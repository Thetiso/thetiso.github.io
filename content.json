{"pages":[{"title":"CV","text":"Thetiso 教育背景#技术栈#项目经验#","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#Create a new post#1$ hexo new &quot;My New Post&quot; More info: Writing Run server#1$ hexo server More info: Server Generate static files#1$ hexo generate More info: Generating Deploy to remote sites#1$ hexo deploy More info: Deployment","link":"/2020/10/30/hello-world/"},{"title":"build Blog-site by Hexo","text":"记录使用hexo搭建github博客的过程(mac) 准备# node npm github账号 START# 全局安装hexo12$ npm i hexo -g$ hexo init Blog 在此site选择hexo的主题，默认主题landscape。很多主题都比较陈旧，坚持维护的不多，我选择的是icarus. 安装icarus123//Blog根目录$ npm install hexo-theme-icarus$ hexo config theme icarus 启动服务12345$ npm i$ hexo s//实际运行可能会报错并提示有部分组件未安装，按照提示安装即可//浏览器地址`localhost:4000`预览//若端口占用，可使用`lsof -i:4000`查看进程，配合`kill -9 ${pid}`指令清除进程 写作#创建分类#12//Blog根目录$ hexo n page categories 打开生成的index.md文件，修改如下 12345---title: categoriesdate: 2020-10-30 10:42:43type: &quot;categories&quot;--- 而后在任意文章顶部标记新的分类名称即可 123456---title: Hexo建站date: 2020-10-30 10:41:03categories:- 建站--- 创建标签#与创建分类同理 12//Blog根目录$ hexo n page tags 打开生成的index.md文件，修改如下 12345---title: tagsdate: 2020-10-30 10:42:43type: &quot;tags&quot;--- 而后在任意文章顶部标记新的分类名称即可 123456---title: Hexo建站date: 2020-10-30 10:41:03tags:- hexo--- 引用图片#在配置文件中允许使用资源文件 1post_aeest_folder: true 在文章中引用的方式参考链接注意: 上述配置对已经创建的文章不会生效，需要重新hexo n XXX才会在_post文件夹下创建同名的资源文件夹，直接将要用的图片丢进去就OK啦 1{% asset_img avatar.jpg %} 如下图 部署#hexo官方提供了配合Travis CI的github pages部署教程， 但是流程实在太长，对新手不友好，推荐使用懒人一键部署 1$ npm install hexo-deployer-git --save 修改_config.yml配置文件,注意同名文件可能有好几个，改的是本目录下的文件 12345deploy: type: 'git' repo: 'https://github.com/xxx/xxx.github.io' branch: master message: 'init' 一键部署 1$ hexo clean &amp;&amp; hexo deploy 其他#markdown语法#折叠#12345&lt;details&gt;&lt;summary&gt;Title&lt;/summary&gt;content!!!&lt;/details&gt; 折叠示例如下 Title content!!! 标注#这是要标注的地方^脚注1，注脚后的冒号请注意，它也是一部分 1234这是要标注的地方[^脚注1]。[^脚注1]: 巴拉巴拉.. 配置主题icarus#bash12$ npm install hexo-theme-icarus$ hexo config theme icarus 如果需要更加个性化定制/修改css等，就需要使用git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus的方式直接导入源码。当然直接下载源码扔到对应文件夹也是OK的，记得去掉git相关文件就行。 开启busuanzi访问统计#_config.icarus.yml &gt; plugins &gt; busuanzi: true即可，记得重新运行hexo,可以在审查元素中查看是否拉取busuanzi.js即可。更加具体的解释和配置可以看这个文章 链接","link":"/2020/10/30/hexo-site/"},{"title":"nginx静态网站优化","text":"本文初略介绍针对静态网站的nginx优化 参考文章一参考文章一 设置nginx配置文件#sh123456789101112131415161718192021server { listen 80; server_name xxx.com gzip on; #开启或关闭gzip on off gzip_static on; gzip_disable &quot;msie6&quot;; #不使用gzip IE6 gzip_min_length 1024; #gzip压缩最小文件大小，超出进行压缩（自行调节） gzip_buffers 4 16k; #buffer 不用修改 gzip_comp_level 8; #压缩级别:1-10，数字越大压缩的越好，时间也越长 gzip_types application/javascript text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; location / { try_files $uri $uri/ /index.html; root /your/site/path/from/root; index index.html; expires 24h; #静态文件缓存时间 }} 请务必核对gzip_types, 本人之前一般js文件是text/javascript格式，导致页面上加载js时，速度极其缓慢 gzip_min_length可以适当设置的小一点 expires 可以大幅度加快文件的读取速度，当然弊端就是遇到更新会触发缓存，自行斟酌。 try_files 是针对vue spa静态站点的设置，为了使浏览器输入具体url时能直达页面，而不是只能看到首页 PS#谨防 HSTS#参考文章 HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。服务器开启HSTS的方法是，当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议响应头中包含Strict-Transport-Security字段。非加密传输时设置的HSTS字段无效。 比如，https://www.liberalman.cn 的响应头含有Strict-Transport-Security: max-age=31536000; includeSubDomains。这意味着两点：在接下来的一年（即31536000秒）中，浏览器只要向xxx或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如，用户点击超链接或在地址栏输入 http://www.liberalman.cn/ ，浏览器应当自动将 http 转写成 https，然后直接向 https://www.liberalman.cn/ 发送请求。 在接下来的一年中，如果 www.liberalman.cn 服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。 服务器端配置HSTS，减少302跳转，其实HSTS的最大作用是防止302 HTTP劫持。HSTS的缺点是浏览器支持率不高，另外配置HSTS后HTTPS很难实时降级成HTTP。同时，也建议启用SPDY来提高性能，不累述。","link":"/2020/12/10/nginx%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"title":"RN项目笔记(基础篇)","text":"本文主要记录在写rn项目过程中的一些要点。 …尴尬，其中使用UI框架为ant-d, 但是其listview在上拉加载的时候无法触发fetch, github上维护看着也不积极。已准备弃用 1. 基础样式 1.1 常用属性 2. 使用要点 2.1 设置本文自动省略 2.2 对文本设置圆角 2.3 文本元素长度auto,不跟随父元素(不超过父元素长度时) 2.4 为Text/View添加点击事件 3. 杂记(开发中遇到的问题) 1. 如何使用熟悉的js中class来设置样式 2. icon框架 react-native-vector-icons ant-ui有多个版本,请务必仔细核对自己的版本是否正确。本文对应的ui框架网站为官网、文档 2020.12.11 目前是混合使用ant和elements框架 1. 基础样式#参考文章 js12345678910111213141516171819202122232425export default class App extends Component&lt;Props&gt; { render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={{color: 'red'}}&gt;I Love React Native!&lt;/Text&gt; &lt;Text style={[styles.fs14, styles.red]}&gt;two styles in array!&lt;/Text&gt; &lt;/View&gt; ); }, }const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, fs14: { fontSize: 14 }, red: { color: 'red' }}); 设定组件/子元素的样式有两种方式： 直接行内设置 通过StyleSheet 需要注意的是， 通过StyleSheet设置的时候，只有一对大括号，而行内需要两对; 当一个元素的样式被分拆成多个时，需要用数组形式 1.1 常用属性#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960width //宽height //高backgroundColoropacity //透明度//边框圆角设置borderTopLeftRadius //左上角圆角borderTopRightRadius //右上角的圆角borderBottomLeftRadius //左下角的圆角borderBottomRightRadius //右下角的圆角borderRadius //所有角的圆角//边框宽度borderLeftWidth //左边边框宽度borderRightWidth //右边边框宽度borderTopWidth //顶部边框宽度borderBottomWidth //底部边框宽度borderWidth //所有边框宽度//边框颜色borderColor //边框颜色marginBottom //距下外边距marginLeft //距左外边距marginRight //距右外边距marginTop //距上外边距marginVertical //垂直外边距(也就是距上,距下边距)marginHorizontal //水平外边距(距左,距右边距)margin //所有边距paddingBottom //距下内边距paddingLeft //距左内边距paddingRight //距右内边距paddingTop //距上内边距paddingVertical//垂直内边距paddingHorizontal //水平内边距padding //所有内边距//图像变换ImagescaleX //水平方向缩放scaleY //垂直方向缩放rotation //旋转translateX //水平方向平移translateY //水平方向平移resizemode //拉伸图片 'cover' ,'strech','contain'//文本Textcolor //文字颜色textAlign //对其方式 ('left','right','auto','center','justify')fontSize //字体大小fontStyle //字体风格 正常:'normal', 斜体:'italic'fontWeight //字体粗细 加粗:'bold', '100', '200' letterSpacing //字符间距lineHeight //行间距textDecorationLine //字体装饰线 下划线:'underline', 删除线:'line-through',下划线删除线:'underline line-through'textDecorationStyle //字体装饰线风格 单线:'solid' 双线:'double' 虚线:'dotted','dashed'textDecorationColor //字体装饰线颜色 2. 使用要点#2.1 设置本文自动省略#Text在设置了文本之后会在到达width的位置自动截断，如果需要设置以省略号...结尾的话需要在行内设置参数 1&lt;Text numberOfLines={1}&gt;我是文本&lt;/Text&gt; 2.2 对文本设置圆角#ios下无法通过给Text设置Radius来设置圆角，需要通过外部加一层View元素设置圆角 12345&lt;View style={{borderRadius: 2}}&gt; &lt;Text style={{height: 20, backgroundColor: '#0c3', color: '#fff'}}&gt; 本文 &lt;/Text&gt;&lt;/View&gt; 2.3 文本元素长度auto,不跟随父元素(不超过父元素长度时)#js1234&lt;View style={{width: 200, flexDirection: 'column'}}&gt; &lt;View style={{width: 100}}&gt;&lt;/View&gt; &lt;Text style={{backgroundColor: 'red'}}&gt;这是文本&lt;/Text&gt;&lt;/View&gt; 上述代码中，从背景色可以发现text元素始终长度和父元素保持一致。此时，如果需要设置Text的长度根据文本来动态变化，则可以通过position来处理.修改后的代码如下： 12345678&lt;View style={{width: 200, flexDirection: 'column'}}&gt; &lt;View style={{width: 100}}&gt;&lt;/View&gt; &lt;View&gt; &lt;View style={{position: 'absolute', borderRadius: 5}}&gt; &lt;Text style={{backgroundColor: 'red'}}&gt;这是文本&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&lt;/View&gt; 2.4 为Text/View添加点击事件#12345678import {TouchableHighlight} from 'react-native';... &lt;TouchableHighlight onPress={this.submit}&gt; &lt;View&gt; &lt;Text&gt;文本 &lt;/View&gt;&lt;/TouchableHighlight&gt; 需要注意的是，TouchableHighlight的子元素只能是一个。 3. 杂记(开发中遇到的问题)#1. 如何使用熟悉的js中class来设置样式#2. icon框架 react-native-vector-icons#123yarn add react-native-vector-iconscd iospod install 如果遇到Unrecognized font family 'Material Icons'报错，则需要修改info.plist 123456789101112131415161718&lt;key&gt;UIAppFonts&lt;/key&gt;&lt;array&gt;&lt;string&gt;AntDesign.ttf&lt;/string&gt;&lt;string&gt;Entypo.ttf&lt;/string&gt;&lt;string&gt;EvilIcons.ttf&lt;/string&gt;&lt;string&gt;Feather.ttf&lt;/string&gt;&lt;string&gt;FontAwesome.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Brands.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Regular.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Solid.ttf&lt;/string&gt;&lt;string&gt;Foundation.ttf&lt;/string&gt;&lt;string&gt;Ionicons.ttf&lt;/string&gt;&lt;string&gt;MaterialIcons.ttf&lt;/string&gt;&lt;string&gt;MaterialCommunityIcons.ttf&lt;/string&gt;&lt;string&gt;SimpleLineIcons.ttf&lt;/string&gt;&lt;string&gt;Octicons.ttf&lt;/string&gt;&lt;string&gt;Zocial.ttf&lt;/string&gt;&lt;/array&gt; 参考文章icon列表从上面的报错也可以知道此框架默认的Icon类别为Material,列表一览列表中的icon名称如果包含下划线，请记得改为短横：_ 改为 -, 貌似是某个版本改过命名规则。","link":"/2020/12/01/rn-ant-ui/"},{"title":"React Native APP开发(1)","text":"采用RN开发APP准备篇 准备工作# RN的准备工作请参考官方教程 UI框架选择的是蚂蚁那套Ant-UI MARK# 度娘能找到的rn教程很多不注明版本号，盲目使用其中的解决方案容易导致项目长跪不起，所以再不确定其版本号的情况下，请尽量使用最新的解决方案 ant-ui分别有对应react和rn的两套版本,请注意区分 引用ant-ui需要在xcode中引用对应的tff文件，否则会出现字体找不到的报错 启动#启动前请先打开xcode确保command tool是最新的 123$ npx react-native init AwesomeProject$ cd AwesomeProject$ yarn react-native run-ios 首次启动比较慢，根据电脑配置几分钟到十几分钟不等 核心组件#react-redux#参考vue的vuex, rn也有对应的状态管理，基本教程请参考此链接 axios#基本用法参照vue内的用法，不再赘述。 react-native-router-flux#对应vue-router, rn的路由管理参考链接, 不是很好理解，需要实际上手 页面传参#参考链接 NEXT 基础篇","link":"/2020/10/30/rn-app-step1/"},{"title":"React Native APP开发(3)","text":"采用RN开发APP进阶篇 常用框架 减少样板代码 简化action creator 1234567891011121314151617function makeActionCreator(type, ...argNames) { return function(...args) { let action = { type } argNames.forEach((arg, index) =&gt; { action[argNames[index]] = args[index] }) return action }}const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'export const addTodo = makeActionCreator(ADD_TODO, 'todo')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') 异步action creator + middleware 第三方授权登录 1. 微信授权 一些注意点 1. safeAreaView只对ios有效 2. setSate webview 保存图片、视频等 相册选择图片/视频、拍照等 safearea兼容 常用框架#参考链接 减少样板代码#简化action creator#1234567891011121314151617function makeActionCreator(type, ...argNames) { return function(...args) { let action = { type } argNames.forEach((arg, index) =&gt; { action[argNames[index]] = args[index] }) return action }}const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'export const addTodo = makeActionCreator(ADD_TODO, 'todo')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') 异步action creator + middleware#继上一篇的异步action， 当我们需要获取用户信息、评论列表、产品列表时，一种方案是抽象一个公共的request来处理各个请求，但是这样做共用了request.state, 无法应对单个请求异常超时的情况。这时候可以考虑换个思路抽象，使用thunk提供的中间件功能。 123456789101112export function loadPosts(userId) { return { // 要在之前和之后发送的 action types types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'], // 检查缓存 (可选): shouldCallAPI: (state) =&gt; !state.users[userId], // 进行取： callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`), // 在 actions 的开始和结束注入的参数 payload: { userId } };} 搭配中间件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function callAPIMiddleware({ dispatch, getState }) { return next =&gt; action =&gt; { const { types, callAPI, shouldCallAPI = () =&gt; true, payload = {} } = action if (!types) { // Normal action: pass it on return next(action) } if ( !Array.isArray(types) || types.length !== 3 || !types.every(type =&gt; typeof type === 'string') ) { throw new Error('Expected an array of three string types.') } if (typeof callAPI !== 'function') { throw new Error('Expected callAPI to be a function.') } if (!shouldCallAPI(getState())) { return } const [ requestType, successType, failureType ] = types dispatch(Object.assign({}, payload, { type: requestType })) return callAPI().then( response =&gt; dispatch(Object.assign({}, payload, { response, type: successType })), error =&gt; dispatch(Object.assign({}, payload, { error, type: failureType })) ) }} 至此，可以用下面的例子构造拉取评论、追加评论的异步action 1234567891011121314151617181920212223export function loadComments(postId) { return { types: ['LOAD_COMMENTS_REQUEST', 'LOAD_COMMENTS_SUCCESS', 'LOAD_COMMENTS_FAILURE'], shouldCallAPI: (state) =&gt; !state.posts[postId], callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`), payload: { postId } };}export function addComment(postId, message) { return { types: ['ADD_COMMENT_REQUEST', 'ADD_COMMENT_SUCCESS', 'ADD_COMMENT_FAILURE'], callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`, { method: 'post', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({ message }) }), payload: { postId, message } };} 第三方授权登录#1. 微信授权#参考文章 https://www.cnblogs.com/lude1994/p/10784457.html https://www.npmjs.com/package/react-native-wechat https://www.jianshu.com/p/b1a081165fba 一些注意点#1. safeAreaView只对ios有效#2. setSate#js1234567891011this.setState({ name: 'abc',})console.log(this.state.name) // 输出并不是abc//正确的写法应该是this.setState({ name: 'abc'}, ()=&gt; { console.log(this.state.name) //abc}) webview# 参考文章1参考文章2 失效github 保存图片、视频等# yarn add @react-native-community/camerarollios需要配置info.list NSPhotoLibraryUsageDescription 你懂的安卓需要额外配置权限npm说明 相册选择图片/视频、拍照等# github项目 bash1234567yarn add react-native-image-picker# RN &gt;= 0.60cd ios &amp;&amp; pod install# RN &lt; 0.60react-native link react-native-image-picker safearea兼容# 参考文章","link":"/2020/11/04/rn-app-step3/"},{"title":"rn-elements","text":"本文介绍react-native-elements在rn项目中的使用。 参考文章官方文档","link":"/2020/12/02/rn-elements/"},{"title":"sentry-docker","text":"服务器端使用docker部署sentry服务端。 部署参考文章sentry官方文档 架构#Q：Sentry到底是如何实现实时日志监控报警的呢？A：Sentry是一个C/S架构，我们需要在自己应用中集成Sentry的SDK(支持前后端语言)才能在应用发生错误是将错误信息发送给Sentry服务端。根据语言和框架的不同，我们可以选择自动或自定义设置特殊的错误类型报告给Sentry服务端。Sentry的服务端分为web、cron、worker这几个部分，应用（客户端）发生错误后将错误信息上报给web，web处理后放入消息队列或Redis内存队列，worker从队列中消费数据进行处理，postgresql对数据持久化。 my-sentry：sentry的web服务 sentry-cron：sentry的定时任务，活性检测 sentry-worker：业务处理，数据持久化，报警 综上，想在自建服务器上搭建sentry服务端需要跑多个docker容器，请选购稍微大点的配置。 安装#服务器系统环境: centos: 7+ docker: 1.31.1 12345678910111213141516171819# 获取镜像，可能会比较慢docker pull sentry docker pull redisdocker pull postgres# 启动服务docker run -d --name sentry-redis --restart=always redis ###保证了，异常自动拉起docker run -d --name sentry-postgres -e POSTGRES_PASSWORD=密码 -e POSTGRES_USER=sentry --restart=always postgres# 生成sentry秘钥，记得保存哦~docker run --rm sentry config generate-secret-key# 数据库及账户初始化、需要你设置的账号就是WEB的登录账号和密码，稍微有点慢docker run -it --rm -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry upgrade# 启动WEBdocker run -d -p 9000:9000 --name my-sentry -e SENTRY_SECRET_KEY='秘钥' --link sentry-redis:redis --link sentry-postgres:postgres --restart=always sentry# 启动sentry-cron/work服务docker run -d --name sentry-cron -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry run crondocker run -d --name sentry-worker-1 -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry run worker# 查看所有容器，是否有某明奇妙挂了的docker ps -a 在http://{ip}:9000上开始探索新大陆吧~ WEB# 好不犹豫就是Installation Instructions走起来，选择vue项目 傻眼了，刚才登录后的那个设置页面写错了地址，导致sentry.init配置项直接出现了ip…=&gt; 用nginx给9000配置一个域名 1npm install @sentry/browser main.js12345678910import Vue from 'vue'import * as Sentry from '@sentry/browser';import * as Integrations from '@sentry/integrations';Sentry.init({ dsn: 'http://8565417f11494c2b9ad05524717464a9@xxxx.yyy.com/1', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: '20210121v1', //版本号 logErrors: true //开发环境下打印错误}); 这个dsn会报错cros.但是可以不用管，不影响使用。=&gt; 找到好的解决办法再来补充 TEST#在首页mounted中随便写个console.log(abc)，运行页面即可。MARK: 如果使用try-catch把上面的log包含的话，sentry并不能捕获到。 稍微改造下引入函数，只在生产环境中使用sentry 1234567process.env.NODE_ENV == 'production' &amp;&amp; Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: '20210121v1', //版本号 logErrors: true //开发环境下打印错误}); 快速定位错误#获取token的参考文章配置参数位置的参考文章-官方文档配置参数答疑vue/cli4+的插件答疑 安装#我使用的是vue/cli 4+， 所以第一篇文章讲的web.config.js没用上，参照了插件答疑的文章进行配置 12#安装cnpm install --save-dev @sentry/webpack-plugin vue.config.js1234567891011121314151617181920212223242526272829303132333435363738const SentryWebpackPlugin = require(&quot;@sentry/webpack-plugin&quot;);//拼接路径function resolve(dir) { return path.join(__dirname, dir)}module.exports = { // ...其他配置 chainWebpack: config =&gt; { // ...其他插件 config .plugin('@sentry/webpack-plugin') .use( new SentryWebpackPlugin({ release:&quot;20210121v9&quot;, authToken: 'xxxxx', project: 'project_name', url: 'http://xxx.yyy.com', org: 'org_name', include: &quot;.&quot;, ignoreFile: &quot;.sentrycliignore&quot;, ignore: [&quot;node_modules&quot;, &quot;webpack.config.js&quot;], // configFile: &quot;sentry.properties&quot;, urlPrefix:&quot;~/js&quot; }) ) },}//plugin配置例子1chainWebpack(config) { config.plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin)}//plugin配置例子2const MyPlugin = require('plugin')config.plugin('plugin').use(new MyPlugin()) 获取配置参数#token# url# project# org# 测试#一开始跑得很流畅，但是后续几个上传sourceMap之后就无法定位错误位置，才明白是urlPrefix配置错误。 1这个 --url-prefix 是你线上访问到js文件的路径，~ 就是你网站的根目录，比如我网站的静态文件是这样 http://192.168.144.163:8080/static/js/xxxx.js，那么按照上面例子填就是正确的，因为我网站根目录就是 http://192.168.144.163:8080，上传成功后可以在 Releases -&gt; Artifacts 中看到刚才上传的文件 我的线上项目访问js是这样的：http://xx.yy.com/js/chunk.xxxx.js =&gt;所以urlPrefix得配置成 ~/js 配置sourseMap前的报错是这样的 配置后的报错定位。请注意右手边的一排小按钮，可以切换 =&gt; 快速定位报错位置 优化#为了成为项目应用，需要在开发环境中屏蔽sentry, 同时将版本号统一管理。 main.js123456process.env.NODE_ENV == 'production' &amp;&amp; Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: process.env.VUE_APP_RELEASE_VERSION, //版本号 logErrors: true //开发环境下打印错误}); vue.config.js12345678910111213141516process.env.NODE_ENV == 'production' &amp;&amp; config .plugin('@sentry/webpack-plugin') .use( new SentryWebpackPlugin({ release: process.env.VUE_APP_RELEASE_VERSION, authToken: 'f38e0c1683e84581be211f4ffce5287d2c776fd78fac4afba4c30ab92a2b9f39', project: 'abc', url: 'http://xxx.yyy.com', org: 'sentry', include: &quot;.&quot;, ignoreFile: &quot;.sentrycliignore&quot;, ignore: [&quot;node_modules&quot;, &quot;webpack.config.js&quot;], // configFile: &quot;sentry.properties&quot;, urlPrefix:&quot;~/js&quot; }) ) Q &amp; A#Q: error pulling image configuration: unknown blob# 查看docker文件 /etc/docker/daemon.json (没有的话 手动创建下), 我之前用的是163的镜像，切换成aliyun的。 打开阿里云容器镜像服务页面, 加加速器地址复制到上述json中。123{ &quot;registry-mirrors&quot;: [&quot;https://7ctk7xl2.mirror.aliyuncs.com&quot;]} 重启docker,记得把其他容器也重新跑起来。一般改了阿里云之后，拉取镜像的速度会起飞。 Q： chrome下的cors问题#我的服务端版本号是9.1.2， vue端是7在safari中上传没问题，报错时只发送一次xxx.yyy.com/api/2/store?xxx=xxxx.但是到了chrome下，出了上述报错外，还额外发了两次xxx.yyy.com/api/2/envelope?xxx=xxxx一开始还以为是客服端的cors配置出了问题，尝试半天未果。然后有怀疑是chorme的问题，还关掉了ad-block等，依旧不能解决。最后在官方github下看到这个issueSeems I can fix it by adding startTransactionOnPageLoad: false in BrowserTracing, closed然并卵！！！ 最终，我把nginx配置设置成这样 123456789101112131415161718server { listen 80; server_name xxx.yyy.com; proxy_set_header Connection ''; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Request-Id $request_id; proxy_read_timeout 30s; proxy_send_timeout 5s; location / { proxy_pass http://sentryServer; }} main.js123456789101112Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [ new Integrations.Vue({Vue, attachProps: true}), new TracingIntegrations.BrowserTracing({ startTransactionOnPageLoad: false, }), ], release: process.env.VUE_APP_RELEASE_VERSION, //版本号 logErrors: true, //开发环境下打印错误 // _experiments: { useEnvelope: true },}); sentry服务端设置： projects -&gt; your_project -&gt; setting -&gt; general settings -&gt; domain 改为* stroe请求正常发送，envelope依旧不消停。 sad~ 知道原因的小伙伴请速速留言！！！","link":"/2021/01/21/sentry-docker/"},{"title":"vue-step-by-step","text":"vue教程(在实际项目中的基本使用) Step 1 起步 编辑器 VS Code cnpm 运行项目 项目结构 Step 2 组件的生命周期 页面 vue-router 全局钩子 路由钩子 组件钩子 vuex - store Step 3 思考 More keepActive的存在意义 为什么router-link时使用name vue-bus 全局通知 Step 4 优化加载 混入 自定义指令 客户端数据库 loki.js 服务端渲染 Nuxt 国际化 i18n 规范总结 Step 1#起步#vue有大版本区别，建议使用最新版。@vue/cli对于vue就像是spring-boot-starter对于spring-boot一样。 sh1234567## 全局安装cli工具，以后开发都会用到，所以建议全局安装npm install -g @vue/clicd someDir ..## 创建项目vue create step-by-step# ORvue ui vue create之后默认选择就行ESLint一开始会有所不适应，可以先放放。至此,创建一个叫做step-by-step项目。 编辑器 VS Code#和所有前端项目一样，可以直接使用idea/eclipse/sublime等工具来编写vue项目，在此推荐vscode cnpm#cnpm是国内采用淘宝镜像的组件工具，相比npm，获取依赖速度大大加快。以后项目中都会用到，建议全局安装。 12npm install cnpm -gnpm install cnpm -g --registry=https://registry.npm.taobao.org 运行项目#12345cd step-by-step#获取依赖cnpm i #测试运行npm run serve 不出意外将在命令窗口看到如下输出语句 12345DONE Compiled successfully in 1901ms 2:16:44 PMApp running at:- Local: http://localhost:8080/ - Network: http://192.168.3.32:8080/Note that the development build is not optimized. 项目结构#初始的项目距离开发需求还很远，先对项目结构做一下补充。 12345678910111213141516+ public+ src + assets - css //需要自己创建 - images //需要自己创建 + components + layouts //需要自己创建 + pages //需要自己创建 + configs //需要自己创建 + apis //需要自己创建 + utils //需要自己创建 - App.vue - main.js- vue.config.js //需要自己创建- babel.config.js- package.json 一个呈现在浏览器上的页面需要符合这样的层级结构：app &gt; layout &gt; page &gt; component。当我们项目需要不同的框架布局时，就可以定义不同的layout。举例子：正常浏览器访问查询列表的时候，我们需要header和footer，但是当我们的页面被别的项目用iframe引用时，就需要全局调整header和footer Step 2#组件的生命周期#改造初始后的项目，使其符合上一节所说的层级结构。阅读下面内容前，请先查看DEMO-S1从console中我们能看到打印结果为 1234567891011before layout createlayout createdbefore header createheader createdbefore content createcontent createdbefore footer createfooter createdheader mountedcontent mountedfooter mounted 由此，当我们在项目中加载数据的时候就需要注意了，layout/page/compontent各个阶段加载数据的先后顺序。父组件先create -&gt; 子组件 create -&gt; 子组件mounted -&gt; 父组件mounted 页面#阅读下面内容前，请先查看DEMO-S2了解了组件加载的先后顺序，我们尝试写一个符合规范的页面.为此我们需要新增依赖。 sh12cnpm i vue-router axios vuex --save# 记得重新npm run serve vue-router#基本用法: 123456789101112131415161718import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter);const router = new VueRouter({ mode: 'history', routes: [ { path: '/', //懒加载 component: () =&gt; import('../pages/index.vue') //or component: IndexPage } ]});export default router router-view 在src/components/common/content中包含这个标签，可以理解为根据配置的router来匹配组件。参考文档 router 与 钩子 全局钩子: beforeEach与afterEach的使用，配合store来查询用户权限、追加日志等 路由独享: 组件钩子: 全局钩子# to:router即将进入的路由对象 from:当前导航即将离开的路由 next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。 1234567891011121314151617181920212223router.beforeEach((to, from, next) =&gt; { console.log(store.state.token) const route = ['index', 'list']; let isLogin = store.state.token; // 是否登录 // 未登录状态；当路由到route指定页时，跳转至login if (route.indexOf(to.name) &gt;= 0) { if (isLogin == null) { router.push({ path: '/login', }); } } // 已登录状态；当路由到login时，跳转至home console.log(to.name) localStorage.setItem('routerName', to.name) if (to.name === 'login') { if (isLogin != null) { router.push({ path: '/HomeMain', });; } } next();});router.afterEach((to, from) =&gt; { console.log(to.fullPath, to.path, location.href)}); 路由钩子#12345678910111213const router = new VueRouter({ mode: 'history', routes: [ { path: '/dashboard', //懒加载 component: resolve =&gt; require(['../components/page/Dashboard.vue'], resolve) meta: { title: '系统首页' }, beforeEnter: (to, from, next) =&gt; { }, beforeLeave: (to, from, next) =&gt; { }, } ]}); 组件钩子#12345678910111213141516171819&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data: ()=&gt; ({}), beforeRouteLeave(to, from, next) { next() }, beforeRouteEnter(to, from, next) { next() }, beforeRouteUpdate(to, from, next) { next() }, computed: {}, method: {}}&lt;/script&gt; vuex - store#官方文档 state:驱动应用的数据源； view: 以声明方式将 state 映射到视图； actions: 响应在 view 上的用户输入导致的状态变化。 mutation: 原函数改变state的数据 action: 异步请求 -&gt; 有必要的话可以在返回前调用mutation12this.$store.commit('clearUsrInfo') //mutationthis.$store.dispatch('getProductList') //action Step 3#思考#对于SPA项目，各种数据请求/处理应该在哪个位置发生？带着以下问题查看DEMO-S3 有登录用户吗？ 存在本地化的授权token 校验token是否有效 用户的基本信息什么时候更新，保存在哪？那些数据虽然需要，但不需要本地化? 只存token,其他数据在必要的时候远程更新 当前用户有权查看当前页面信息吗？ 查store校验 调用远程接口由后台判断 -&gt; nuxt 用户的浏览行为在哪里发出？逐个页面发送日志，还是统一发送？ 借用钩子(全局钩子/路由钩子) 不同级别的用户对应不同的界面/菜单，我应该在哪个层进行识别才能避免用户看到不该看的信息？ 根据数据敏感程度自行斟酌：低敏感度、高敏感度 api统一管理的意义何在？是否需要全部使用action 可以适当偷懒，直接调用axios 统一管理：解耦合 More#阅读以下以下代码时，请先查看DEMO-S4 keepActive的存在意义#router.js12345678910111213const router = new Router({ ... routes: [ { name: 'test', path: '/test', component: ()=&gt; import('@/pages/test/index'), meta: { keepAlive: true } } ] }) compontents/xx.js1234&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 为什么router-link时使用name#当我们需要修改某个页面的路径的时候，不必逐个页面修改，只需要在router.js中修改path即可。 vue-bus 全局通知#1cnpm i --save vue-bus 123456789101112import VueBus from 'vue-bus'Vue.use(VueBus)this.$bus.on('some-action', actionHandle)this.$bus.once('some-action-happen-once', actionHandle)this.$bus.emit('some-action', paylod)actionHanlle: function(paylod) {} Step 4#优化加载#阅读以下代码请先查看DEMO-S5 外部引用 loki.js为例 在public/index.html中顶部引用外部script 在vue.config.js中配置映射关系 按需引用 element-ui为例123456789101112131415161718192021222324252627/* 第一步cnpm i --save babel-preset-envcnpm i --dev babel-plugin-component*///第二步修改.babel.config.jsmodule.exports = { presets: [ '@vue/cli-plugin-babel/preset', ], plugins: [ // element官方教程 [ &quot;component&quot;, { libraryName: &quot;element-ui&quot;, styleLibraryName: &quot;theme-chalk&quot; } ] ]}//第三部在main.js中import { Button } from 'element-ui';Vue.use(Button);//第四部实际组件中&lt;el-button @click=&quot;addTodo&quot;&gt;Vue-Bus&lt;/el-button&gt; 包分析package.json123456// cnpm i -D webpack-bundle-analyzer// 追加指令 &quot;scripts&quot;: { ... &quot;analyz&quot;: &quot;npm run build --analyze&quot; }, vue.config.js123456789101112131415161718const path = require('path');//拼接路径function resolve(dir) { return path.join(__dirname, dir)}module.exports = { ... chainWebpack: config =&gt; { config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) config.resolve.alias .set('@', resolve('src')) .set('#', resolve('public')) },} gzip nginx配置缓存和压缩 webpack压缩设置 混入#阅读以下代码请先查看DEMO-S5对于需要鉴权的页面，都会包含用户的基本信息，怎么才能避免每个组件都复制黏贴呢？ -&gt; 全局混入demo中我们点击/mine页面中的按钮可以直接修改header中的显示。 main.js1234567891011Vue.mixin({ created: function () {}, //混入对象的钩子将在组件自身钩子之前调用 computed: { ...mapState({ citySN: state =&gt; state.citySN }), ...mapGetters({ authBJS: 'fromBJS', }) },}) 其他还有组件混入等，可以查看官方文档。需要注意各种混入方式中遇到名称冲突时的规则。 自定义指令#在手机端页面上常常会有这样的需求：页面/组件打开(show)时自动focus输入框 -&gt; 自定义指令focus官方文档我们修改之前根据三字码查询机场名称的代码（/loki页面） 123456789directives: { focus: { // 指令的定义 inserted: function (el) { let ipt = el.hasChildNodes() ? el.querySelector('input') : el ipt.focus() } }}, 客户端数据库 loki.js#Github关键是看下examples。结合localStorage避免页面多次加载json。 服务端渲染 Nuxt#准备额外开文章说，暂且略过。 国际化 i18n#官方文档 规范总结# 保证项目文档结构 vue页面/组件内尽可能少使用axios请求，统一到apis/xxx.js目录下 梳理store.state内容,灵活使用getters localStorage.item中只存储必要信息，切勿将state全部存在localStorage中(若后期增减/修改字段会需要额外维护) 利用router钩子进行鉴权，避免暴露敏感页面 抽象request.js，为所有api使用，保证数据处理的一致性(主要是错误编码、报错信息的一致) 灵活使用router-view组件，减少页面渲染 组件间(非父子关系)时，使用vue-bus,切勿使用localStorage 使用混入，减少组件的重复代码 外部引用、按需引用、代码压缩等优化加载。","link":"/2021/01/08/vue-step-by-step/"},{"title":"前端基础之页面渲染与网路请求","text":"新开主题介绍计算机基础，其实也是前端的基础！ 页面渲染 DOM CSSOM 加载JS Render Tree 页面的重绘（repaint）与重排（reflow） 重绘（repaint）： 重排/回流（reflow）： NOTE 1. 重排必将引起重绘，而重绘不一定会引起重排。 2. 何时回引起重排？ 3. **如何减少和避免重排 ** 网络请求 TCP 三次握手建立连接 TCP 四次握手断开连接 Q &amp; A 为什么要将js放到页脚部分 引入样式的几种方式的权重 css属性书写顺序建议 何种类型的DOM操作是耗费性能的 参考文档 Q:从用户输入浏览器输入url到页面最后呈现 有哪些过程？ 用户输入URL地址 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存） 浏览器将端口号从URL中解析出来 浏览器建立一条与目标Web服务器的TCP连接（三次握手） 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器返回一条HTTP响应报文 关闭连接 浏览器解析文档 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕 页面渲染#主流的两个浏览器内核为WebKit 和 Gecko(Mozilla) 两者在用词上稍有差异，但主题流程基本为： HTML解析出DOM Tree CSS解析出Style Rules 将二者关联生成Render Tree Layout 根据Render Tree计算每个节点的信息 Painting 根据计算好的信息绘制整个页面 DOM#DOM树构建过程： 读取html文档， 将字节转换成字符， 确定tokens（标签）， 再将tokens转换成节点，以节点构建 DOM 树 CSSOM#CSSOM树构建过程与DOM树构建流程一致： 读取CSS文档， 将字节转换成字符， 确定tokens（标签）， 再将tokens转换成节点，以节点构建 CSSOM 树 加载JS#若在构建DOM树的过程中，当 HTML 解析器遇到一个 script 标记时，即遇到了js，将立即阻塞DOM树的构建，将控制权移交给 JavaScript 引擎，等到 JavaScript 引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建。 其根本原因在于，JS会对DOM节点进行操作，浏览器无法预测未来的DOM节点的具体内容，为了防止无效操作，节省资源，只能阻塞DOM树的构建。譬如，若不阻塞DOM树的构建，若JS删除了某个DOM节点A，那么浏览器为构建此节点A花费的资源就是无效的。 若在HTML头部加载JS文件，由于JS阻塞，会推迟页面的首绘。为了加快页面渲染，一般将JS文件放到HTML底部进行加载，或是对JS文件执行async或defer加载。 Render Tree#渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。 构建渲染树，根据渲染树计算每个可见元素的布局，并输出到绘制流程，将像素渲染到屏幕上。 页面的重绘（repaint）与重排（reflow）#重绘（repaint）：#屏幕的一部分要重绘。渲染树节点发生改变，但不影响该节点在页面当中的空间位置及大小。譬如某个div标签节点的背景颜色、字体颜色等等发生改变，但是该div标签节点的宽、高、内外边距并不发生变化，此时触发浏览器重绘（repaint）。 重排/回流（reflow）：#当渲染树节点发生改变，影响了节点的几何属性（如宽、高、内边距、外边距、或是float、position、display：none;等等），导致节点位置发生变化，此时触发浏览器重排（reflow），需要重新生成渲染树。譬如JS为某个p标签节点添加新的样式：”display:none;”。导致该p标签被隐藏起来，该p标签之后的所有节点位置都会发生改变。此时浏览器需要重新生成渲染树，重新布局，即重排（reflow）。 NOTE#1. 重排必将引起重绘，而重绘不一定会引起重排。#2. 何时回引起重排？#当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排： 添加或者删除可见的DOM元素； 元素位置改变——display、float、position、overflow等等； 元素尺寸改变——边距、填充、边框、宽度和高度 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变； 页面渲染初始化； 浏览器窗口尺寸改变——resize事件发生时； 3. **如何减少和避免重排 **#Reflow 的成本比 Repaint 的成本高得多的多。一个节点的 Reflow 很有可能导致子节点，甚至父节点以及兄弟节点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）； 让要操作的元素进行”离线处理”，处理完后一起更新； 使用DocumentFragment进行缓存操作,引发一次回流和重绘； 使用display:none技术，只引发两次回流和重绘； 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存； 让元素脱离动画流，减少回流的Render Tree的规模； 网络请求#TCP 三次握手建立连接#TCP 四次握手断开连接#Q &amp; A#为什么要将js放到页脚部分#引入样式的几种方式的权重#css属性书写顺序建议#何种类型的DOM操作是耗费性能的#参考文档#参考文档1how browsers workhow browsers work中文翻译","link":"/2021/01/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BD%91%E8%B7%AF%E8%AF%B7%E6%B1%82/"},{"title":"算法基础-递归","text":"L. Peter Deutsch 说过：To Iterate is Human, to Recurse, Divine.中文译为：人理解迭代，神理解递归。 概念#递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。 =&gt; 数学归纳法 数学归纳法适用于将解决的原问题转化为解决它的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在相同的逻辑归纳处理项。当然有一个是例外的，也就是归纳结束的那一个处理方法不适用于我们的归纳处理项，当然也不能适用，否则我们就无穷归纳了 三要素#明确递归终止条件#我们知道，递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递去而是开始实实在在的归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。 给出递归终止时的处理办法#我们刚刚说到，在递归的临界点存在一种简单情境，在这种简单情境下，我们应该直接给出问题的解决方案。一般地，在这种情境下，问题的解决方案是直观的、容易的。 提取重复的逻辑，缩小问题规模#我们在阐述递归思想内涵时谈到，递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，我们需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。 编程模型#模型一： 在递去的过程中解决问题#12345678function recursion(大规模){ if (end_condition) { // 明确的递归终止条件 end; // 简单情景 } else { // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题 solve; // 递去 recursion(小规模); // 递到最深处后，不断地归来 }} 模型二： 在归来的过程中解决问题#12345678function recursion(大规模){ if (end_condition) { // 明确的递归终止条件 end; // 简单情景 } else { // 先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题 recursion(小规模); // 递去 solve; // 归来 }} 例子#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235/*** Title: 阶乘的实现 * Description:* 递归解法* 非递归解法* @author rico*/const Factorial = (n)=&gt; { if(n == 1) // 递归终止条件 return 1; // 简单情景 return n * Factorial(n-1); // 相同重复逻辑，缩小问题的规模}/** 斐波那契数列如下：* 1,1,2,3,5,8,13,21,34,...*/const fibonacci = (n)=&gt; { if (n == 1 || n == 2) return 1; return fibonacci(n-1) + fibonacci(n-2);}/** * @description 对经典递归法的优化 * * 斐波那契数列如下： * * 1,1,2,3,5,8,13,21,34,... * * 那么，我们可以这样看：fib(1,1,5) = fib(1,2,4) = fib(2,3,3) = 5 * * 也就是说，以1,1开头的斐波那契数列的第五项正是以1,2开头的斐波那契数列的第四项， * 而以1,2开头的斐波那契数列的第四项也正是以2,3开头的斐波那契数列的第三项， * 更直接地，我们就可以一步到位：fib(2,3,3) = 2 + 3 = 5,计算结束。 * * 注意，前两个参数是数列的开头两项，第三个参数是我们想求的以前两个参数开头的数列的第几项。 * 时间复杂度：O(n)* * @param first 数列的第一项* @param second 数列的第二项* @param n 目标项* @return */const optimizeFibonacci = (first, second, n)=&gt; { if (n &gt; 0) { if(n == 1){ // 递归终止条件 return first; // 简单情景 }else if(n == 2){ // 递归终止条件 return second; // 简单情景 }else if (n == 3) { // 递归终止条件 return first + second; // 简单情景 } return optimizeFibonacci(second, first + second, n - 1); // 相同重复逻辑，缩小问题规模 } return -1;}/** * 杨辉三角 * 杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。* 它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。* * 例如，下面给出了杨辉三角形的前4行： * 1 * 1 1* 1 2 1* 1 3 3 1* @description 递归获取杨辉三角指定行、列(从0开始)的值* 注意：与是否创建杨辉三角无关* @x 指定行* @y 指定列 */const trangleValue = (x, y)=&gt; { if(y &lt;= x &amp;&amp; y &gt;= 0){ if(y == 0 || x == y){ // 递归终止条件 return 1; }else{ // 递归调用，缩小问题的规模 return trangleValue(x-1, y-1) + trangleValue(x-1, y); } } return -1;}/** * @description 递归判断一个字符串是否是回文字符串 * @param s * @return */const isPalindromeString_recursive = (s)=&gt; { let start = 0; let end = s.length - 1; if(end &gt; start){ // 递归终止条件:两个指针相向移动，当start超过end时，完成判断 if(s.charAt(start) != s.charAt(end)){ return false; }else{ // 递归调用，缩小问题的规模 return isPalindromeString_recursive(s.substring(start+1).substring(0, end-1)); } } return true;}/** * 字符串全排列 * @description 从字符串数组中每次选取一个元素，作为结果中的第一个元素;然后，对剩余的元素全排列* @param s* 字符数组* @param from* 起始下标* @param to* 终止下标*/const getStringPermutations3 = (s, from, to)=&gt; { if (s != null &amp;&amp; to &gt;= from &amp;&amp; to &lt; s.length &amp;&amp; from &gt;= 0) { // 边界条件检查 if (from == to) { // 递归终止条件 console.log(s); // 打印结果 } else { for (let i = from; i &lt;= to; i++) { swap(s, i, from); // 交换前缀,作为结果中的第一个元素，然后对剩余的元素全排列 getStringPermutations3(s, from + 1, to); // 递归调用，缩小问题的规模 swap(s, from, i); // 换回前缀，复原字符数组 } } } }const swap = (s, from, to)=&gt; { let temp = s[from]; s[from] = s[to]; s[to] = temp;}/*** @description 二分查找的递归实现* @param array 目标数组* @param low 左边界* @param high 右边界* @param target 目标值* @return 目标值所在位置*/const binarySearch = (array, low, high, target)=&gt; { //递归终止条件 if(low &lt;= high){ let mid = (low + high) &gt;&gt; 1; if(array[mid] == target){ return mid + 1; // 返回目标值的位置，从1开始 } else if(array[mid] &gt; target){ // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除 return binarySearch(array, low, mid-1, target); } else{ // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除 return binarySearch(array, mid+1, high, target); } } return -1; //表示没有搜索到}/*** Title: 递归求解二叉树的深度*/const getTreeDepth = (t) =&gt; { // 树为空 if (t == null) // 递归终止条件 return 0; let left = getTreeDepth(t.left); // 递归求左子树深度，缩小问题的规模 let right = getTreeDepth(t.left); // 递归求右子树深度，缩小问题的规模 return left &gt; right ? left + 1 : right + 1;}/* 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。*/var generateParenthesis = function (n) { const res = []; const dfs = (lRemain, rRemain, str) =&gt; { // 左右括号所剩的数量，str是当前构建的字符串 if (str.length == 2 * n) { // 字符串构建完成 res.push(str); // 加入解集 return; // 结束当前递归分支 } if (lRemain &gt; 0) { // 只要左括号有剩，就可以选它，然后继续做选择（递归） dfs(lRemain - 1, rRemain, str + &quot;(&quot;); } if (lRemain &lt; rRemain) { // 右括号比左括号剩的多，才能选右括号 dfs(lRemain, rRemain - 1, str + &quot;)&quot;); // 然后继续做选择（递归） } }; dfs(n, n, &quot;&quot;); // 递归的入口，剩余数量都是n，初始字符串是空串 return res;};/* 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。*/function ListNode(val, next) { this.val = (val===undefined ? 0 : val) this.next = (next===undefined ? null : next)}var reverseKGroup = function(head, k) { if(!head) return head; let tmpArray = [], tmpHeader = new ListNode(head.val, head.next) for(let i = 0; i &lt; k; i++) { if(tmpHeader) { tmpArray.push(tmpHeader) } else { break; } tmpHeader = tmpHeader.next } if(tmpArray.length &lt; k) { return head } let nextUnitHeader = reverseKGroup(tmpHeader, k) for(let i = k - 1; i &gt; 0; i --) { let node = tmpArray[i] node.next = tmpArray[i-1] } tmpArray[0].next = nextUnitHeader return tmpArray[k-1]};let reverseKGroupNode1 = new ListNode(1)let reverseKGroupNode2 = new ListNode(2, reverseKGroupNode1)let reverseKGroupNode3 = new ListNode(3, reverseKGroupNode2)let reverseKGroupNode4 = new ListNode(4, reverseKGroupNode3) 参考文档#csdn","link":"/2021/02/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92/"},{"title":"canvas-weapp-h5","text":"忙完公司关于海报制作的需求，开这篇文章扯扯canvas！ fabric.js 画布 canvas 文本、图片：最基本的海报要素 Text Image 图层高度 自定义编辑框 自定义编辑功能 联调 1. 授权验证 WE-APP APP(RN) 2. 选择照片 WE-APP APP(RN) 3. 传递数据 WE-APP APP(RN) NOTE safeArea qrcode 二维码 fabricObject自定义附加字段 服务端处理 截取指定区域 字体 最开始的需求是在小程序内简单实现可以手动编辑的海报，不是根据数据直接套模板生成海报。找了github, 最终选的是疑似酷家乐团队的Painter。用下来基本能满足需求，但是遇到了两个问题： 新需求：可能需要整APP，那就意味着我得有个RN下的canvas组件、或者就是H5上整canvas; 调试困难：不知道是不是系统原因还是啥，mac上跑小程序编辑器一直都不是很流畅，一旦页面上跑得东西多了，动不动就可以去喝杯咖啡.. sad 接下来的小程序页面中又多加了一个需求：需要将整好的数据直接导出成图片。 首先想到的就是wxml-to-canvas。 用这还行，不过考虑到后续APP也会有相同的需求，最终把wxml-to-canvas放下，选择了H5上的canvas方案。wxml-to-canvas没法直接使用iconfont, 得把icon换成img才行。 在H5的现有方案中，首先选中的是小飞飞的easy-canvas. 但这个项目尚未支持z-index, 担心后续有图层调整相关的要求，无奈放弃。在小飞飞推荐下，开始折腾fabric.js 不用翻墙就能看的官网地址 github上有好心的前人写了中文文档. 稍微有点久远，不过用来初步入门已经足够了。 在此，就不赘述一些基本使用方法，直接按照项目中常见的需求来展开。 fabric.js#画布 canvas#12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;canvas-box&quot;&gt; &lt;canvas id=&quot;canvas&quot; :width='width' :height='height'&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import {fabric} from 'fabric';export default { data: ()=&gt; ({ width: 360, height: 640, canvas: '' }), created: function() { //预加载数据,组装等 }, mounted: function() { //canvas赋值必须得等页面加载之后才行 this.canvas = new fabric.Canvas('canvas') }, methods: { }}&lt;/script&gt; 文本、图片：最基本的海报要素#fabric.js项目作者将所有画布上的对象抽象为fabric.Object。其他所有的文本、图像之类全是基于这个基类。 Text#12345678910111213141516171819202122232425262728let obj = { text: '文本内容', //这里有借鉴Painter项目 css: { left: 100, top: 100, fontWeight: 600, color: '#fff', }}let text = new fabric.Text( obj.text, { left: obj.css.left, top: obj.css.top, fontFamily: 'Comic Sans' , fontSize: obj.css.fontSize || 20, fontWeight: obj.css.fontWeight, fill:obj.css.color, originX: obj.css.originX ||'left', })//绑定点击(选中)事件，默认是支持的，这里是为了调用自定义的编辑框text.on('selected', _this.selectedHandle)//可以配置fabric.Object不可被选中text.set('selectable', !!obj.editAble);this.canvas.add(text);//moveTo方法将在后续控制层高的地方讲到text.moveTo(1) Text有个进阶的Object: IText tips: Text可以设置padding, 默认的编辑框border距离文本实在是太近了，尤其是需要自定义编辑框按钮的时候，挨得太近根本没办法好好显示按钮，通过设置这个参数，就可以开心的留一些区域给按钮啦 Image#12345678910111213141516171819202122232425262728//加载跨域图片new fabric.Image.fromURL(obj.url, function(img) { //这里img.width/height是图片的原始宽高，单位px console.log(img.width , img.height, obj.css.width) let scaleRatio = obj.css.width / img.width //通过scale使图片适应设定的宽高 img.scale(scaleRatio); //可以设置翻转 // oImg.scale(0.5).set('flipX, true); img.on('selected', _this.selectedHandle) img.top = obj.css.top img.left = obj.css.left //不设置height,避免选择框不能匹配图像边缘 img.on('selected', _this.selectedHandle) img.set('selectable', !!obj.editAble);}, {crossOrigin: 'anonymous'})//加载本地图片// &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;// &lt;img src=&quot;my_image.png&quot; id=&quot;my-image&quot;&gt;var canvas = new fabric.Canvas('c');var imgElement = document.getElementById('my-image');var imgInstance = new fabric.Image(imgElement, { left: 100, top: 100, angle: 30, opacity: 0.85});canvas.add(imgInstance); 加载跨域图片时候需要设置crossOrigin参数。 所有的fabric.Object下子类都是公用编辑框(controls)的 加载图片是个异步操作，不能保证所有Object的先后顺序。这就需要配合之前所说的moveTo函数来控制其图层高度。 图层高度#点此查看介绍文档 图层高度同z-index, 数值大的可以遮挡数值小的。控制图层一般用到这几个方法： 12345obj.bringToFront(); // 置顶obj.bringForward(); // 向上一层obj.sendToBack(); // 置底obj.sendBackwards(); // 向下一层obj.moveTo(n); // 设置层高N 自定义编辑框#fabric.js自带的编辑框还是蛮丑的… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103selectedHandle: function() { //getActiveObject()可以获取当前被选中的对象 -&gt; 进而获取其类型 let type = this.canvas.getActiveObject() ? this.canvas.getActiveObject().type : null type &amp;&amp; this.setupEditBox(type) //如果是文本, 则显示文本编辑菜单，如果是图片则显示图片菜单 this.showTextMenu = type == 'text' this.showImgMenu = type == 'image'},setupEditBox: function(targetType) { //首先隐藏默认的编辑框上的所有小点(按钮) Object.values(fabric.Object.prototype.controls).forEach(c =&gt; c.visible = false); //可以理解为原生按钮支持的事件handler let controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls; //icon直接用的base64 png图片，这里不适合全部黏贴上来，后续补充demo的时候，可以去demo查看 //编辑框画自定义的按钮还没尝试其他方法... 后续尝试下新的放方法 let _this = this, editIcon64 = 'data:image/png;base64,...' let eidtIconImg = document.createElement('img'); eidtIconImg.src = editIcon64; let scaleIcon64 = 'data:image/png;base64,...' let scaleIconImg = document.createElement('img'); scaleIconImg.src = scaleIcon64; let textCloseIcon64 = 'data:image/png;base64,...'; let textCloseIconImg = document.createElement('img'); textCloseIconImg.src = textCloseIcon64; //edit即为这个新按钮的名称，可以随意取 fabric.Object.prototype.controls.edit = new fabric.Control({ x: 0, //x y是以Object中心点为0的, 向上为Y负轴， 向左为X负轴 y: -0.5, //0.5其实指的是 height * 0.5 offsetY: -30, //30的单位是px cursorStyle: 'pointer', mouseUpHandler: _this.showEditPopover, //点击事件的handler，请看下一小节 render: renderTextEditIcon, //自定义绘制按钮 cornerSize: 32, visible: targetType == 'text' }); fabric.Object.prototype.controls.scale = new fabric.Control({ x: 0.5, y: 0.5, cursorStyle: 'pointer', render: renderImageScaleIcon, cornerSize: 32, actionHandler:scalingEqually, visible: targetType == 'image' }); fabric.Object.prototype.controls.text_close = new fabric.Control({ x: 0, y: 0.5, offsetY: 30, cursorStyle: 'pointer', render: renderTextCloseIcon, cornerSize: 32, mouseUpHandler: _this.deleteTextHandle, visible: targetType == 'text' }); //其实我也不想在这里写function, 试了下写外面，结果绘制没成功... sad function renderImageScaleIcon(ctx, left, top, styleOverride, fabricObject) { let w = 32, h = 32; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(scaleIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw edit box for img done') } function renderTextEditIcon(ctx, left, top, styleOverride, fabricObject) { let w = 32, h = 32; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(eidtIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw edit icon for text done') } function renderTextCloseIcon(ctx, left, top, styleOverride, fabricObject) { let w = 30, h = 30; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(textCloseIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw close icon for text done') }}, 自定义编辑功能#在controls.edit我们指定了mouseUpHandler为showEditPopover。control.close用了一样的方式来获取点击事件。 12345678910showEditPopover: function(eventData, target) { //没直接用传参 let obj = this.canvas.getActiveObject() if (!obj || obj.type != 'text') { return } //如果是文本被点击，则弹出modle允许编辑 this.showTextEditModel = true; this.textEditModelContent = obj.text}, 当我们的model中修改文本内容完成，则可以用下面的方法替换画布上的文本 12345678confirmTextEdit: function() { let obj = this.canvas.getActiveObject() if (!!obj &amp;&amp; obj.type == 'text') { obj.text = this.textEditModelContent } this.canvas.requestRenderAll(); //重新渲染画布 this.showTextEditModel = false //清除model}, 联调#涉及到联调的主要是这几个功能点： we-app的授权验证 选取移动端本地(相册)的照片 fabric.js生成的图片传给APP或者we-app使用 1. 授权验证#WE-APP#先引入wx-jdk，我是先在index.html顶部加载，然后通过vue的配置来获取的 vue.config.js12345configureWebpack: { externals: { 'weixin-js-sdk': 'wx' },}, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364created: function() { let _this = this //确认是否是在小程序中 wx.miniProgram.getEnv(function(res) { console.log(res.miniprogram) _this.weAppEnv = res.miniprogram })},mounted: function() { if(this.weAppEnv) { this.initWxConfig() }},methods: { initWxConfig: function() { let url = window.location.href url = url.split('#')[0] const promise = axios.get('/api/wechat/h5/sign/share' + '?app_id=' + this.appId + '&amp;url=' + url); promise.then(res =&gt; { if (res.data.code == 200) { const sign = res.data.data; this._wxConfigJSSDK(sign); } }); promise.catch((err) =&gt; { console.log(err.response); }) }, _wxConfigJSSDK: function(sign){ wx.config({ debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: sign.appId + '', // 必填，公众号的唯一标识 timestamp: parseInt(sign.timestamp), // 必填，生成签名的时间戳 nonceStr: sign.nonceStr + '', // 必填，生成签名的随机串 signature: sign.signature + '',// 必填，签名 jsApiList: ['chooseImage', 'downloadImage', 'previewImage', 'uploadImage'] // 必填，需要使用的JS接口列表 }) wx.ready(function(){ wx.checkJsApi({ jsApiList: [ 'chooseImage', 'previewImage', 'uploadImage', 'downloadImage' ], success: function (res) { if (res.checkResult.getLocation == false) { console.error('你的微信版本太低，不支持微信JS接口，请升级到最新的微信版本！'); return; }else{ console.log('授权成功', res) } }, fail: err=&gt; { console.log(err) } }); }); wx.error(function(res){ console.error(res) }); },} 中间涉及到一个appId,即为调用该页面的小程序关联的公众号appid 当我们需要调用分享(APP、H5内),就需要进行签名。具体逻辑参照官方文档 切记将这个fabric.js所在的域名添加到公众号下的安全域名内，没错，公众号！！！和小程序关联的公众号，同主体，同开发者平台账号下 切记将这个fabric.js所在的域名添加到小程序的合法业务域名下 小程序开发工具-网页模式可以用来调试当前fabric.js页面 小程序开发工具-小程序模式没办法使用模拟器来测试授权，必须真机测试！！！一般来说上一步的网页模式测试没问题，真机也不会有问题 不涉及选择照片功能的话，可以不授权。 APP(RN)#RN内好像没涉及授权问题 2. 选择照片#WE-APP#借用wx-js-sdk来手机上的照片，也可以支持拍照。前提是完成wx.config 1234567891011121314151617181920212223242526272829303132_getLocalImage: function() { let _this = this return new Promise((resolve, reject)=&gt; { wx.chooseImage({ count: 1, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) { var localIds = res.localIds; // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 let targetImgId = localIds[0] console.log('wkwebview is' + !!window.__wxjs_is_wkwebview) wx.getLocalImgData({ localId: targetImgId, success: (res) =&gt; { let localData = res.localData // localData是图片的base64数据，可以用img标签显示 if (localData.indexOf('data:image') != 0) { //判断是否有这样的头部 =&gt; 兼容安卓机型（安卓机不包含data头） localData = 'data:image/jpeg;base64,' + localData } resolve(localData) }, fail: err=&gt; { reject(err) } }) }, fail: err=&gt; { reject(err) } }); })}, APP(RN)#rn中的选择照片就相对简单一点。主要是用到组件react-native-image-picker 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;Avatar containerStyle={styles.avatar} rounded size=&quot;large&quot; source={{ uri: 'https://' + this.props.agent.avatar }} title={!this.props.agent.avatar ? '店': null} &gt; &lt;Avatar.Accessory name=&quot;edit&quot; size={25} onPress={()=&gt; { let options = { mediaType: 'photo', maxWidth: '320', maxHeight: '320', quality: '0.8', }, callback = async (res) =&gt; { if(res &amp;&amp; res.uri) { let loading = Toast.loading('即将上传，请稍候', 0) let token = await applyToken() if(token) { Toast.remove(loading) let uploadLoading = Toast.loading('正在上传', 0), key = 'agent/avatar/' + this.props.agent.id + '/' + new Date().getTime() + '.jpg' upload( { key: key, path: res.uri.replace('file://', ''), //这个是关键 mimeType: res.type, token: token, zone: ZONE.HUABEI, }, null ).then(data =&gt; { console.log(data) Toast.remove(uploadLoading) Toast.success('上传成功', 2, ()=&gt; { let avatarURL = 'oss-xxx.XXX.com/' + data.key this.props.updateAgentAvatar({avatar: avatarURL}) //追加同步服务器的步骤 }) }) .catch(err =&gt; { console.error(err) if (err.code === CODE.UPLOAD_FAILURE) { console.log('upload error') } }) } } } launchImageLibrary(options, callback) }} /&gt;&lt;/Avatar&gt; 3. 传递数据#WE-APP#H5传数据给小程序的webview，难点在于接收数据的时机和页面切换。 用户点击H5上的生成海报时，先将base64数据postMsg给小程序，然后执行wx.miniProgram.redirectTo(‘url?params’) 嵌套H5的页面中webview绑定msgHandler接收H5传上来的数据,并存storage 跳转后的页面接收params, 稍作定时(假装loading)后，从storage中获取数据，转base64为本地文件展示。 APP(RN)#h512345let obj = { type: 'generate-img', img: cripedImage //base64}window.ReactNativeWebView &amp;&amp; window.ReactNativeWebView.postMessage(JSON.stringify(obj)) rn1234567891011121314151617181920212223242526272829//为了更好的区分H5是谁调用的，可以在此webview中设置前缀script(后续再补充)&lt;WebView onLoad={(e) =&gt; console.log('onLoad')} onLoadEnd={(e) =&gt; console.log('onLoadEnd')} onLoadStart={(e) =&gt; console.log('onLoadStart')} renderError={() =&gt; { console.log('renderError') return &lt;View&gt;&lt;Text&gt;renderError回调了，出现错误&lt;/Text&gt;&lt;/View&gt; }} renderLoading={() =&gt; { return &lt;View&gt;&lt;Text&gt;这是自定义Loading...&lt;/Text&gt;&lt;/View&gt; }} source={{uri: this.state.url}} //h5页面地址 style={{marginTop: 20}} onMessage={this._onMessage} //接收上面传过来的参数/&gt;_onMessage = (event)=&gt; { let webString = event.nativeEvent ? event.nativeEvent.data : '' if(webString) { let obj = JSON.parse(webString) if(obj &amp;&amp; obj.type == 'generate-img') { Actions['poster-preview']({ img: obj.img }) return } } console.log('H5-&gt;RN传参错误')} NOTE#safeArea#qrcode 二维码#fabricObject自定义附加字段#服务端处理#参考文档 截取指定区域#参考文档 123456789101112131415161718192021222324252627282930313233/** Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately* @param {Object} [options] Options object* @param {String} [options.format=png] The format of the output image. Either &quot;jpeg&quot; or &quot;png&quot;* @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.* @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent* @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14* @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14* @param {Number} [options.width] Cropping width. Introduced in v1.2.14* @param {Number} [options.height] Cropping height. Introduced in v1.2.14* @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0* @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format* @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}*/// @example &lt;caption&gt;Generate jpeg dataURL with lower quality&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'jpeg', quality: 0.8 });// @example &lt;caption&gt;Generate cropped png dataURL (clipping of canvas)&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'png', left: 100, top: 100, width: 200, height: 200 });// @example &lt;caption&gt;Generate double scaled png dataURL&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'png', multiplier: 2 }); 字体#Q: 小程序内嵌H5， H5使用fabric, 但画布上的英文字很明显不是选用的字体? (后来发现这个是Times New Roman)A: 最开始怀疑是微信浏览器最字体做了限制，官方文档,后台注意到嵌入fabric的H5页面，非canvas内部的字体并没有受到影响。至此： 字体支持应该是设置的字体在电脑端(测试时)存在，但真机时并没有 尝试在真机上设置Text的字体为苹方，上述猜想得到证实 接下来就是得想办法让真机能支持自己设置的字体-&gt; 区分机型，并为不同机型寻找合适的字体PS: 至于node端设置字体，请参考这个文章","link":"/2020/12/28/canvas-weapp-h5/"},{"title":"React Native APP开发(2)","text":"采用RN开发APP基础篇 React基础 1. class组件 2. 路由-组件跳转 3. 状态管理 action reducer Store 数据流 全局引用 异步Action 4. 数据持久化 后记 React基础#安利个网站snack，方便在线调试自己写的代码(尤其是起步阶段，避免眼高手低) 可以不用注册，保存个链接，必要的时候赋值代码进去修改/运行 1. class组件#javascript123456789import React, { Component } from 'react';import { Text } from 'react-native';export default class Cat extends Component { render() { return ( &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; ); }} props对应外部传入的参数， 一般不在内部修改state对应组件内部的参数, 根据用户交互行为变更/赋值 javascript12345678910111213141516171819202122232425262728293031323334import React, { Component } from &quot;react&quot;;import { Button, Text, View } from &quot;react-native&quot;;export class Cat extends Component { state = { isHungry: true }; render() { return ( &lt;View&gt; &lt;Text&gt; I am {this.props.name}, and I am {this.state.isHungry ? &quot; hungry&quot; : &quot; full&quot;}! &lt;/Text&gt; &lt;Button onPress={() =&gt; { this.setState({ isHungry: false }); }} disabled={!this.state.isHungry} title={ this.state.isHungry ? &quot;Pour me some milk, please!&quot; : &quot;Thank you!&quot; } /&gt; &lt;/View&gt; ); }}export default class Cafe extends Component { render() { return ( &lt;&gt; &lt;Cat name=&quot;Munkustrap&quot; /&gt; &lt;Cat name=&quot;Spot&quot; /&gt; &lt;/&gt; ); }} 在class形式的组件中，不用管props的内部结构，只需要注意引用组件时怎么传递参数。 state 参数的命名方式需要注意。 onPress赋值的应该是一个函数，也可以直接提出来写 render返回必须用()包起来， 所有的模板内容必须用一个元素包起来，不能出现并列的多个元素javascript12345678910111213141516171819202122232425import React, { Component } from 'react';import { Text, Button, View } from 'react-native';export default class Cat extends Component { state = { showName: false, } showName = ()=&gt; { if(this.state.showName) return; this.setState({ showName: true }) } render() { return ( &lt;View&gt; &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; { this.state.showName ? (&lt;Text&gt;My name is Lily!&lt;/Text&gt;) : (null)} &lt;Button onPress={this.showName} title=&quot;show my name&quot;&gt;&lt;/Button&gt; &lt;/View&gt; // &lt;View&gt; // &lt;Text&gt;这个View-Text不能写, 类似于Vue只能有一个根元素&lt;/Text&gt; // &lt;/View&gt; ); }} 2. 路由-组件跳转#类似于vue-router，rn的路由管理组件为react-native-router-flux, 需要注意的是该组件有多个大版本，对应不同版本的react-navigation，查阅文档的时候请先留意版本是否匹配。官方还有react-router方案可选.当前以最新版V4.2.0为例。 首先构建两个页面(sence) javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//login.jsimport React, {Component} from 'react';import {View, Text, SafeAreaView,StatusBar} from 'react-native';import {Actions} from &quot;react-native-router-flux&quot;;export default class Login extends Component { gotoRegister = (params)=&gt; { Actions.register() } render() { return ( &lt;&gt; &lt;StatusBar&gt;&lt;/StatusBar&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text&gt;登录页面&lt;/Text&gt; &lt;Button onPress={this.gotoRegister} type=&quot;primary&quot; title=&quot;没有账号，立即注册&quot;&gt;&lt;/Button&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); }}//import React, {Component} from 'react';import {View, Text, SafeAreaView,StatusBar} from 'react-native';import {Actions} from &quot;react-native-router-flux&quot;;export default class Register extends Component { gotoIndex = (params)=&gt; { Actions.reset('index', {}) } render() { return ( &lt;&gt; &lt;StatusBar&gt;&lt;/StatusBar&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text&gt;注册页面&lt;/Text&gt; &lt;Button onPress={this.gotoIndex} type=&quot;primary&quot; title=&quot;前往首页&quot;&gt;&lt;/Button&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); }} 构建APP.js javascript123456789101112131415161718192021222324import React, { Component } from 'react';import Login from './container/Login';import Register from './container/Register';import Index from './container/Index';import {Stack, Scene, Router, Actions, Tabs} from 'react-native-router-flux';export default class App extends Component&lt;Props&gt; { render() { return ( &lt;Router&gt; &lt;Stack key=&quot;root&quot; title=&quot;测试&quot;&gt; &lt;Scene key=&quot;login&quot; component={Login} initial=&quot;true&quot; //设置默认页面 title=&quot;Login&quot; /&gt; &lt;Scene key=&quot;register&quot; component={Register} title=&quot;Register&quot; /&gt; &lt;Scene key=&quot;index&quot; component={Index} hideNavBar /&gt; &lt;/Stack&gt; &lt;/Router&gt; ); }} react-native-router-flux提供了便捷的路由跳转API,可以通过在app.js内设置的sence.key搭配Actions直接跳转 javascript123456let props = { shopId: 123}Actions.login(props)// 等同于Actions.push('login', props) 常用的的API如下, javascript123456789101112131415// 返回上一页面Actions.pop();// 返回指定页面(堆栈中)Actions.popTo('key'); // 刷新页面Actions.refresh({ param1: 'hello', param2: 'world' });// 清空当前页面堆栈，重新打开指定的页面Actions.reset('index', props)// tabbar之间切换Actions.jump('key') 3. 状态管理#APP内往往需要全局共享用户的登录状态、昵称、头像等，这时候就需要状态管理组件react-redux。在使用react-redux之前，先了解下redux的一些基本概念。 action reducer store NOTE应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。惟一改变 state 的办法是触发 action(一个描述发生什么的对象)。为了描述 action 如何改变 state 树，你需要编写 reducers。 action#Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。 javascript12345678910//建议单独文件存放const ADD_TODO = 'ADD_TODO'import { ADD_TODO, REMOVE_TODO } from '../actionTypes'//action对象{ type: ADD_TODO, text: 'Build my first Redux app'} action creator之前说action是一个普通对象，action creator则是一个函数，根据传参来返回需要的action.如果我们把store对应的state想象成是一个人， 那么action就是各种人所包含动作的描述。 javascript123456789{ type: '跑步',}{ type: '平躺',}... action除type可以自定义各种属性，所以我们可以这样来细化action javascript12345678910111213141516{ type: '跑步', speed: '慢速',}{ type: '跑步', speed: '中速',}{ type: '跑步', speed: '快速',}... 这时候我们就会想，需要根据某个传参(比如说跑步前吃的多不多)来确定自己具体使用哪个action(跑多快),这就引出了creator函数 javascript12345678910111213141516171819function run(payload) { if(payload.full == 1) { return { type: '跑步', speed: '慢速', } } else if (payload.full == 0) { return { type: '跑步', speed: '快速', } } else { return { type: '跑步', speed: '中速', } }} 进一步， 我们也会根据其他参数来定义更加丰富的action(根据零花钱来确定是跑回去呢，还是打车等等)总的来看action creator的思路和java中的工厂模式类似。 javascript12345678910111213141516171819202122232425262728293031323334/* * action 类型 */export const ADD_TODO = 'ADD_TODO';export const TOGGLE_TODO = 'TOGGLE_TODO'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'/* * 其它的常量 */export const VisibilityFilters = { SHOW_ALL: 'SHOW_ALL', SHOW_COMPLETED: 'SHOW_COMPLETED', SHOW_ACTIVE: 'SHOW_ACTIVE'}/* * action 创建函数 */export function addTodo(text) { return { type: ADD_TODO, text }}export function toggleTodo(index) { return { type: TOGGLE_TODO, index }}export function setVisibilityFilter(filter) { return { type: SET_VISIBILITY_FILTER, filter }} Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。 javascript12dispatch(addTodo(text))dispatch(completeTodo(index)) 或者创建一个 被绑定的 action 创建函数 来自动 dispatch： javascript12const boundAddTodo = text =&gt; dispatch(addTodo(text))const boundCompleteTodo = index =&gt; dispatch(completeTodo(index)) 然后直接调用它们： javascript12boundAddTodo(text);boundCompleteTodo(index); reducer#reducer 是一个纯函数，接收旧的 state 和 action，返回新的 state。 1(previousState, action) =&gt; newState 保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 1234567891011121314151617181920212223242526272829303132333435import { WALK, RUN, TAXI } from './actions'const initialState = { useVehicle: false, costMoney: false speed: null};function backHome(state, action) { if (typeof state === 'undefined') { return initialState } //处理其他action return state}//上述undefined的判断可以精简为如下function todoApp(state = initialState, action) { switch (action.type) { case WALK.type: return Object.assign({}, state, { useVehicle: false, costMoney: false speed: '5km/h' }) case RUN.type: return { ...state, useVehicle: false, costMoney: false speed: '15km/h' }) default: return state }} reducer合并 12345678910111213141516import { combineReducers } from 'redux'const todoApp = combineReducers({ visibilityFilter, mytodo: todos})export default todoApp//等价于export default function todoApp(state = {}, action) { return { visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) }} Store#Store的功能： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器。 12345import { createStore } from 'redux'import todoApp from './reducers'let store = createStore(todoApp)// 设置初始状态let store = createStore(todoApp, window.STATE_FROM_SERVER) 数据流#严格的单向数据流是 Redux 架构的设计核心。应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。 Redux 应用中数据的生命周期遵循下面 4 个步骤： 调用 store.dispatch(action); Redux store 调用传入的 reducer 函数: Store 会把两个参数(当前的 state 树和 上述action)传入 reducer; 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树 Redux store 保存了根 reducer 返回的完整 state 树 NOTE Redux 和 React 之间没有关系 Redux 的 React 绑定库(react-redux)是基于 容器组件和展示组件相分离 的开发思想 全局引用#React Redux 组件 让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。 123456789101112131415import React from 'react'import { render } from 'react-dom'import { Provider } from 'react-redux'import { createStore } from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp)render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 异步Action#默认情况下，createStore() 所创建的 Redux store 没有使用 middleware，所以只支持 同步数据流。你可以使用 applyMiddleware() 来增强 createStore()。虽然这不是必须的，但是它可以帮助你用简便的方式来描述异步的 action。像 redux-thunk 或 redux-promise 这样支持异步的 middleware 都包装了 store 的 dispatch() 方法，以此来让你 dispatch 一些除了 action 以外的其他内容，例如：函数或者 Promise。你所使用的任何 middleware 都可以以自己的方式解析你 dispatch 的任何内容，并继续传递 actions 给下一个 middleware。比如，支持 Promise 的 middleware 能够拦截 Promise，然后为每个 Promise 异步地 dispatch 一对 begin/end actions。当 middleware 链中的最后一个 middleware 开始 dispatch action 时，这个 action 必须是一个普通对象。这是 同步式的 Redux 数据流 开始的地方（译注：这里应该是指，你可以使用任意多异步的 middleware 去做你想做的事情，但是需要使用普通对象作为最后一个被 dispatch 的 action ，来将处理流程带回同步方式）。项目中，我们常常会需要发起异步请求，这时候action就会需要异步等待请求的结果(success or fail)。请先在项目引入redux-thunk，以发起请求为例 actions123{ type: 'REQUEST_POST' }{ type: 'RECEIVE_POSTS', error: 'Oops', response: null }{ type: 'RECEIVE_POSTS', response: { ... }, error: null } 构建action creator, 三个同步action: 发起请求 请求成功 请求失败123456789101112131415161718192021222324//通知 reducer 请求开始的 actionexport function requestPosts(){ return { type: REQUEST_POSTS, isFetch:true //进度条相关 }} //通知 reducer 请求成功的 actionexport function receviePostOnSuccess(data){ return { type: RECEIVE_POSTS, isFetch:false, amount: data }} //通知 reducer 请求失败的 action。export function receviePostOnError( message){ return{ type: RECEIVE_POSTS, isFetch:false, errorMsg:message }} 假设我们的请求是用来获取阅读量amount, 实际项目中建议改为data12345const initState={ isFetch: false, amount: 0, errorMsg: null,} reducers12345678910111213141516171819export function request_reducer(state=initState, action) { console.log(action.type, JSON.stringify(action)) switch (action.type){ case REQUEST_POSTS: return { ...state, isFetch: action.isFetch ? true : false, } case RECEIVE_POSTS: return { ...state, isFetch: false, amount: action.amount ? action.amount : 0, errorMsg: action.errorMsg ? action.errorMsg : null } default: return state; }} 异步action的关键在于action creator返回的不是一个简单对象{type: ...}, 而是一个函数/Promise(归功于thunk) 1234567891011121314151617181920212223242526272829//最核心的异步操作export function fetchAmount() { return axios.get('http://www.baidu.com')}//异步action//异步请求action 【将上面3个基础的action整合】export function getAmountPromise(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) const {num} = getState() return new Promise((resolve, reject)=&gt; { let success = (res)=&gt; { setTimeout(()=&gt; { dispatch(receviePostOnSuccess(num.number)) resolve(res) }, 2000) }, fail = (err)=&gt; { console.log(error); dispatch(receviePostOnError('error')) reject(err) } fetchAmount().then(success, fail) }) }} 完整例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//一个异步请求import axios from 'axios';const REQUEST_POSTS = &quot;REQUEST_POST&quot;;const RECEIVE_POSTS = &quot;RECEIVE_POSTS&quot;;const initState={ isFetch: false, amount: 0, errorMsg: null,}export function request_reducer(state=initState, action) { console.log(action.type, JSON.stringify(action)) switch (action.type){ case REQUEST_POSTS: return { ...state, isFetch: action.isFetch ? true : false, } case RECEIVE_POSTS: return { ...state, isFetch: false, amount: action.amount ? action.amount : 0, errorMsg: action.errorMsg ? action.errorMsg : null } default: return state; }}export function fetchAmount() { return axios.get('http://www.baidu.com')}//通知 reducer 请求开始的 actionexport function requestPosts(){ return { type: REQUEST_POSTS, isFetch:true //进度条相关 }} //通知 reducer 请求成功的 actionexport function receviePostOnSuccess(data){ return { type: RECEIVE_POSTS, isFetch:false, amount: data }} //通知 reducer 请求失败的 action。export function receviePostOnError( message){ return{ type: RECEIVE_POSTS, isFetch:false, errorMsg:message }} //异步请求action 【将上面3个基础的action整合】//写法一export function getAmount(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 // console.log( JSON.stringify(this), JSON.stringify(_this)) console.log(&quot;==================&quot;) dispatch(requestPosts()) const {num} = getState() //异步请求后端接口 return fetchAmount().then( data=&gt; { console.log(num); dispatch(receviePostOnSuccess(num.number)) }, error=&gt; { console.log(error); dispatch(receviePostOnError('error')) } ) }}//异步请求action 【将上面3个基础的action整合】//写法二export function getAmountPromise(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) const {num} = getState() return new Promise((resolve, reject)=&gt; { let success = (res)=&gt; { setTimeout(()=&gt; { dispatch(receviePostOnSuccess(num.number)) resolve(res) }, 2000) }, fail = (err)=&gt; { console.log(error); dispatch(receviePostOnError('error')) reject(err) } fetchAmount().then(success, fail) }) }} 4. 数据持久化#TODO 后记#写异步action的时候一直有疑惑，如果把所有的网络请求都用redux的思路来写的话，这个代码量简直爆炸。请教了之前写RN的朋友，被告知，异步网络请求可以不走action, 简单封装下axios, 统一管理API即可。","link":"/2020/10/30/rn-app-step2/"},{"title":"前端基础之JS基本","text":"很多时候都会想不起或者忽略这些基础概念。有空的时候还是得老老实实看一遍记一遍。 切勿眼高手低~ 组成 原始值和引用值 Undefined Null Boolean Number String 类型转换 转换成字符串 转换成数值 parseInt parseFloat 强制类型转换 引用类型 Object Boolean 对象 Number 对象 toFixed() 方法 toExponential() 方法 toPrecision() 方法 =&gt; 取N位有效数 String 对象 length charAt() 和 charCodeAt() 方法 es6 concat() 方法 indexOf() 和 lastIndexOf() 方法 localeCompare() 方法 slice() 和 substring() toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase() 提示 instanceof 运算符 等性运算符 等号(==)与非等号(!==) 全等号与非全等号 Function length属性 Function 对象 闭包 简单的闭包 复杂的闭包 对象类型 本地对象 内部对象 宿主对象 继承 对象冒充 对象冒充可以实现多重继承 call() apply() 原型链 混合 组成#JavaScript 由以下 3 个不同部分组成的： 核心（ECMAScript）: 描述js的语法和基本对象 文档对象模型（DOM）: 处理网页内容的方法和接口 浏览器对象模型（BOM）: 与浏览器进行交互的方法和接口 DOMDOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物 BOMIE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的标准。 BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括： 弹出新的浏览器窗口 移动、关闭浏览器窗口以及调整窗口大小 提供 Web 浏览器详细信息的定位对象 提供用户屏幕分辨率详细信息的屏幕对象 对 cookie 的支持 IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象 由于没有相关的 BOM 标准，每种浏览器都有自己的 BOM 实现。有一些事实上的标准，如具有一个窗口对象和一个导航对象，不过每种浏览器可以为这些对象或其他对象定义自己的属性和方法。 原始值和引用值#在 ECMAScript 中，变量可以存在两种类型的值，即原始值和引用值。 原始值存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。引用值存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的原始类型之一，即 Undefined、Null、Boolean、Number 和 String 型。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。 在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript 打破了这一传统。 如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 原始类型ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String。ECMA-262 把术语类型（type）定义为值的一个集合，每种原始类型定义了它包含的值的范围及其字面量表示形式。 ECMAScript 提供了 typeof 运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。 1234var sTemp = &quot;test string&quot;;alert (typeof sTemp); //输出 &quot;string&quot;alert (typeof 86); //输出 &quot;number&quot;console.log(typeof 1 == 'number') //true 对变量或值调用 typeof 运算符将返回下列值之一： undefined - 如果变量是 Undefined 类型的 boolean - 如果变量是 Boolean 类型的 number - 如果变量是 Number 类型的 string - 如果变量是 String 类型的 object - 如果变量是一种引用类型或 Null 类型的 NOTE注释：为什么 typeof 运算符对于 null 值会返回 &quot;Object&quot;。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。 Undefined# 当声明的变量未初始化时，该变量的默认值是 undefined。 当函数无明确返回值时，返回的也是值 “undefined”123456789var oTemp;alert(typeof oTemp); //输出 &quot;undefined&quot;alert(typeof oTemp2); //输出 &quot;undefined&quot;function testFunc() {}alert(testFunc() == undefined); //输出 &quot;true&quot; 前面的代码对两个变量输出的都是 “undefined”，即使只有变量 oTemp2 从未被声明过。如果对 oTemp2 使用除 typeof 之外的其他运算符的话，会引起错误，因为其他运算符只能用于已声明的变量上。 Null#另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。 尽管这两个值相等，但它们的含义不同: undefined 是声明了变量但未对其初始化时赋予该变量的值， null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。1alert(null == undefined); //输出 &quot;true&quot; Boolean#Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。 即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的。 12var bFound = true;var bLost = false; Number#ECMA-262 中定义的最特殊的类型是 Number 类型。这种类型既可以表示32 位的整数，还可以表示64 位的浮点数。 直接输入的（而不是从另一个变量访问的）任何数字都被看做 Number 类型的字面量。 八进制数和十六进制数 整数也可以被表示为八进制（以 8 为底）或十六进制（以 16 为底）的字面量。八进制字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7） 十六进制的字面量，首位数字必须为 0，后面接字母 x，然后是任意的十六进制数字（0 到 9 和 A 到 F）。这些字母可以是大写的，也可以是小写的 浮点数要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量对于浮点字面量的有趣之处在于，用它进行计算前，真正存储的是字符串。 科学计数法对于非常大或非常小的数，可以用科学计数法表示浮点数，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数 特殊的 Number 值 Number.MAX_VALUE 和 Number.MIN_VALUE Number.POSITIVE_INFINITY 和 Number.NEGATIVE_INFINITY Infinity NaN 当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 Number.MIN_VALUE 的计算也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。 事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。Number.POSITIVE_INFINITY 的值为 Infinity。Number.NEGATIVE_INFINITY 的值为 -Infinity。 由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用 isFinite() 方法，以确保该数不是无穷大 NaN 是个奇怪的特殊值。一般说来，这种情况发生在类型（String、Boolean 等）转换失败时。例如，要把单词 blue 转换成数值就会失败，因为没有与之等价的数值。与无穷大一样，NaN 也不能用于算术计算。NaN 的另一个奇特之处在于，它与自身不相等，这意味着下面的代码将返回 false 1234alert(NaN == NaN); //输出 &quot;false&quot;//不推荐使用 NaN 值本身。函数 isNaN() 会做得相当好：alert(isNaN(&quot;blue&quot;)); //输出 &quot;true&quot;alert(isNaN(&quot;666&quot;)); //输出 &quot;false&quot; String#String 类型的独特之处在于，它是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种国际字符集，本教程后面将讨论它）。 字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1： 字符串字面量是由双引号（”）或单引号（’）声明的。而 Java 则是用双引号声明字符串，用单引号声明字符。但是由于 ECMAScript 没有字符类型，所以可使用这两种表示法中的任何一种 类型转换#转换成字符串#Boolean 值、数字和字符串的原始值的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。Number 类型的 toString() 方法比较特殊，它有两种模式，即默认模式和基模式。采用默认模式，toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）在默认模式中，无论最初采用什么表示法声明数字，Number 类型的 toString() 方法返回的都是数字的十进制表示。因此，以八进制或十六进制字面量形式声明的数字输出的都是十进制形式的.采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。 1234567891011121314var sColor = &quot;red&quot;;alert(sColor.length); //输出 &quot;3&quot;var bFound = false;alert(bFound.toString()); //输出 &quot;false&quot;//默认模式var iNum1 = 10;var iNum2 = 10.0;alert(iNum1.toString()); //输出 &quot;10&quot;alert(iNum2.toString()); //输出 &quot;10&quot;//基模式var iNum = 10;alert(iNum.toString(2)); //输出 &quot;1010&quot;alert(iNum.toString(8)); //输出 &quot;12&quot;alert(iNum.toString(16)); //输出 &quot;A&quot; 转换成数值# parseInt parseFloat 前者把值转换成整数，后者把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。 parseInt#1234var iNum1 = parseInt(&quot;12345red&quot;); //返回 12345var iNum1 = parseInt(&quot;0xA&quot;); //返回 10var iNum1 = parseInt(&quot;56.9&quot;); //返回 56var iNum1 = parseInt(&quot;red&quot;); //返回 NaN parseInt() 方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。 12345678var iNum1 = parseInt(&quot;AF&quot;, 16); //返回 175var iNum1 = parseInt(&quot;10&quot;, 2); //返回 2var iNum2 = parseInt(&quot;10&quot;, 8); //返回 8var iNum3 = parseInt(&quot;10&quot;, 10); //返回 10//如果十进制数包含前导 0，那么最好采用基数 10，这样才不会意外地得到八进制的值var iNum1 = parseInt(&quot;010&quot;); //返回 8var iNum2 = parseInt(&quot;010&quot;, 8); //返回 8var iNum3 = parseInt(&quot;010&quot;, 10); //返回 10 parseFloat#parseFloat() 方法与 parseInt() 方法的处理方式相似，从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数。 不过，对于这个方法来说，第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。parseFloat() 会把这个小数点之前的字符转换成数字。这意味着字符串 &quot;11.22.33&quot; 将被解析成 11.22。 使用 parseFloat() 方法的另一不同之处在于，字符串必须以十进制形式表示浮点数，而不是用八进制或十六进制。该方法会忽略前导 0，所以八进制数 0102 将被解析为 102。对于十六进制数 0xA，该方法将返回 NaN，因为在浮点数中，x 不是有效字符。（注释：经测试，具体的浏览器实现会返回 0，而不是 NaN。） 此外，parseFloat() 方法也没有基模式。 12345678var fNum1 = parseFloat(&quot;12345red&quot;); //返回 12345var fNum2 = parseFloat(&quot;0xA&quot;); //返回 NaNvar fNum3 = parseFloat(&quot;11.2&quot;); //返回 11.2var fNum4 = parseFloat(&quot;11.22.33&quot;); //返回 11.22var fNum5 = parseFloat(&quot;0102&quot;); //返回 102var fNum6 = parseFloat(&quot;red&quot;); //返回 NaNvar fNum7 = parseFloat(&quot;abc.123&quot;); //返回 NaNvar fNum7 = parseFloat(&quot;.123abc&quot;); //返回 0.123 强制类型转换#ECMAScript 中可用的 3 种强制类型转换如下： Boolean(value) - 把给定的值转换成 Boolean 型； Number(value) - 把给定的值转换成数字（可以是整数或浮点数）； String(value) - 把给定的值转换成字符串；用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。 Boolean() 函数当要转换的值是至少有一个字符的字符串、非 0 数字或对象时，Boolean() 函数将返回 true。如果该值是空字符串、数字 0、undefined 或 null，它将返回 false。 123456var b1 = Boolean(&quot;&quot;); //false - 空字符串var b2 = Boolean(&quot;hello&quot;); //true - 非空字符串var b1 = Boolean(50); //true - 非零数字var b1 = Boolean(null); //false - nullvar b1 = Boolean(0); //false - 零var b1 = Boolean(new object()); //true - 对象 Number() 函数Number() 函数的强制类型转换与 parseInt() 和 parseFloat() 方法的处理方式相似，只是它转换的是整个值，而不是部分值。 还记得吗，parseInt() 和 parseFloat() 方法只转换第一个无效字符之前的字符串，因此 “1.2.3” 将分别被转换为 “1” 和 “1.2”。 用 Number() 进行强制类型转换，&quot;1.2.3&quot; 将返回 NaN，因为整个字符串值不能转换成数字。如果字符串值能被完整地转换，Number() 将判断是调用 parseInt() 方法还是 parseFloat() 方法。 123456789Number(false) // 0Number(true) // 1Number(undefined) // NaNNumber(null) // 0Number(&quot;1.2&quot;) // 1.2Number(&quot;12&quot;) // 12Number(&quot;1.2.3&quot;) // NaNNumber(new object()) // NaNNumber(50) // 50 String() 函数最后一种强制类型转换方法 String() 是最简单的，因为它可把任何值转换成字符串。 要执行这种强制类型转换，只需要调用作为参数传递进来的值的 toString() 方法，即把 12 转换成 “12”，把 true 转换成 “true”，把 false 转换成 “false”，以此类推。 强制转换成字符串和调用 toString() 方法的唯一不同之处在于，对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误： 123var s1 = String(null); //&quot;null&quot;var oNull = null;var s2 = oNull.toString(); //会引发错误 引用类型#Object#123let obj = new Object() //同let obj = new Object //为了避免混淆，尽量加上括号 Object 对象具有下列属性： constructor对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。 Prototype对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。 Object 对象还具有下列方法： hasOwnProperty(property)判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，o.hasOwnProperty(“name”)） IsPrototypeOf(object)判断该对象是否为另一个对象的原型。 PropertyIsEnumerable()判断给定的属性是否可以用 for…in 语句进行枚举。 ToString()返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。 ValueOf()返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。 注释：上面列出的每种属性和方法都会被其他对象覆盖。 Boolean 对象#Boolean 对象是 Boolean 原始类型的引用类型。 要创建 Boolean 对象，只需要传递 Boolean 值作为参数： 1var oBooleanObject = new Boolean(true); Number 对象#正如你可能想到的，Number 对象是 Number 原始类型的引用类型。要创建 Number 对象，采用下列代码： 1var oNumberObject = new Number(68); 您应该已认出本章前面小节中讨论特殊值（如 Number.MAX_VALUE）时提到的 Number 对象。所有特殊值都是 Number 对象的静态属性。 要得到数字对象的 Number 原始值，只需要使用 valueOf() 方法： 1var iNumber = oNumberObject.valueOf(); toFixed() 方法#toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toFixed(2)); //输出 &quot;68.00&quot; toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误 toExponential() 方法#与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。 与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toExponential(1)); //输出 &quot;6.8e+1&quot; 这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x10¹。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。 toPrecision() 方法 =&gt; 取N位有效数#toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如， 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(1)); //输出 &quot;7e+1&quot; 这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了： 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(2)); //输出 &quot;68&quot; 当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？ 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(3)); //输出 &quot;68.0&quot; 在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。 toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数。 提示：与 Boolean 对象相似，Number 对象也很重要，不过应该少用这种对象，以避免潜在的问题。只要可能，都使用数字的原始表示法。 String 对象#String 对象是 String 原始类型的对象表示法，它是以下方式创建的： 1var oStringObject = new String(&quot;hello world&quot;); length#String 对象具有属性 length，它是字符串中的字符个数： 123var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.length); //输出 &quot;11&quot;alert('龍'.length) // 1 这个例子输出的是 “11”，即 “hello world” 中的字符个数。注意，即使字符串包含双字节的字符（与 ASCII 字符相对，ASCII 字符只占用一个字节），每个字符也只算一个字符。 charAt() 和 charCodeAt() 方法#首先，两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。 charAt() 方法返回的是包含指定位置处的字符的字符串： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charAt(1)); //输出 &quot;e&quot; 在字符串 “hello world” 中，位置 1 处的字符是 “e”。在“ECMAScript 原始类型”这一节中我们讲过，第一个字符的位置是 0，第二个字符的位置是 1，依此类推。因此，调用 charAt(1) 返回的是 “e”。 如果想得到的不是字符，而是字符代码，那么可以调用 charCodeAt() 方法： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charCodeAt(1)); //输出 &quot;101&quot; 这个例子输出 “101”，即小写字母 “e” 的字符代码。 es6#es6中字符串追加了unicode的支持遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 123456789101112let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) { console.log(text[i]);}// &quot; &quot;// &quot; &quot;for (let i of text) { console.log(i);}// &quot;𠮷&quot; concat() 方法#用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，保持原始的 String 对象不变： 1234var oStringObject = new String(&quot;hello &quot;);var sResult = oStringObject.concat(&quot;world&quot;);alert(sResult); //输出 &quot;hello world&quot;alert(oStringObject); //输出 &quot;hello &quot; indexOf() 和 lastIndexOf() 方法#1234var oStringObject = new String(&quot;hello world!&quot;);alert(oStringObject.indexOf(&quot;o&quot;)); 输出 &quot;4&quot;alert(oStringObject.lastIndexOf(&quot;o&quot;)); 输出 &quot;7&quot;alert(oStringObject.lastIndexOf(&quot;orl&quot;)); 输出 &quot;7&quot; localeCompare() 方法#下一个方法是 localeCompare()，对字符串进行排序。该方法有一个参数 - 要进行比较的字符串，返回的是下列三个值之一： 如果 String 对象按照字母顺序排在参数中的字符串之前，返回负数。 如果 String 对象等于参数中的字符串，返回 0 如果 String 对象按照字母顺序排在参数中的字符串之后，返回正数。 注释：如果返回负数，那么最常见的是 -1，不过真正返回的是由实现决定的。如果返回正数，那么同样的，最常见的是 1，不过真正返回的是由实现决定的。localeCompare() 方法的独特之处在于，实现所处的区域（locale，兼指国家/地区和语言）确切说明了这种方法运行的方式。在美国，英语是 ECMAScript 实现的标准语言，localeCompare() 是区分大小写的，大写字母在字母顺序上排在小写字母之后。不过，在其他区域，情况可能并非如此。示例如下： 1234var oStringObject = new String(&quot;yellow&quot;);alert(oStringObject.localeCompare(&quot;brick&quot;)); //输出 &quot;1&quot;alert(oStringObject.localeCompare(&quot;yellow&quot;)); //输出 &quot;0&quot;alert(oStringObject.localeCompare(&quot;zoo&quot;)); //输出 &quot;-1&quot; slice() 和 substring()#ECMAScript 提供了两种方法从子串创建字符串值，即 slice() 和 substring()。这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。如果省略第二个参数，终止位就默认为字符串的长度。 与 concat() 方法一样，slice() 和 substring() 方法都不改变 String 对象自身的值。它们只返回原始的 String 值，保持 String 对象不变。 12345var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.slice(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.substring(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.slice(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot;alert(oStringObject.substring(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot; 在这个例子中，slice() 和 substring() 的用法相同，返回值也一样。当只有参数 3 时，两个方法返回的都是 “lo world”，因为 “hello” 中的第二个 “l” 位于位置 3 上。当有两个参数 “3” 和 “7” 时，两个方法返回的值都是 “lo w”（”world” 中的字母 “o” 位于位置 7 上，所以它不包括在结果中）。 为什么有两个功能完全相同的方法呢？事实上，这两个方法并不完全相同，不过只在参数为负数时，它们处理参数的方式才稍有不同。 对于负数参数，slice() 方法会用字符串的长度加上参数，substring() 方法则将其作为 0 处理（也就是说将忽略它）。例如： 12345var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.slice(&quot;-3&quot;)); //输出 &quot;rld&quot;alert(oStringObject.substring(&quot;-3&quot;)); //输出 &quot;hello world&quot;alert(oStringObject.slice(&quot;3, -4&quot;)); //输出 &quot;lo w&quot;alert(oStringObject.substring(&quot;3, -4&quot;)); //输出 &quot;hel&quot; 这样即可看出 slice() 和 substring() 方法的主要不同。 当只有参数 -3 时，slice() 返回 “rld”，substring() 则返回 “hello world”。这是因为对于字符串 “hello world”，slice(“-3”) 将被转换成 slice(“8”)，而 substring(“-3”) 将被转换成 substring(“0”)。 同样，使用参数 3 和 -4 时，差别也很明显。slice() 将被转换成 slice(3, 7)，与前面的例子相同，返回 “lo w”。而 substring() 方法则将两个参数解释为 substring(3, 0)，实际上即 substring(0, 3)，因为 substring() 总把较小的数字作为起始位，较大的数字作为终止位。因此，substring(“3, -4”) 返回的是 “hel”。这里的最后一行代码用来说明如何使用这些方法。 toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()#最后一套要讨论的方法涉及大小写转换。有 4 种方法用于执行大小写转换，即 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 一般来说，如果不知道在以哪种编码运行一种语言，则使用区域特定的方法比较安全。 提示#记住，String 对象的所有属性和方法都可应用于 String 原始值上，因为它们是伪对象。 instanceof 运算符#在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject instanceof String); //输出 &quot;true&quot; 这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是 “true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。 等性运算符#等号(==)与非等号(!==)#执行类型转换的规则如下： 如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 在比较时，该运算符还遵守下列规则： 值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 1234567891011null == undefined //true&quot;NaN&quot; == NaN //false5 == NaN //falseNaN == NaN //falseNaN != NaN //truefalse == 0 //truetrue == 1 //truetrue == 2 //falseundefined == 0 //falsenull == 0 //false&quot;5&quot; == 5 //true 全等号与非全等号#这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 12345var sNum = &quot;66&quot;;var iNum = 66;alert(sNum == iNum); //输出 &quot;true&quot;alert(sNum === iNum); //输出 &quot;false&quot;alert(sNum !== iNum); //输出 &quot;true&quot; Function#length属性#ECMAScript 定义的属性 length 声明了函数期望的参数个数。例如： 12345678910function doAdd(iNum) { alert(iNum + 10);}function sayHi() { alert(&quot;Hi&quot;);}alert(doAdd.length); //输出 &quot;1&quot;alert(sayHi.length); //输出 &quot;0&quot; Function 对象#有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。例如： 12345function doAdd(iNum) { alert(iNum + 10);}document.write(doAdd.toString()); 闭包#闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。 简单的闭包#1234567var sMessage = &quot;hello world&quot;;function sayHelloWorld() { alert(sMessage);}sayHelloWorld(); 在上面这段代码中，脚本被载入内存后，并没有为函数 sayHelloWorld() 计算变量 sMessage 的值。该函数捕获 sMessage 的值只是为了以后的使用，也就是说，解释程序知道在调用该函数时要检查 sMessage 的值。sMessage 将在函数调用 sayHelloWorld() 时（最后一行）被赋值，显示消息 “hello world”。 复杂的闭包#12345678var iBaseNum = 10;function addNum(iNum1, iNum2) { function doAdd() { return iNum1 + iNum2 + iBaseNum; } return doAdd();} 这里，函数 addNum() 包括函数 doAdd() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 iNum1 和 iNum2 以及全局变量 iBaseNum 的值。 addNum() 的最后一步调用了 doAdd()，把两个参数和全局变量相加，并返回它们的和。 这里要掌握的重要概念是，doAdd() 函数根本不接受参数，它使用的值是从执行环境中获取的。 对象类型#本地对象# Object Function Array String Boolean Number Date RegExp Error EvalError RangeError ReferenceError SyntaxError TypeError URIError 内部对象#即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。 宿主对象#所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。 所有 BOM 和 DOM 对象都是宿主对象。 继承#要用 ECMAScript 实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可作为基类。出于安全原因，本地类和宿主类不能作为基类，这样可以防止公用访问编译过的浏览器级的代码，因为这些代码可以被用于恶意攻击。 对象冒充#构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 ClassA 构造函数成为 ClassB 的方法，然后调用它。ClassB 就会收到 ClassA 的构造函数中定义的属性和方法。例如，用下面的方式定义 ClassA 和 ClassB： 123456789101112function ClassA(sColor) { this.color = sColor; this.sayColor = function () { alert(this.color); };}function ClassB(sColor) { this.newMethod = ClassA; this.newMethod(sColor); delete this.newMethod;} 在这段代码中，为 ClassA 赋予了方法 newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是 ClassB 构造函数的参数 sColor。最后一行代码删除了对 ClassA 的引用，这样以后就不能再调用它。 所有新属性和新方法都必须在删除了新方法的代码行后定义。否则，可能会覆盖超类的相关属性和方法： 12345678910111213141516function ClassB(sColor, sName) { this.newMethod = ClassA; this.newMethod(sColor); delete this.newMethod; this.name = sName; this.sayName = function () { alert(this.name); };}var objA = new ClassA(&quot;blue&quot;);var objB = new ClassB(&quot;red&quot;, &quot;John&quot;);objA.sayColor(); //输出 &quot;blue&quot;objB.sayColor(); //输出 &quot;red&quot;objB.sayName(); //输出 &quot;John&quot; 对象冒充可以实现多重继承#123456789function ClassZ() { this.newMethod = ClassX; this.newMethod(); delete this.newMethod; this.newMethod = ClassY; this.newMethod(); delete this.newMethod;} 这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法，ClassY 具有高优先级。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。 由于这种继承方法的流行，ECMAScript 的第三版为 Function 对象加入了两个方法，即 call() 和 apply()。 call()#call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如： 12345678function sayColor(sPrefix,sSuffix) { alert(sPrefix + this.color + sSuffix);};var obj = new Object();obj.color = &quot;blue&quot;;sayColor.call(obj, &quot;The color is &quot;, &quot;a very nice color indeed.&quot;); 在这个例子中，函数 sayColor() 在对象外定义，即使它不属于任何对象，也可以引用关键字 this。对象 obj 的 color 属性等于 blue。调用 call() 方法时，第一个参数是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个和第三个参数是字符串。它们与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息 “The color is blue, a very nice color indeed.” 将被显示出来。 要与继承机制的对象冒充方法一起使用该方法，只需将前三行的赋值、调用和删除代码替换即可： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.call(this, sColor); this.name = sName; this.sayName = function () { alert(this.name); };} 这里，我们需要让 ClassA 中的关键字 this 等于新创建的 ClassB 对象，因此 this 是第一个参数。第二个参数 sColor 对两个类来说都是唯一的参数。 apply()#apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如： 12345678function sayColor(sPrefix,sSuffix) { alert(sPrefix + this.color + sSuffix);};var obj = new Object();obj.color = &quot;blue&quot;;sayColor.apply(obj, new Array(&quot;The color is &quot;, &quot;a very nice color indeed.&quot;)); 这个例子与前面的例子相同，只是现在调用的是 apply() 方法。调用 apply() 方法时，第一个参数仍是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个参数是由两个字符串构成的数组，与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息仍是 “The color is blue, a very nice color indeed.”，将被显示出来。 该方法也用于替换前三行的赋值、调用和删除新方法的代码： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.apply(this, new Array(sColor)); this.name = sName; this.sayName = function () { alert(this.name); };} 同样的，第一个参数仍是 this，第二个参数是只有一个值 color 的数组。可以把 ClassB 的整个 arguments 对象作为第二个参数传递给 apply() 方法： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.apply(this, arguments); this.name = sName; this.sayName = function () { alert(this.name); };} 当然，只有超类中的参数顺序与子类中的参数顺序完全一致时才可以传递参数对象。如果不是，就必须创建一个单独的数组，按照正确的顺序放置参数。此外，还可使用 call() 方法。 原型链#prototype 对象是个模板，要实例化的对象都以这个模板为基础。总而言之，prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。 123456789101112131415function ClassA() {}ClassA.prototype.color = &quot;blue&quot;;ClassA.prototype.sayColor = function () { alert(this.color);};function ClassB() {}ClassB.prototype = new ClassA(); //mark /*这里，把 ClassB 的 prototype 属性设置成 ClassA 的实例。这很有意思，因为想要 ClassA 的所有属性和方法，但又不想逐个将它们 ClassB 的 prototype 属性。还有比把 ClassA 的实例赋予 prototype 属性更好的方法吗？*/ 注意： 调用 ClassA 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。 子类的所有属性和方法都必须出现在 prototype 属性被赋值后，因为在它之前赋值的所有方法都会被删除。为什么？因为 prototype 属性被替换成了新对象，添加了新方法的原始对象将被销毁。所以，为 ClassB 类添加 name 属性和 sayName() 方法的代码如下：123456789function ClassB() {}ClassB.prototype = new ClassA();ClassB.prototype.name = &quot;&quot;;ClassB.prototype.sayName = function () { alert(this.name);}; 混合#对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。开发者如何选择呢？答案很简单，两者都用。创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制，用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法.12345678910111213141516171819202122232425function ClassA(sColor) { this.color = sColor;}ClassA.prototype.sayColor = function () { alert(this.color);};function ClassB(sColor, sName) { ClassA.call(this, sColor); //对象冒用 this.name = sName; //构造函数定义属性}ClassB.prototype = new ClassA(); //原型链继承//继承后定义新的方法ClassB.prototype.sayName = function () { alert(this.name);};var objA = new ClassA(&quot;blue&quot;);var objB = new ClassB(&quot;red&quot;, &quot;John&quot;);objA.sayColor(); //输出 &quot;blue&quot;objB.sayColor(); //输出 &quot;red&quot;objB.sayName(); //输出 &quot;John&quot;","link":"/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"RN","slug":"RN","link":"/tags/RN/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"sentry","slug":"sentry","link":"/tags/sentry/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"fabric.js","slug":"fabric-js","link":"/tags/fabric-js/"}],"categories":[{"name":"建站","slug":"建站","link":"/categories/%E5%BB%BA%E7%AB%99/"},{"name":"运维","slug":"运维","link":"/categories/%E8%BF%90%E7%BB%B4/"},{"name":"APP","slug":"APP","link":"/categories/APP/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"canvas","slug":"canvas","link":"/categories/canvas/"},{"name":"前端基础","slug":"前端基础","link":"/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"}]}