{"pages":[{"title":"CV","text":"Thetiso 教育背景#技术栈#项目经验#","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#Create a new post#1$ hexo new &quot;My New Post&quot; More info: Writing Run server#1$ hexo server More info: Server Generate static files#1$ hexo generate More info: Generating Deploy to remote sites#1$ hexo deploy More info: Deployment","link":"/2020/10/30/hello-world/"},{"title":"build Blog-site by Hexo","text":"记录使用hexo搭建github博客的过程(mac) 准备# node npm github账号 START# 全局安装hexo12$ npm i hexo -g$ hexo init Blog 在此site选择hexo的主题，默认主题landscape。很多主题都比较陈旧，坚持维护的不多，我选择的是icarus. 安装icarus123//Blog根目录$ npm install hexo-theme-icarus$ hexo config theme icarus 启动服务12345$ npm i$ hexo s//实际运行可能会报错并提示有部分组件未安装，按照提示安装即可//浏览器地址`localhost:4000`预览//若端口占用，可使用`lsof -i:4000`查看进程，配合`kill -9 ${pid}`指令清除进程 写作#创建分类#12//Blog根目录$ hexo n page categories 打开生成的index.md文件，修改如下 12345---title: categoriesdate: 2020-10-30 10:42:43type: &quot;categories&quot;--- 而后在任意文章顶部标记新的分类名称即可 123456---title: Hexo建站date: 2020-10-30 10:41:03categories:- 建站--- 创建标签#与创建分类同理 12//Blog根目录$ hexo n page tags 打开生成的index.md文件，修改如下 12345---title: tagsdate: 2020-10-30 10:42:43type: &quot;tags&quot;--- 而后在任意文章顶部标记新的分类名称即可 123456---title: Hexo建站date: 2020-10-30 10:41:03tags:- hexo--- 引用图片#在配置文件中允许使用资源文件 1post_aeest_folder: true 在文章中引用的方式参考链接注意: 上述配置对已经创建的文章不会生效，需要重新hexo n XXX才会在_post文件夹下创建同名的资源文件夹，直接将要用的图片丢进去就OK啦 1{% asset_img avatar.jpg %} 如下图 部署#hexo官方提供了配合Travis CI的github pages部署教程， 但是流程实在太长，对新手不友好，推荐使用懒人一键部署 1$ npm install hexo-deployer-git --save 修改_config.yml配置文件,注意同名文件可能有好几个，改的是本目录下的文件 12345deploy: type: 'git' repo: 'https://github.com/xxx/xxx.github.io' branch: master message: 'init' 一键部署 1$ hexo clean &amp;&amp; hexo deploy 其他#markdown语法#折叠#12345&lt;details&gt;&lt;summary&gt;Title&lt;/summary&gt;content!!!&lt;/details&gt; 折叠示例如下 Title content!!! 标注#这是要标注的地方^脚注1，注脚后的冒号请注意，它也是一部分 1234这是要标注的地方[^脚注1]。[^脚注1]: 巴拉巴拉.. 配置主题icarus#bash12$ npm install hexo-theme-icarus$ hexo config theme icarus 如果需要更加个性化定制/修改css等，就需要使用git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus的方式直接导入源码。当然直接下载源码扔到对应文件夹也是OK的，记得去掉git相关文件就行。 开启busuanzi访问统计#_config.icarus.yml &gt; plugins &gt; busuanzi: true即可，记得重新运行hexo,可以在审查元素中查看是否拉取busuanzi.js即可。更加具体的解释和配置可以看这个文章 链接","link":"/2020/10/30/hexo-site/"},{"title":"nginx静态网站优化","text":"本文初略介绍针对静态网站的nginx优化 参考文章一参考文章一 设置nginx配置文件#sh123456789101112131415161718192021server { listen 80; server_name xxx.com gzip on; #开启或关闭gzip on off gzip_static on; gzip_disable &quot;msie6&quot;; #不使用gzip IE6 gzip_min_length 1024; #gzip压缩最小文件大小，超出进行压缩（自行调节） gzip_buffers 4 16k; #buffer 不用修改 gzip_comp_level 8; #压缩级别:1-10，数字越大压缩的越好，时间也越长 gzip_types application/javascript text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; location / { try_files $uri $uri/ /index.html; root /your/site/path/from/root; index index.html; expires 24h; #静态文件缓存时间 }} 请务必核对gzip_types, 本人之前一般js文件是text/javascript格式，导致页面上加载js时，速度极其缓慢 gzip_min_length可以适当设置的小一点 expires 可以大幅度加快文件的读取速度，当然弊端就是遇到更新会触发缓存，自行斟酌。 try_files 是针对vue spa静态站点的设置，为了使浏览器输入具体url时能直达页面，而不是只能看到首页 PS#谨防 HSTS#参考文章 HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。服务器开启HSTS的方法是，当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议响应头中包含Strict-Transport-Security字段。非加密传输时设置的HSTS字段无效。 比如，https://www.liberalman.cn 的响应头含有Strict-Transport-Security: max-age=31536000; includeSubDomains。这意味着两点：在接下来的一年（即31536000秒）中，浏览器只要向xxx或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如，用户点击超链接或在地址栏输入 http://www.liberalman.cn/ ，浏览器应当自动将 http 转写成 https，然后直接向 https://www.liberalman.cn/ 发送请求。 在接下来的一年中，如果 www.liberalman.cn 服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。 服务器端配置HSTS，减少302跳转，其实HSTS的最大作用是防止302 HTTP劫持。HSTS的缺点是浏览器支持率不高，另外配置HSTS后HTTPS很难实时降级成HTTP。同时，也建议启用SPDY来提高性能，不累述。","link":"/2020/12/10/nginx%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"title":"RN项目笔记(基础篇)","text":"本文主要记录在写rn项目过程中的一些要点。 …尴尬，其中使用UI框架为ant-d, 但是其listview在上拉加载的时候无法触发fetch, github上维护看着也不积极。已准备弃用 1. 基础样式 1.1 常用属性 2. 使用要点 2.1 设置本文自动省略 2.2 对文本设置圆角 2.3 文本元素长度auto,不跟随父元素(不超过父元素长度时) 2.4 为Text/View添加点击事件 3. 杂记(开发中遇到的问题) 1. 如何使用熟悉的js中class来设置样式 2. icon框架 react-native-vector-icons ant-ui有多个版本,请务必仔细核对自己的版本是否正确。本文对应的ui框架网站为官网、文档 2020.12.11 目前是混合使用ant和elements框架 1. 基础样式#参考文章 js12345678910111213141516171819202122232425export default class App extends Component&lt;Props&gt; { render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={{color: 'red'}}&gt;I Love React Native!&lt;/Text&gt; &lt;Text style={[styles.fs14, styles.red]}&gt;two styles in array!&lt;/Text&gt; &lt;/View&gt; ); }, }const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, fs14: { fontSize: 14 }, red: { color: 'red' }}); 设定组件/子元素的样式有两种方式： 直接行内设置 通过StyleSheet 需要注意的是， 通过StyleSheet设置的时候，只有一对大括号，而行内需要两对; 当一个元素的样式被分拆成多个时，需要用数组形式 1.1 常用属性#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960width //宽height //高backgroundColoropacity //透明度//边框圆角设置borderTopLeftRadius //左上角圆角borderTopRightRadius //右上角的圆角borderBottomLeftRadius //左下角的圆角borderBottomRightRadius //右下角的圆角borderRadius //所有角的圆角//边框宽度borderLeftWidth //左边边框宽度borderRightWidth //右边边框宽度borderTopWidth //顶部边框宽度borderBottomWidth //底部边框宽度borderWidth //所有边框宽度//边框颜色borderColor //边框颜色marginBottom //距下外边距marginLeft //距左外边距marginRight //距右外边距marginTop //距上外边距marginVertical //垂直外边距(也就是距上,距下边距)marginHorizontal //水平外边距(距左,距右边距)margin //所有边距paddingBottom //距下内边距paddingLeft //距左内边距paddingRight //距右内边距paddingTop //距上内边距paddingVertical//垂直内边距paddingHorizontal //水平内边距padding //所有内边距//图像变换ImagescaleX //水平方向缩放scaleY //垂直方向缩放rotation //旋转translateX //水平方向平移translateY //水平方向平移resizemode //拉伸图片 'cover' ,'strech','contain'//文本Textcolor //文字颜色textAlign //对其方式 ('left','right','auto','center','justify')fontSize //字体大小fontStyle //字体风格 正常:'normal', 斜体:'italic'fontWeight //字体粗细 加粗:'bold', '100', '200' letterSpacing //字符间距lineHeight //行间距textDecorationLine //字体装饰线 下划线:'underline', 删除线:'line-through',下划线删除线:'underline line-through'textDecorationStyle //字体装饰线风格 单线:'solid' 双线:'double' 虚线:'dotted','dashed'textDecorationColor //字体装饰线颜色 2. 使用要点#2.1 设置本文自动省略#Text在设置了文本之后会在到达width的位置自动截断，如果需要设置以省略号...结尾的话需要在行内设置参数 1&lt;Text numberOfLines={1}&gt;我是文本&lt;/Text&gt; 2.2 对文本设置圆角#ios下无法通过给Text设置Radius来设置圆角，需要通过外部加一层View元素设置圆角 12345&lt;View style={{borderRadius: 2}}&gt; &lt;Text style={{height: 20, backgroundColor: '#0c3', color: '#fff'}}&gt; 本文 &lt;/Text&gt;&lt;/View&gt; 2.3 文本元素长度auto,不跟随父元素(不超过父元素长度时)#js1234&lt;View style={{width: 200, flexDirection: 'column'}}&gt; &lt;View style={{width: 100}}&gt;&lt;/View&gt; &lt;Text style={{backgroundColor: 'red'}}&gt;这是文本&lt;/Text&gt;&lt;/View&gt; 上述代码中，从背景色可以发现text元素始终长度和父元素保持一致。此时，如果需要设置Text的长度根据文本来动态变化，则可以通过position来处理.修改后的代码如下： 12345678&lt;View style={{width: 200, flexDirection: 'column'}}&gt; &lt;View style={{width: 100}}&gt;&lt;/View&gt; &lt;View&gt; &lt;View style={{position: 'absolute', borderRadius: 5}}&gt; &lt;Text style={{backgroundColor: 'red'}}&gt;这是文本&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&lt;/View&gt; 2.4 为Text/View添加点击事件#12345678import {TouchableHighlight} from 'react-native';... &lt;TouchableHighlight onPress={this.submit}&gt; &lt;View&gt; &lt;Text&gt;文本 &lt;/View&gt;&lt;/TouchableHighlight&gt; 需要注意的是，TouchableHighlight的子元素只能是一个。 3. 杂记(开发中遇到的问题)#1. 如何使用熟悉的js中class来设置样式#2. icon框架 react-native-vector-icons#123yarn add react-native-vector-iconscd iospod install 如果遇到Unrecognized font family 'Material Icons'报错，则需要修改info.plist 123456789101112131415161718&lt;key&gt;UIAppFonts&lt;/key&gt;&lt;array&gt;&lt;string&gt;AntDesign.ttf&lt;/string&gt;&lt;string&gt;Entypo.ttf&lt;/string&gt;&lt;string&gt;EvilIcons.ttf&lt;/string&gt;&lt;string&gt;Feather.ttf&lt;/string&gt;&lt;string&gt;FontAwesome.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Brands.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Regular.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Solid.ttf&lt;/string&gt;&lt;string&gt;Foundation.ttf&lt;/string&gt;&lt;string&gt;Ionicons.ttf&lt;/string&gt;&lt;string&gt;MaterialIcons.ttf&lt;/string&gt;&lt;string&gt;MaterialCommunityIcons.ttf&lt;/string&gt;&lt;string&gt;SimpleLineIcons.ttf&lt;/string&gt;&lt;string&gt;Octicons.ttf&lt;/string&gt;&lt;string&gt;Zocial.ttf&lt;/string&gt;&lt;/array&gt; 参考文章icon列表从上面的报错也可以知道此框架默认的Icon类别为Material,列表一览列表中的icon名称如果包含下划线，请记得改为短横：_ 改为 -, 貌似是某个版本改过命名规则。","link":"/2020/12/01/rn-ant-ui/"},{"title":"React Native APP开发(1)","text":"采用RN开发APP准备篇 准备工作# RN的准备工作请参考官方教程 UI框架选择的是蚂蚁那套Ant-UI MARK# 度娘能找到的rn教程很多不注明版本号，盲目使用其中的解决方案容易导致项目长跪不起，所以再不确定其版本号的情况下，请尽量使用最新的解决方案 ant-ui分别有对应react和rn的两套版本,请注意区分 引用ant-ui需要在xcode中引用对应的tff文件，否则会出现字体找不到的报错 启动#启动前请先打开xcode确保command tool是最新的 123$ npx react-native init AwesomeProject$ cd AwesomeProject$ yarn react-native run-ios 首次启动比较慢，根据电脑配置几分钟到十几分钟不等 核心组件#react-redux#参考vue的vuex, rn也有对应的状态管理，基本教程请参考此链接 axios#基本用法参照vue内的用法，不再赘述。 react-native-router-flux#对应vue-router, rn的路由管理参考链接, 不是很好理解，需要实际上手 页面传参#参考链接 NEXT 基础篇","link":"/2020/10/30/rn-app-step1/"},{"title":"React Native APP开发(3)","text":"采用RN开发APP进阶篇 常用框架 减少样板代码 简化action creator 1234567891011121314151617function makeActionCreator(type, ...argNames) { return function(...args) { let action = { type } argNames.forEach((arg, index) =&gt; { action[argNames[index]] = args[index] }) return action }}const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'export const addTodo = makeActionCreator(ADD_TODO, 'todo')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') 异步action creator + middleware 第三方授权登录 1. 微信授权 一些注意点 1. safeAreaView只对ios有效 2. setSate webview 保存图片、视频等 相册选择图片/视频、拍照等 safearea兼容 常用框架#参考链接 减少样板代码#简化action creator#1234567891011121314151617function makeActionCreator(type, ...argNames) { return function(...args) { let action = { type } argNames.forEach((arg, index) =&gt; { action[argNames[index]] = args[index] }) return action }}const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'export const addTodo = makeActionCreator(ADD_TODO, 'todo')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') 异步action creator + middleware#继上一篇的异步action， 当我们需要获取用户信息、评论列表、产品列表时，一种方案是抽象一个公共的request来处理各个请求，但是这样做共用了request.state, 无法应对单个请求异常超时的情况。这时候可以考虑换个思路抽象，使用thunk提供的中间件功能。 123456789101112export function loadPosts(userId) { return { // 要在之前和之后发送的 action types types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'], // 检查缓存 (可选): shouldCallAPI: (state) =&gt; !state.users[userId], // 进行取： callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`), // 在 actions 的开始和结束注入的参数 payload: { userId } };} 搭配中间件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function callAPIMiddleware({ dispatch, getState }) { return next =&gt; action =&gt; { const { types, callAPI, shouldCallAPI = () =&gt; true, payload = {} } = action if (!types) { // Normal action: pass it on return next(action) } if ( !Array.isArray(types) || types.length !== 3 || !types.every(type =&gt; typeof type === 'string') ) { throw new Error('Expected an array of three string types.') } if (typeof callAPI !== 'function') { throw new Error('Expected callAPI to be a function.') } if (!shouldCallAPI(getState())) { return } const [ requestType, successType, failureType ] = types dispatch(Object.assign({}, payload, { type: requestType })) return callAPI().then( response =&gt; dispatch(Object.assign({}, payload, { response, type: successType })), error =&gt; dispatch(Object.assign({}, payload, { error, type: failureType })) ) }} 至此，可以用下面的例子构造拉取评论、追加评论的异步action 1234567891011121314151617181920212223export function loadComments(postId) { return { types: ['LOAD_COMMENTS_REQUEST', 'LOAD_COMMENTS_SUCCESS', 'LOAD_COMMENTS_FAILURE'], shouldCallAPI: (state) =&gt; !state.posts[postId], callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`), payload: { postId } };}export function addComment(postId, message) { return { types: ['ADD_COMMENT_REQUEST', 'ADD_COMMENT_SUCCESS', 'ADD_COMMENT_FAILURE'], callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`, { method: 'post', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({ message }) }), payload: { postId, message } };} 第三方授权登录#1. 微信授权#参考文章 https://www.cnblogs.com/lude1994/p/10784457.html https://www.npmjs.com/package/react-native-wechat https://www.jianshu.com/p/b1a081165fba 一些注意点#1. safeAreaView只对ios有效#2. setSate#js1234567891011this.setState({ name: 'abc',})console.log(this.state.name) // 输出并不是abc//正确的写法应该是this.setState({ name: 'abc'}, ()=&gt; { console.log(this.state.name) //abc}) webview# 参考文章1参考文章2 失效github 保存图片、视频等# yarn add @react-native-community/camerarollios需要配置info.list NSPhotoLibraryUsageDescription 你懂的安卓需要额外配置权限npm说明 相册选择图片/视频、拍照等# github项目 bash1234567yarn add react-native-image-picker# RN &gt;= 0.60cd ios &amp;&amp; pod install# RN &lt; 0.60react-native link react-native-image-picker safearea兼容# 参考文章","link":"/2020/11/04/rn-app-step3/"},{"title":"rn-elements","text":"本文介绍react-native-elements在rn项目中的使用。 参考文章官方文档","link":"/2020/12/02/rn-elements/"},{"title":"vue-step-by-step","text":"vue教程(在实际项目中的基本使用) Step 1 起步 编辑器 VS Code cnpm 运行项目 项目结构 Step 2 组件的生命周期 页面 vue-router 全局钩子 路由钩子 组件钩子 vuex - store Step 3 思考 More keepActive的存在意义 为什么router-link时使用name vue-bus 全局通知 Step 4 优化加载 混入 自定义指令 客户端数据库 loki.js 服务端渲染 Nuxt 国际化 i18n 规范总结 Step 1#起步#vue有大版本区别，建议使用最新版。@vue/cli对于vue就像是spring-boot-starter对于spring-boot一样。 sh1234567## 全局安装cli工具，以后开发都会用到，所以建议全局安装npm install -g @vue/clicd someDir ..## 创建项目vue create step-by-step# ORvue ui vue create之后默认选择就行ESLint一开始会有所不适应，可以先放放。至此,创建一个叫做step-by-step项目。 编辑器 VS Code#和所有前端项目一样，可以直接使用idea/eclipse/sublime等工具来编写vue项目，在此推荐vscode cnpm#cnpm是国内采用淘宝镜像的组件工具，相比npm，获取依赖速度大大加快。以后项目中都会用到，建议全局安装。 12npm install cnpm -gnpm install cnpm -g --registry=https://registry.npm.taobao.org 运行项目#12345cd step-by-step#获取依赖cnpm i #测试运行npm run serve 不出意外将在命令窗口看到如下输出语句 12345DONE Compiled successfully in 1901ms 2:16:44 PMApp running at:- Local: http://localhost:8080/ - Network: http://192.168.3.32:8080/Note that the development build is not optimized. 项目结构#初始的项目距离开发需求还很远，先对项目结构做一下补充。 12345678910111213141516+ public+ src + assets - css //需要自己创建 - images //需要自己创建 + components + layouts //需要自己创建 + pages //需要自己创建 + configs //需要自己创建 + apis //需要自己创建 + utils //需要自己创建 - App.vue - main.js- vue.config.js //需要自己创建- babel.config.js- package.json 一个呈现在浏览器上的页面需要符合这样的层级结构：app &gt; layout &gt; page &gt; component。当我们项目需要不同的框架布局时，就可以定义不同的layout。举例子：正常浏览器访问查询列表的时候，我们需要header和footer，但是当我们的页面被别的项目用iframe引用时，就需要全局调整header和footer Step 2#组件的生命周期#改造初始后的项目，使其符合上一节所说的层级结构。阅读下面内容前，请先查看DEMO-S1从console中我们能看到打印结果为 1234567891011before layout createlayout createdbefore header createheader createdbefore content createcontent createdbefore footer createfooter createdheader mountedcontent mountedfooter mounted 由此，当我们在项目中加载数据的时候就需要注意了，layout/page/compontent各个阶段加载数据的先后顺序。父组件先create -&gt; 子组件 create -&gt; 子组件mounted -&gt; 父组件mounted 页面#阅读下面内容前，请先查看DEMO-S2了解了组件加载的先后顺序，我们尝试写一个符合规范的页面.为此我们需要新增依赖。 sh12cnpm i vue-router axios vuex --save# 记得重新npm run serve vue-router#基本用法: 123456789101112131415161718import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter);const router = new VueRouter({ mode: 'history', routes: [ { path: '/', //懒加载 component: () =&gt; import('../pages/index.vue') //or component: IndexPage } ]});export default router router-view 在src/components/common/content中包含这个标签，可以理解为根据配置的router来匹配组件。参考文档 router 与 钩子 全局钩子: beforeEach与afterEach的使用，配合store来查询用户权限、追加日志等 路由独享: 组件钩子: 全局钩子# to:router即将进入的路由对象 from:当前导航即将离开的路由 next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。 1234567891011121314151617181920212223router.beforeEach((to, from, next) =&gt; { console.log(store.state.token) const route = ['index', 'list']; let isLogin = store.state.token; // 是否登录 // 未登录状态；当路由到route指定页时，跳转至login if (route.indexOf(to.name) &gt;= 0) { if (isLogin == null) { router.push({ path: '/login', }); } } // 已登录状态；当路由到login时，跳转至home console.log(to.name) localStorage.setItem('routerName', to.name) if (to.name === 'login') { if (isLogin != null) { router.push({ path: '/HomeMain', });; } } next();});router.afterEach((to, from) =&gt; { console.log(to.fullPath, to.path, location.href)}); 路由钩子#12345678910111213const router = new VueRouter({ mode: 'history', routes: [ { path: '/dashboard', //懒加载 component: resolve =&gt; require(['../components/page/Dashboard.vue'], resolve) meta: { title: '系统首页' }, beforeEnter: (to, from, next) =&gt; { }, beforeLeave: (to, from, next) =&gt; { }, } ]}); 组件钩子#12345678910111213141516171819&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data: ()=&gt; ({}), beforeRouteLeave(to, from, next) { next() }, beforeRouteEnter(to, from, next) { next() }, beforeRouteUpdate(to, from, next) { next() }, computed: {}, method: {}}&lt;/script&gt; vuex - store#官方文档 state:驱动应用的数据源； view: 以声明方式将 state 映射到视图； actions: 响应在 view 上的用户输入导致的状态变化。 12this.$store.commit('clearUsrInfo')this.$store.dispatch('getProductList') Step 3#思考#对于SPA项目，各种数据请求/处理应该在哪个位置发生？带着以下问题查看DEMO-S3 有登录用户吗？ 存在本地化的授权token 校验token是否有效 用户的基本信息什么时候更新，保存在哪？那些数据虽然需要，但不需要本地化? 只存token,其他数据在必要的时候远程更新 当前用户有权查看当前页面信息吗？ 查store校验 调用远程接口由后台判断 -&gt; nuxt 用户的浏览行为在哪里发出？逐个页面发送日志，还是统一发送？ 借用钩子(全局钩子/路由钩子) 不同级别的用户对应不同的界面/菜单，我应该在哪个层进行识别才能避免用户看到不该看的信息？ 根据数据敏感程度自行斟酌：低敏感度、高敏感度 api统一管理的意义何在？是否需要全部使用action 可以适当偷懒，直接调用axios 统一管理：解耦合 More#阅读以下以下代码时，请先查看DEMO-S4 keepActive的存在意义#router.js12345678910111213const router = new Router({ ... routes: [ { name: 'test', path: '/test', component: ()=&gt; import('@/pages/test/index'), meta: { keepAlive: true } } ] }) compontents/xx.js1234&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 为什么router-link时使用name#当我们需要修改某个页面的路径的时候，不必逐个页面修改，只需要在router.js中修改path即可。 vue-bus 全局通知#1cnpm i --save vue-bus 123456789101112import VueBus from 'vue-bus'Vue.use(VueBus)this.$bus.on('some-action', actionHandle)this.$bus.once('some-action-happen-once', actionHandle)this.$bus.emit('some-action', paylod)actionHanlle: function(paylod) {} Step 4#优化加载#阅读以下代码请先查看DEMO-S5 外部引用 loki.js为例 在public/index.html中顶部引用外部script 在vue.config.js中配置映射关系 按需引用 element-ui为例123456789101112131415161718192021222324252627/* 第一步cnpm i --save babel-preset-envcnpm i --dev babel-plugin-component*///第二步修改.babel.config.jsmodule.exports = { presets: [ '@vue/cli-plugin-babel/preset', ], plugins: [ // element官方教程 [ &quot;component&quot;, { libraryName: &quot;element-ui&quot;, styleLibraryName: &quot;theme-chalk&quot; } ] ]}//第三部在main.js中import { Button } from 'element-ui';Vue.use(Button);//第四部实际组件中&lt;el-button @click=&quot;addTodo&quot;&gt;Vue-Bus&lt;/el-button&gt; 包分析package.json123456// cnpm i -D webpack-bundle-analyzer// 追加指令 &quot;scripts&quot;: { ... &quot;analyz&quot;: &quot;npm run build --analyze&quot; }, vue.config.js123456789101112131415161718const path = require('path');//拼接路径function resolve(dir) { return path.join(__dirname, dir)}module.exports = { ... chainWebpack: config =&gt; { config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) config.resolve.alias .set('@', resolve('src')) .set('#', resolve('public')) },} gzip nginx配置缓存和压缩 webpack压缩设置 混入#阅读以下代码请先查看DEMO-S5对于需要鉴权的页面，都会包含用户的基本信息，怎么才能避免每个组件都复制黏贴呢？ -&gt; 全局混入demo中我们点击/mine页面中的按钮可以直接修改header中的显示。 main.js1234567891011Vue.mixin({ created: function () {}, //混入对象的钩子将在组件自身钩子之前调用 computed: { ...mapState({ citySN: state =&gt; state.citySN }), ...mapGetters({ authBJS: 'fromBJS', }) },}) 其他还有组件混入等，可以查看官方文档。需要注意各种混入方式中遇到名称冲突时的规则。 自定义指令#在手机端页面上常常会有这样的需求：页面/组件打开(show)时自动focus输入框 -&gt; 自定义指令focus官方文档我们修改之前根据三字码查询机场名称的代码（/loki页面） 123456789directives: { focus: { // 指令的定义 inserted: function (el) { let ipt = el.hasChildNodes() ? el.querySelector('input') : el ipt.focus() } }}, 客户端数据库 loki.js#服务端渲染 Nuxt#国际化 i18n#规范总结#","link":"/2021/01/08/vue-step-by-step/"},{"title":"canvas-weapp-h5","text":"忙完公司关于海报制作的需求，开这篇文章扯扯canvas！ fabric.js 画布 canvas 文本、图片：最基本的海报要素 Text Image 图层高度 自定义编辑框 自定义编辑功能 联调 1. 授权验证 WE-APP APP(RN) 2. 选择照片 WE-APP APP(RN) 3. 传递数据 WE-APP APP(RN) NOTE safeArea qrcode 二维码 fabricObject自定义附加字段 服务端处理 截取指定区域 字体 最开始的需求是在小程序内简单实现可以手动编辑的海报，不是根据数据直接套模板生成海报。找了github, 最终选的是疑似酷家乐团队的Painter。用下来基本能满足需求，但是遇到了两个问题： 新需求：可能需要整APP，那就意味着我得有个RN下的canvas组件、或者就是H5上整canvas; 调试困难：不知道是不是系统原因还是啥，mac上跑小程序编辑器一直都不是很流畅，一旦页面上跑得东西多了，动不动就可以去喝杯咖啡.. sad 接下来的小程序页面中又多加了一个需求：需要将整好的数据直接导出成图片。 首先想到的就是wxml-to-canvas。 用这还行，不过考虑到后续APP也会有相同的需求，最终把wxml-to-canvas放下，选择了H5上的canvas方案。wxml-to-canvas没法直接使用iconfont, 得把icon换成img才行。 在H5的现有方案中，首先选中的是小飞飞的easy-canvas. 但这个项目尚未支持z-index, 担心后续有图层调整相关的要求，无奈放弃。在小飞飞推荐下，开始折腾fabric.js 不用翻墙就能看的官网地址 github上有好心的前人写了中文文档. 稍微有点久远，不过用来初步入门已经足够了。 在此，就不赘述一些基本使用方法，直接按照项目中常见的需求来展开。 fabric.js#画布 canvas#12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;canvas-box&quot;&gt; &lt;canvas id=&quot;canvas&quot; :width='width' :height='height'&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import {fabric} from 'fabric';export default { data: ()=&gt; ({ width: 360, height: 640, canvas: '' }), created: function() { //预加载数据,组装等 }, mounted: function() { //canvas赋值必须得等页面加载之后才行 this.canvas = new fabric.Canvas('canvas') }, methods: { }}&lt;/script&gt; 文本、图片：最基本的海报要素#fabric.js项目作者将所有画布上的对象抽象为fabric.Object。其他所有的文本、图像之类全是基于这个基类。 Text#12345678910111213141516171819202122232425262728let obj = { text: '文本内容', //这里有借鉴Painter项目 css: { left: 100, top: 100, fontWeight: 600, color: '#fff', }}let text = new fabric.Text( obj.text, { left: obj.css.left, top: obj.css.top, fontFamily: 'Comic Sans' , fontSize: obj.css.fontSize || 20, fontWeight: obj.css.fontWeight, fill:obj.css.color, originX: obj.css.originX ||'left', })//绑定点击(选中)事件，默认是支持的，这里是为了调用自定义的编辑框text.on('selected', _this.selectedHandle)//可以配置fabric.Object不可被选中text.set('selectable', !!obj.editAble);this.canvas.add(text);//moveTo方法将在后续控制层高的地方讲到text.moveTo(1) Text有个进阶的Object: IText tips: Text可以设置padding, 默认的编辑框border距离文本实在是太近了，尤其是需要自定义编辑框按钮的时候，挨得太近根本没办法好好显示按钮，通过设置这个参数，就可以开心的留一些区域给按钮啦 Image#12345678910111213141516171819202122232425262728//加载跨域图片new fabric.Image.fromURL(obj.url, function(img) { //这里img.width/height是图片的原始宽高，单位px console.log(img.width , img.height, obj.css.width) let scaleRatio = obj.css.width / img.width //通过scale使图片适应设定的宽高 img.scale(scaleRatio); //可以设置翻转 // oImg.scale(0.5).set('flipX, true); img.on('selected', _this.selectedHandle) img.top = obj.css.top img.left = obj.css.left //不设置height,避免选择框不能匹配图像边缘 img.on('selected', _this.selectedHandle) img.set('selectable', !!obj.editAble);}, {crossOrigin: 'anonymous'})//加载本地图片// &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;// &lt;img src=&quot;my_image.png&quot; id=&quot;my-image&quot;&gt;var canvas = new fabric.Canvas('c');var imgElement = document.getElementById('my-image');var imgInstance = new fabric.Image(imgElement, { left: 100, top: 100, angle: 30, opacity: 0.85});canvas.add(imgInstance); 加载跨域图片时候需要设置crossOrigin参数。 所有的fabric.Object下子类都是公用编辑框(controls)的 加载图片是个异步操作，不能保证所有Object的先后顺序。这就需要配合之前所说的moveTo函数来控制其图层高度。 图层高度#点此查看介绍文档 图层高度同z-index, 数值大的可以遮挡数值小的。控制图层一般用到这几个方法： 12345obj.bringToFront(); // 置顶obj.bringForward(); // 向上一层obj.sendToBack(); // 置底obj.sendBackwards(); // 向下一层obj.moveTo(n); // 设置层高N 自定义编辑框#fabric.js自带的编辑框还是蛮丑的… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103selectedHandle: function() { //getActiveObject()可以获取当前被选中的对象 -&gt; 进而获取其类型 let type = this.canvas.getActiveObject() ? this.canvas.getActiveObject().type : null type &amp;&amp; this.setupEditBox(type) //如果是文本, 则显示文本编辑菜单，如果是图片则显示图片菜单 this.showTextMenu = type == 'text' this.showImgMenu = type == 'image'},setupEditBox: function(targetType) { //首先隐藏默认的编辑框上的所有小点(按钮) Object.values(fabric.Object.prototype.controls).forEach(c =&gt; c.visible = false); //可以理解为原生按钮支持的事件handler let controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls; //icon直接用的base64 png图片，这里不适合全部黏贴上来，后续补充demo的时候，可以去demo查看 //编辑框画自定义的按钮还没尝试其他方法... 后续尝试下新的放方法 let _this = this, editIcon64 = 'data:image/png;base64,...' let eidtIconImg = document.createElement('img'); eidtIconImg.src = editIcon64; let scaleIcon64 = 'data:image/png;base64,...' let scaleIconImg = document.createElement('img'); scaleIconImg.src = scaleIcon64; let textCloseIcon64 = 'data:image/png;base64,...'; let textCloseIconImg = document.createElement('img'); textCloseIconImg.src = textCloseIcon64; //edit即为这个新按钮的名称，可以随意取 fabric.Object.prototype.controls.edit = new fabric.Control({ x: 0, //x y是以Object中心点为0的, 向上为Y负轴， 向左为X负轴 y: -0.5, //0.5其实指的是 height * 0.5 offsetY: -30, //30的单位是px cursorStyle: 'pointer', mouseUpHandler: _this.showEditPopover, //点击事件的handler，请看下一小节 render: renderTextEditIcon, //自定义绘制按钮 cornerSize: 32, visible: targetType == 'text' }); fabric.Object.prototype.controls.scale = new fabric.Control({ x: 0.5, y: 0.5, cursorStyle: 'pointer', render: renderImageScaleIcon, cornerSize: 32, actionHandler:scalingEqually, visible: targetType == 'image' }); fabric.Object.prototype.controls.text_close = new fabric.Control({ x: 0, y: 0.5, offsetY: 30, cursorStyle: 'pointer', render: renderTextCloseIcon, cornerSize: 32, mouseUpHandler: _this.deleteTextHandle, visible: targetType == 'text' }); //其实我也不想在这里写function, 试了下写外面，结果绘制没成功... sad function renderImageScaleIcon(ctx, left, top, styleOverride, fabricObject) { let w = 32, h = 32; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(scaleIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw edit box for img done') } function renderTextEditIcon(ctx, left, top, styleOverride, fabricObject) { let w = 32, h = 32; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(eidtIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw edit icon for text done') } function renderTextCloseIcon(ctx, left, top, styleOverride, fabricObject) { let w = 30, h = 30; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(textCloseIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw close icon for text done') }}, 自定义编辑功能#在controls.edit我们指定了mouseUpHandler为showEditPopover。control.close用了一样的方式来获取点击事件。 12345678910showEditPopover: function(eventData, target) { //没直接用传参 let obj = this.canvas.getActiveObject() if (!obj || obj.type != 'text') { return } //如果是文本被点击，则弹出modle允许编辑 this.showTextEditModel = true; this.textEditModelContent = obj.text}, 当我们的model中修改文本内容完成，则可以用下面的方法替换画布上的文本 12345678confirmTextEdit: function() { let obj = this.canvas.getActiveObject() if (!!obj &amp;&amp; obj.type == 'text') { obj.text = this.textEditModelContent } this.canvas.requestRenderAll(); //重新渲染画布 this.showTextEditModel = false //清除model}, 联调#涉及到联调的主要是这几个功能点： we-app的授权验证 选取移动端本地(相册)的照片 fabric.js生成的图片传给APP或者we-app使用 1. 授权验证#WE-APP#先引入wx-jdk，我是先在index.html顶部加载，然后通过vue的配置来获取的 vue.config.js12345configureWebpack: { externals: { 'weixin-js-sdk': 'wx' },}, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364created: function() { let _this = this //确认是否是在小程序中 wx.miniProgram.getEnv(function(res) { console.log(res.miniprogram) _this.weAppEnv = res.miniprogram })},mounted: function() { if(this.weAppEnv) { this.initWxConfig() }},methods: { initWxConfig: function() { let url = window.location.href url = url.split('#')[0] const promise = axios.get('/api/wechat/h5/sign/share' + '?app_id=' + this.appId + '&amp;url=' + url); promise.then(res =&gt; { if (res.data.code == 200) { const sign = res.data.data; this._wxConfigJSSDK(sign); } }); promise.catch((err) =&gt; { console.log(err.response); }) }, _wxConfigJSSDK: function(sign){ wx.config({ debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: sign.appId + '', // 必填，公众号的唯一标识 timestamp: parseInt(sign.timestamp), // 必填，生成签名的时间戳 nonceStr: sign.nonceStr + '', // 必填，生成签名的随机串 signature: sign.signature + '',// 必填，签名 jsApiList: ['chooseImage', 'downloadImage', 'previewImage', 'uploadImage'] // 必填，需要使用的JS接口列表 }) wx.ready(function(){ wx.checkJsApi({ jsApiList: [ 'chooseImage', 'previewImage', 'uploadImage', 'downloadImage' ], success: function (res) { if (res.checkResult.getLocation == false) { console.error('你的微信版本太低，不支持微信JS接口，请升级到最新的微信版本！'); return; }else{ console.log('授权成功', res) } }, fail: err=&gt; { console.log(err) } }); }); wx.error(function(res){ console.error(res) }); },} 中间涉及到一个appId,即为调用该页面的小程序关联的公众号appid 当我们需要调用分享(APP、H5内),就需要进行签名。具体逻辑参照官方文档 切记将这个fabric.js所在的域名添加到公众号下的安全域名内，没错，公众号！！！和小程序关联的公众号，同主体，同开发者平台账号下 切记将这个fabric.js所在的域名添加到小程序的合法业务域名下 小程序开发工具-网页模式可以用来调试当前fabric.js页面 小程序开发工具-小程序模式没办法使用模拟器来测试授权，必须真机测试！！！一般来说上一步的网页模式测试没问题，真机也不会有问题 不涉及选择照片功能的话，可以不授权。 APP(RN)#RN内好像没涉及授权问题 2. 选择照片#WE-APP#借用wx-js-sdk来手机上的照片，也可以支持拍照。前提是完成wx.config 12345678910111213141516171819202122232425262728_getLocalImage: function() { let _this = this return new Promise((resolve, reject)=&gt; { wx.chooseImage({ count: 1, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) { var localIds = res.localIds; // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 let targetImgId = localIds[0] console.log('wkwebview is' + !!window.__wxjs_is_wkwebview) wx.getLocalImgData({ localId: targetImgId, success: (res) =&gt; { let localData = res.localData // localData是图片的base64数据，可以用img标签显示 resolve(localData) }, fail: err=&gt; { reject(err) } }) }, fail: err=&gt; { reject(err) } }); })}, APP(RN)#rn中的选择照片就相对简单一点。主要是用到组件react-native-image-picker 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;Avatar containerStyle={styles.avatar} rounded size=&quot;large&quot; source={{ uri: 'https://' + this.props.agent.avatar }} title={!this.props.agent.avatar ? '店': null} &gt; &lt;Avatar.Accessory name=&quot;edit&quot; size={25} onPress={()=&gt; { let options = { mediaType: 'photo', maxWidth: '320', maxHeight: '320', quality: '0.8', }, callback = async (res) =&gt; { if(res &amp;&amp; res.uri) { let loading = Toast.loading('即将上传，请稍候', 0) let token = await applyToken() if(token) { Toast.remove(loading) let uploadLoading = Toast.loading('正在上传', 0), key = 'agent/avatar/' + this.props.agent.id + '/' + new Date().getTime() + '.jpg' upload( { key: key, path: res.uri.replace('file://', ''), //这个是关键 mimeType: res.type, token: token, zone: ZONE.HUABEI, }, null ).then(data =&gt; { console.log(data) Toast.remove(uploadLoading) Toast.success('上传成功', 2, ()=&gt; { let avatarURL = 'oss-xxx.XXX.com/' + data.key this.props.updateAgentAvatar({avatar: avatarURL}) //追加同步服务器的步骤 }) }) .catch(err =&gt; { console.error(err) if (err.code === CODE.UPLOAD_FAILURE) { console.log('upload error') } }) } } } launchImageLibrary(options, callback) }} /&gt;&lt;/Avatar&gt; 3. 传递数据#WE-APP#H5传数据给小程序的webview，难点在于接收数据的时机和页面切换。 用户点击H5上的生成海报时，先将base64数据postMsg给小程序，然后执行wx.miniProgram.redirectTo(‘url?params’) 嵌套H5的页面中webview绑定msgHandler接收H5传上来的数据,并存storage 跳转后的页面接收params, 稍作定时(假装loading)后，从storage中获取数据，转base64为本地文件展示。 APP(RN)#h512345let obj = { type: 'generate-img', img: cripedImage //base64}window.ReactNativeWebView &amp;&amp; window.ReactNativeWebView.postMessage(JSON.stringify(obj)) rn1234567891011121314151617181920212223242526272829//为了更好的区分H5是谁调用的，可以在此webview中设置前缀script(后续再补充)&lt;WebView onLoad={(e) =&gt; console.log('onLoad')} onLoadEnd={(e) =&gt; console.log('onLoadEnd')} onLoadStart={(e) =&gt; console.log('onLoadStart')} renderError={() =&gt; { console.log('renderError') return &lt;View&gt;&lt;Text&gt;renderError回调了，出现错误&lt;/Text&gt;&lt;/View&gt; }} renderLoading={() =&gt; { return &lt;View&gt;&lt;Text&gt;这是自定义Loading...&lt;/Text&gt;&lt;/View&gt; }} source={{uri: this.state.url}} //h5页面地址 style={{marginTop: 20}} onMessage={this._onMessage} //接收上面传过来的参数/&gt;_onMessage = (event)=&gt; { let webString = event.nativeEvent ? event.nativeEvent.data : '' if(webString) { let obj = JSON.parse(webString) if(obj &amp;&amp; obj.type == 'generate-img') { Actions['poster-preview']({ img: obj.img }) return } } console.log('H5-&gt;RN传参错误')} NOTE#safeArea#qrcode 二维码#fabricObject自定义附加字段#服务端处理#参考文档 截取指定区域#参考文档 123456789101112131415161718192021222324252627282930313233/** Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately* @param {Object} [options] Options object* @param {String} [options.format=png] The format of the output image. Either &quot;jpeg&quot; or &quot;png&quot;* @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.* @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent* @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14* @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14* @param {Number} [options.width] Cropping width. Introduced in v1.2.14* @param {Number} [options.height] Cropping height. Introduced in v1.2.14* @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0* @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format* @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}*/// @example &lt;caption&gt;Generate jpeg dataURL with lower quality&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'jpeg', quality: 0.8 });// @example &lt;caption&gt;Generate cropped png dataURL (clipping of canvas)&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'png', left: 100, top: 100, width: 200, height: 200 });// @example &lt;caption&gt;Generate double scaled png dataURL&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'png', multiplier: 2 }); 字体#Q: 小程序内嵌H5， H5使用fabric, 但画布上的英文字很明显不是选用的字体? (后来发现这个是Times New Roman)A: 最开始怀疑是微信浏览器最字体做了限制，官方文档,后台注意到嵌入fabric的H5页面，非canvas内部的字体并没有受到影响。至此： 字体支持应该是设置的字体在电脑端(测试时)存在，但真机时并没有 尝试在真机上设置Text的字体为苹方，上述猜想得到证实 接下来就是得想办法让真机能支持自己设置的字体-&gt; 区分机型，并为不同机型寻找合适的字体PS: 至于node端设置字体，请参考这个文章","link":"/2020/12/28/canvas-weapp-h5/"},{"title":"React Native APP开发(2)","text":"采用RN开发APP基础篇 React基础 1. class组件 2. 路由-组件跳转 3. 状态管理 action reducer Store 数据流 全局引用 异步Action 4. 数据持久化 后记 React基础#安利个网站snack，方便在线调试自己写的代码(尤其是起步阶段，避免眼高手低) 可以不用注册，保存个链接，必要的时候赋值代码进去修改/运行 1. class组件#javascript123456789import React, { Component } from 'react';import { Text } from 'react-native';export default class Cat extends Component { render() { return ( &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; ); }} props对应外部传入的参数， 一般不在内部修改state对应组件内部的参数, 根据用户交互行为变更/赋值 javascript12345678910111213141516171819202122232425262728293031323334import React, { Component } from &quot;react&quot;;import { Button, Text, View } from &quot;react-native&quot;;export class Cat extends Component { state = { isHungry: true }; render() { return ( &lt;View&gt; &lt;Text&gt; I am {this.props.name}, and I am {this.state.isHungry ? &quot; hungry&quot; : &quot; full&quot;}! &lt;/Text&gt; &lt;Button onPress={() =&gt; { this.setState({ isHungry: false }); }} disabled={!this.state.isHungry} title={ this.state.isHungry ? &quot;Pour me some milk, please!&quot; : &quot;Thank you!&quot; } /&gt; &lt;/View&gt; ); }}export default class Cafe extends Component { render() { return ( &lt;&gt; &lt;Cat name=&quot;Munkustrap&quot; /&gt; &lt;Cat name=&quot;Spot&quot; /&gt; &lt;/&gt; ); }} 在class形式的组件中，不用管props的内部结构，只需要注意引用组件时怎么传递参数。 state 参数的命名方式需要注意。 onPress赋值的应该是一个函数，也可以直接提出来写 render返回必须用()包起来， 所有的模板内容必须用一个元素包起来，不能出现并列的多个元素javascript12345678910111213141516171819202122232425import React, { Component } from 'react';import { Text, Button, View } from 'react-native';export default class Cat extends Component { state = { showName: false, } showName = ()=&gt; { if(this.state.showName) return; this.setState({ showName: true }) } render() { return ( &lt;View&gt; &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; { this.state.showName ? (&lt;Text&gt;My name is Lily!&lt;/Text&gt;) : (null)} &lt;Button onPress={this.showName} title=&quot;show my name&quot;&gt;&lt;/Button&gt; &lt;/View&gt; // &lt;View&gt; // &lt;Text&gt;这个View-Text不能写, 类似于Vue只能有一个根元素&lt;/Text&gt; // &lt;/View&gt; ); }} 2. 路由-组件跳转#类似于vue-router，rn的路由管理组件为react-native-router-flux, 需要注意的是该组件有多个大版本，对应不同版本的react-navigation，查阅文档的时候请先留意版本是否匹配。官方还有react-router方案可选.当前以最新版V4.2.0为例。 首先构建两个页面(sence) javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//login.jsimport React, {Component} from 'react';import {View, Text, SafeAreaView,StatusBar} from 'react-native';import {Actions} from &quot;react-native-router-flux&quot;;export default class Login extends Component { gotoRegister = (params)=&gt; { Actions.register() } render() { return ( &lt;&gt; &lt;StatusBar&gt;&lt;/StatusBar&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text&gt;登录页面&lt;/Text&gt; &lt;Button onPress={this.gotoRegister} type=&quot;primary&quot; title=&quot;没有账号，立即注册&quot;&gt;&lt;/Button&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); }}//import React, {Component} from 'react';import {View, Text, SafeAreaView,StatusBar} from 'react-native';import {Actions} from &quot;react-native-router-flux&quot;;export default class Register extends Component { gotoIndex = (params)=&gt; { Actions.reset('index', {}) } render() { return ( &lt;&gt; &lt;StatusBar&gt;&lt;/StatusBar&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text&gt;注册页面&lt;/Text&gt; &lt;Button onPress={this.gotoIndex} type=&quot;primary&quot; title=&quot;前往首页&quot;&gt;&lt;/Button&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); }} 构建APP.js javascript123456789101112131415161718192021222324import React, { Component } from 'react';import Login from './container/Login';import Register from './container/Register';import Index from './container/Index';import {Stack, Scene, Router, Actions, Tabs} from 'react-native-router-flux';export default class App extends Component&lt;Props&gt; { render() { return ( &lt;Router&gt; &lt;Stack key=&quot;root&quot; title=&quot;测试&quot;&gt; &lt;Scene key=&quot;login&quot; component={Login} initial=&quot;true&quot; //设置默认页面 title=&quot;Login&quot; /&gt; &lt;Scene key=&quot;register&quot; component={Register} title=&quot;Register&quot; /&gt; &lt;Scene key=&quot;index&quot; component={Index} hideNavBar /&gt; &lt;/Stack&gt; &lt;/Router&gt; ); }} react-native-router-flux提供了便捷的路由跳转API,可以通过在app.js内设置的sence.key搭配Actions直接跳转 javascript123456let props = { shopId: 123}Actions.login(props)// 等同于Actions.push('login', props) 常用的的API如下, javascript123456789101112131415// 返回上一页面Actions.pop();// 返回指定页面(堆栈中)Actions.popTo('key'); // 刷新页面Actions.refresh({ param1: 'hello', param2: 'world' });// 清空当前页面堆栈，重新打开指定的页面Actions.reset('index', props)// tabbar之间切换Actions.jump('key') 3. 状态管理#APP内往往需要全局共享用户的登录状态、昵称、头像等，这时候就需要状态管理组件react-redux。在使用react-redux之前，先了解下redux的一些基本概念。 action reducer store NOTE应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。惟一改变 state 的办法是触发 action(一个描述发生什么的对象)。为了描述 action 如何改变 state 树，你需要编写 reducers。 action#Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。 javascript12345678910//建议单独文件存放const ADD_TODO = 'ADD_TODO'import { ADD_TODO, REMOVE_TODO } from '../actionTypes'//action对象{ type: ADD_TODO, text: 'Build my first Redux app'} action creator之前说action是一个普通对象，action creator则是一个函数，根据传参来返回需要的action.如果我们把store对应的state想象成是一个人， 那么action就是各种人所包含动作的描述。 javascript123456789{ type: '跑步',}{ type: '平躺',}... action除type可以自定义各种属性，所以我们可以这样来细化action javascript12345678910111213141516{ type: '跑步', speed: '慢速',}{ type: '跑步', speed: '中速',}{ type: '跑步', speed: '快速',}... 这时候我们就会想，需要根据某个传参(比如说跑步前吃的多不多)来确定自己具体使用哪个action(跑多快),这就引出了creator函数 javascript12345678910111213141516171819function run(payload) { if(payload.full == 1) { return { type: '跑步', speed: '慢速', } } else if (payload.full == 0) { return { type: '跑步', speed: '快速', } } else { return { type: '跑步', speed: '中速', } }} 进一步， 我们也会根据其他参数来定义更加丰富的action(根据零花钱来确定是跑回去呢，还是打车等等)总的来看action creator的思路和java中的工厂模式类似。 javascript12345678910111213141516171819202122232425262728293031323334/* * action 类型 */export const ADD_TODO = 'ADD_TODO';export const TOGGLE_TODO = 'TOGGLE_TODO'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'/* * 其它的常量 */export const VisibilityFilters = { SHOW_ALL: 'SHOW_ALL', SHOW_COMPLETED: 'SHOW_COMPLETED', SHOW_ACTIVE: 'SHOW_ACTIVE'}/* * action 创建函数 */export function addTodo(text) { return { type: ADD_TODO, text }}export function toggleTodo(index) { return { type: TOGGLE_TODO, index }}export function setVisibilityFilter(filter) { return { type: SET_VISIBILITY_FILTER, filter }} Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。 javascript12dispatch(addTodo(text))dispatch(completeTodo(index)) 或者创建一个 被绑定的 action 创建函数 来自动 dispatch： javascript12const boundAddTodo = text =&gt; dispatch(addTodo(text))const boundCompleteTodo = index =&gt; dispatch(completeTodo(index)) 然后直接调用它们： javascript12boundAddTodo(text);boundCompleteTodo(index); reducer#reducer 是一个纯函数，接收旧的 state 和 action，返回新的 state。 1(previousState, action) =&gt; newState 保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 1234567891011121314151617181920212223242526272829303132333435import { WALK, RUN, TAXI } from './actions'const initialState = { useVehicle: false, costMoney: false speed: null};function backHome(state, action) { if (typeof state === 'undefined') { return initialState } //处理其他action return state}//上述undefined的判断可以精简为如下function todoApp(state = initialState, action) { switch (action.type) { case WALK.type: return Object.assign({}, state, { useVehicle: false, costMoney: false speed: '5km/h' }) case RUN.type: return { ...state, useVehicle: false, costMoney: false speed: '15km/h' }) default: return state }} reducer合并 12345678910111213141516import { combineReducers } from 'redux'const todoApp = combineReducers({ visibilityFilter, mytodo: todos})export default todoApp//等价于export default function todoApp(state = {}, action) { return { visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) }} Store#Store的功能： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器。 12345import { createStore } from 'redux'import todoApp from './reducers'let store = createStore(todoApp)// 设置初始状态let store = createStore(todoApp, window.STATE_FROM_SERVER) 数据流#严格的单向数据流是 Redux 架构的设计核心。应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。 Redux 应用中数据的生命周期遵循下面 4 个步骤： 调用 store.dispatch(action); Redux store 调用传入的 reducer 函数: Store 会把两个参数(当前的 state 树和 上述action)传入 reducer; 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树 Redux store 保存了根 reducer 返回的完整 state 树 NOTE Redux 和 React 之间没有关系 Redux 的 React 绑定库(react-redux)是基于 容器组件和展示组件相分离 的开发思想 全局引用#React Redux 组件 让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。 123456789101112131415import React from 'react'import { render } from 'react-dom'import { Provider } from 'react-redux'import { createStore } from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp)render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 异步Action#默认情况下，createStore() 所创建的 Redux store 没有使用 middleware，所以只支持 同步数据流。你可以使用 applyMiddleware() 来增强 createStore()。虽然这不是必须的，但是它可以帮助你用简便的方式来描述异步的 action。像 redux-thunk 或 redux-promise 这样支持异步的 middleware 都包装了 store 的 dispatch() 方法，以此来让你 dispatch 一些除了 action 以外的其他内容，例如：函数或者 Promise。你所使用的任何 middleware 都可以以自己的方式解析你 dispatch 的任何内容，并继续传递 actions 给下一个 middleware。比如，支持 Promise 的 middleware 能够拦截 Promise，然后为每个 Promise 异步地 dispatch 一对 begin/end actions。当 middleware 链中的最后一个 middleware 开始 dispatch action 时，这个 action 必须是一个普通对象。这是 同步式的 Redux 数据流 开始的地方（译注：这里应该是指，你可以使用任意多异步的 middleware 去做你想做的事情，但是需要使用普通对象作为最后一个被 dispatch 的 action ，来将处理流程带回同步方式）。项目中，我们常常会需要发起异步请求，这时候action就会需要异步等待请求的结果(success or fail)。请先在项目引入redux-thunk，以发起请求为例 actions123{ type: 'REQUEST_POST' }{ type: 'RECEIVE_POSTS', error: 'Oops', response: null }{ type: 'RECEIVE_POSTS', response: { ... }, error: null } 构建action creator, 三个同步action: 发起请求 请求成功 请求失败123456789101112131415161718192021222324//通知 reducer 请求开始的 actionexport function requestPosts(){ return { type: REQUEST_POSTS, isFetch:true //进度条相关 }} //通知 reducer 请求成功的 actionexport function receviePostOnSuccess(data){ return { type: RECEIVE_POSTS, isFetch:false, amount: data }} //通知 reducer 请求失败的 action。export function receviePostOnError( message){ return{ type: RECEIVE_POSTS, isFetch:false, errorMsg:message }} 假设我们的请求是用来获取阅读量amount, 实际项目中建议改为data12345const initState={ isFetch: false, amount: 0, errorMsg: null,} reducers12345678910111213141516171819export function request_reducer(state=initState, action) { console.log(action.type, JSON.stringify(action)) switch (action.type){ case REQUEST_POSTS: return { ...state, isFetch: action.isFetch ? true : false, } case RECEIVE_POSTS: return { ...state, isFetch: false, amount: action.amount ? action.amount : 0, errorMsg: action.errorMsg ? action.errorMsg : null } default: return state; }} 异步action的关键在于action creator返回的不是一个简单对象{type: ...}, 而是一个函数/Promise(归功于thunk) 1234567891011121314151617181920212223242526272829//最核心的异步操作export function fetchAmount() { return axios.get('http://www.baidu.com')}//异步action//异步请求action 【将上面3个基础的action整合】export function getAmountPromise(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) const {num} = getState() return new Promise((resolve, reject)=&gt; { let success = (res)=&gt; { setTimeout(()=&gt; { dispatch(receviePostOnSuccess(num.number)) resolve(res) }, 2000) }, fail = (err)=&gt; { console.log(error); dispatch(receviePostOnError('error')) reject(err) } fetchAmount().then(success, fail) }) }} 完整例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//一个异步请求import axios from 'axios';const REQUEST_POSTS = &quot;REQUEST_POST&quot;;const RECEIVE_POSTS = &quot;RECEIVE_POSTS&quot;;const initState={ isFetch: false, amount: 0, errorMsg: null,}export function request_reducer(state=initState, action) { console.log(action.type, JSON.stringify(action)) switch (action.type){ case REQUEST_POSTS: return { ...state, isFetch: action.isFetch ? true : false, } case RECEIVE_POSTS: return { ...state, isFetch: false, amount: action.amount ? action.amount : 0, errorMsg: action.errorMsg ? action.errorMsg : null } default: return state; }}export function fetchAmount() { return axios.get('http://www.baidu.com')}//通知 reducer 请求开始的 actionexport function requestPosts(){ return { type: REQUEST_POSTS, isFetch:true //进度条相关 }} //通知 reducer 请求成功的 actionexport function receviePostOnSuccess(data){ return { type: RECEIVE_POSTS, isFetch:false, amount: data }} //通知 reducer 请求失败的 action。export function receviePostOnError( message){ return{ type: RECEIVE_POSTS, isFetch:false, errorMsg:message }} //异步请求action 【将上面3个基础的action整合】//写法一export function getAmount(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 // console.log( JSON.stringify(this), JSON.stringify(_this)) console.log(&quot;==================&quot;) dispatch(requestPosts()) const {num} = getState() //异步请求后端接口 return fetchAmount().then( data=&gt; { console.log(num); dispatch(receviePostOnSuccess(num.number)) }, error=&gt; { console.log(error); dispatch(receviePostOnError('error')) } ) }}//异步请求action 【将上面3个基础的action整合】//写法二export function getAmountPromise(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) const {num} = getState() return new Promise((resolve, reject)=&gt; { let success = (res)=&gt; { setTimeout(()=&gt; { dispatch(receviePostOnSuccess(num.number)) resolve(res) }, 2000) }, fail = (err)=&gt; { console.log(error); dispatch(receviePostOnError('error')) reject(err) } fetchAmount().then(success, fail) }) }} 4. 数据持久化#TODO 后记#写异步action的时候一直有疑惑，如果把所有的网络请求都用redux的思路来写的话，这个代码量简直爆炸。请教了之前写RN的朋友，被告知，异步网络请求可以不走action, 简单封装下axios, 统一管理API即可。","link":"/2020/10/30/rn-app-step2/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"RN","slug":"RN","link":"/tags/RN/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"fabric.js","slug":"fabric-js","link":"/tags/fabric-js/"}],"categories":[{"name":"建站","slug":"建站","link":"/categories/%E5%BB%BA%E7%AB%99/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"APP","slug":"APP","link":"/categories/APP/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"canvas","slug":"canvas","link":"/categories/canvas/"}]}