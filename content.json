{"pages":[{"title":"CV","text":"Thetiso 教育背景#技术栈#项目经验#","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"ES6笔记10-Set和Map","text":"set和map，这下许久没动静的java魂开始激动了~~mark map转json and json转map: 数组？对象？ Set 概念 属性与方法 遍历 keys()，values()，entries() forEach() 应用 WeakSet Map 概念 遍历 与其他类型的相互转换 1. Map 转为数组 2. 数组 转为 Map 3. Map 转为对象 4. 对象转为 Map 5. 转为 JSON 6. JSON 转为 Map WeakMap Set#概念#Set类似于数组，但是成员的值都是唯一的，没有重复的值。 Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。12345678910111213141516171819// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll('div'));set.size // 56// 类似于const set = new Set();document .querySelectorAll('div') .forEach(div =&gt; set.add(div));set.size // 56 ==&gt; 数组快速去重12// 去除数组的重复成员[...new Set(array)] ==&gt; 字符串去除重复字符1[...new Set('ababbc')].join('') // &quot;abc&quot; 向 Set 加入值的时候，不会发生类型转换 =&gt; NaN? 对象？所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是向 Set 加入值时认为NaN等于自身，而精确相等运算符认为NaN不等于自身。123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set {NaN} 上面代码向 Set 实例添加了两次NaN，但是只会加入一个。这表明，在 Set 内部，两个NaN是相等的。另外，两个对象总是不相等的。1234567let set = new Set();set.add({});set.size // 1set.add({});set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 属性与方法#Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 ==&gt; Array.from方法可以将 Set 结构转为数组。 12345678const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items);function dedupe(array) { return Array.from(new Set(array));}dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历#Set 结构的实例有四个遍历方法，可以用于遍历成员。 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员 NOTESet的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。 keys()，values()，entries()#keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 1234567891011121314151617181920212223242526272829303132let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) { console.log(item);}// red// green// bluefor (let item of set.values()) { console.log(item);}// red// green// bluefor (let item of set.entries()) { console.log(item);}// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;]let set = new Set(['red', 'green', 'blue']);for (let x of set) { console.log(x);}// red// green// blue forEach()#Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 12345let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9 上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。 另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。 应用#扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。 123let set = new Set(['red', 'green', 'blue']);let arr = [...set];// ['red', 'green', 'blue'] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。 123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 而且，数组的map和filter方法也可以间接用于 Set 了。 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：{2, 4, 6}let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：{2, 4} 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 12345678910111213let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set {1, 2, 3, 4}// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set {2, 3}// （a 相对于 b 的）差集let difference = new Set([...a].filter(x =&gt; !b.has(x))); // Set {1}如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。 123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。 WeakSet#WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 =&gt; 储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏12345const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set Map#概念#ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 =&gt; 传统{…}对象只能用字符串当作键 123456789const m = new Map();const o = {p: 'Hello World'};m.set(o, 'content')m.get(o) // &quot;content&quot;m.has(o) // truem.delete(o) // truem.has(o) // false Map构造函数接受数组作为参数，实际上执行的是下面的算法。 12345678910111213141516171819202122232425262728const items = [ ['name', '张三'], ['title', 'Author']];const map = new Map();items.forEach( ([key, value]) =&gt; map.set(key, value));const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // &quot;张三&quot;map.has('title') // truemap.get('title') // &quot;Author&quot;const set = new Set([ ['foo', 1], ['bar', 2]]);const m1 = new Map(set);m1.get('foo') // 1 事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数. 如果对同一个键多次赋值，后面的值将覆盖前面的值。 如果读取一个未知的键，则返回undefined。 只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。=&gt; Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。 12345678910111213141516171819202122232425262728const map = new Map();map.set(['a'], 555);map.get(['a']) // undefinedconst map = new Map();const k1 = ['a'];const k2 = ['a'];map.set(k1, 111).set(k2, 222);map.get(k1) // 111map.get(k2) // 222let map = new Map();map.set(-0, 123);map.get(+0) // 123map.set(true, 1);map.set('true', 2);map.get(true) // 1map.set(undefined, 3);map.set(null, 4);map.get(undefined) // 3map.set(NaN, 123);map.get(NaN) // 123 常用操作方法和属性 size set get delete has clear 遍历#Map 结构原生提供三个遍历器生成函数和一个遍历方法。 Map.prototype.keys()：返回键名的遍历器。 Map.prototype.values()：返回键值的遍历器。 Map.prototype.entries()：返回所有成员的遍历器。 Map.prototype.forEach()：遍历 Map 的所有成员。需要特别注意的是，Map 的遍历顺序就是插入顺序。 123456789101112131415161718192021222324252627282930313233343536const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) { console.log(key);}// &quot;F&quot;// &quot;T&quot;for (let value of map.values()) { console.log(value);}// &quot;no&quot;// &quot;yes&quot;for (let item of map.entries()) { console.log(item[0], item[1]);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 或者for (let [key, value] of map.entries()) { console.log(key, value);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot;// 等同于使用map.entries()for (let [key, value] of map) { console.log(key, value);}// &quot;F&quot; &quot;no&quot;// &quot;T&quot; &quot;yes&quot; =&gt; 转数组Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。 1234567891011121314151617const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] =&gt; forEachMap 还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。 1234567891011121314map.forEach(function(value, key, map) { console.log(&quot;Key: %s, Value: %s&quot;, key, value);});forEach方法还可以接受第二个参数，用来绑定this。const reporter = { report: function(key, value) { console.log(&quot;Key: %s, Value: %s&quot;, key, value); }};map.forEach(function(value, key, map) { this.report(key, value);}, reporter); 与其他类型的相互转换#1. Map 转为数组#前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（…）。 12345const myMap = new Map() .set(true, 7) .set({foo: 3}, ['abc']);[...myMap]// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ] 2. 数组 转为 Map#将数组传入 Map 构造函数，就可以转为 Map。 12345678new Map([ [true, 7], [{foo: 3}, ['abc']]])// Map {// true =&gt; 7,// Object {foo: 3} =&gt; ['abc']// } 3. Map 转为对象#如果所有 Map 的键都是字符串，它可以无损地转为对象。 12345678910111213function strMapToObj(strMap) { let obj = Object.create(null); for (let [k,v] of strMap) { obj[k] = v; } return obj;}const myMap = new Map() .set('yes', true) .set('no', false);strMapToObj(myMap)// { yes: true, no: false } 如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。 4. 对象转为 Map#对象转为 Map 可以通过Object.entries()。 1234567891011121314let obj = {&quot;a&quot;:1, &quot;b&quot;:2};let map = new Map(Object.entries(obj));//此外，也可以自己实现一个转换函数。function objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap;}objToStrMap({yes: true, no: false})// Map {&quot;yes&quot; =&gt; true, &quot;no&quot; =&gt; false} 5. 转为 JSON#Map 转为 JSON 要区分两种情况。 一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。 另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。123456789101112131415function strMapToJson(strMap) { return JSON.stringify(strMapToObj(strMap));}let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '{&quot;yes&quot;:true,&quot;no&quot;:false}'//----------//function mapToArrayJson(map) { return JSON.stringify([...map]);}let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);mapToArrayJson(myMap)// '[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]' 6. JSON 转为 Map#JSON 转为 Map，正常情况下，所有键名都是字符串。123456function jsonToStrMap(jsonStr) { return objToStrMap(JSON.parse(jsonStr));}jsonToStrMap('{&quot;yes&quot;: true, &quot;no&quot;: false}')// Map {'yes' =&gt; true, 'no' =&gt; false} 但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。123456function jsonToMap(jsonStr) { return new Map(JSON.parse(jsonStr));}jsonToMap('[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]')// Map {true =&gt; 7, Object {foo: 3} =&gt; ['abc']} WeakMap#WeakMap结构与Map结构类似，也是用于生成键值对的集合。 123456789101112// WeakMap 可以使用 set 方法添加成员const wm1 = new WeakMap();const key = {foo: 1};wm1.set(key, 2);wm1.get(key) // 2// WeakMap 也可以接受一个数组，// 作为构造函数的参数const k1 = [1, 2, 3];const k2 = [4, 5, 6];const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);wm2.get(k2) // &quot;bar&quot; WeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。=&gt; 在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。 1234567const map = new WeakMap();map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map keymap.set(null, 2)// TypeError: Invalid value used as weak map key 上面代码中，如果将数值1和Symbol值作为 WeakMap 的键名，都会报错。","link":"/2021/03/26/ES6%E7%AC%94%E8%AE%B010-Set%E5%92%8CMap/"},{"title":"ES6笔记12-module","text":"","link":"/2021/03/29/ES6%E7%AC%94%E8%AE%B012-module/"},{"title":"ES6笔记2-变量的解构赋值","text":"温故而知新, 可以为师矣~少点自满，多点谦虚~ 数组的解构赋值# 123456789101112131415161718192021222324252627282930 let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // &quot;a&quot;y // undefinedz // []let [x, y] = [1, 2, 3];x // 1y // 2//不完全解构=&gt; 左右两边模式不完全匹配let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 如果解构不成功，变量的值就等于undefined。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = {}; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。 对于 Set 结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set(['a', 'b', 'c']);x // &quot;a&quot; 默认值#解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() { console.log('aaa');}let [x = f()] = [1]; 对象的解构赋值#1234567891011121314151617//简写let { bar, foo } = { foo: 'aaa', bar: 'bbb' };foo // &quot;aaa&quot;bar // &quot;bbb&quot;//完整形式let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };//如果变量名与属性名不一致，必须写成下面这样。let { foo: baz } = { foo: 'aaa', bar: 'bbb' };baz // &quot;aaa&quot;let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello'l // 'world' 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。与数组一样，解构也可以用于嵌套结构的对象。 12345678910let obj = { p: [ 'Hello', { y: 'World' } ]};let { p: [x, { y }] } = obj;x // &quot;Hello&quot;y // &quot;World&quot; 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。 1234567891011let obj = { p: [ 'Hello', { y: 'World' } ]};let { p, p: [x, { y }] } = obj;x // &quot;Hello&quot;y // &quot;World&quot;p // [&quot;Hello&quot;, {y: &quot;World&quot;}] 12345678910111213const node = { loc: { start: { line: 1, column: 5 } }};let { loc, loc: { start }, loc: { start: { line }} } = node;line // 1loc // Object {start: Object}start // Object {line: 1, column: 5} 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。 默认值#默认值生效的条件是，对象的属性值严格等于undefined。 12345var {x = 3} = {x: undefined};x // 3var {x = 3} = {x: null};x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 注意点#1. 将一个已经声明的变量用于解构赋值#1234// 错误的写法let x;{x} = {x: 1};// SyntaxError: syntax error 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 123// 正确的写法let x;({x} = {x: 1}); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。 2. 允许等号左边的模式之中，不放置任何变量名#解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 123({} = [true, false]);({} = 'abc');({} = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 3. 可以对数组进行对象属性的解构#由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let {0 : first, [arr.length - 1] : last} = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。 字符串的解构赋值#字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let {length : len} = 'hello';len // 5 数值和布尔值的解构赋值#解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let {toString: s} = 123;s === Number.prototype.toString // truelet {toString: s} = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let { prop: x } = undefined; // TypeErrorlet { prop: y } = null; // TypeError 函数参数的解构赋值#函数的参数也可以使用解构赋值。 12345function add([x, y]){ return x + y;}add([1, 2]); // 3 12345678function move({x = 0, y = 0} = {}) { return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3}); // [3, 0]move({}); // [0, 0] // {} 不严格等于 undefined, 所以{x=0,y=0}起效move(); // [0, 0] //函数参数中的{}在此时起效，因为此时入参 严格等于 undefined 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。 12345678function move({x, y} = { x: 0, y: 0 }) { return [x, y];}move({x: 3, y: 8}); // [3, 8]move({x: 3}); // [3, undefined]move({}); // [undefined, undefined] 入参不严格等于 undefined， 所以 {x,y}起效move(); // [0, 0] //此时入参严格等于undefined ， 所以 {x:0, y:0}起效 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。需要注意上面两端代码中的入参写法，等号左边是 = ， 右边是 ：undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号的问题#解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 以下三种解构赋值不得使用圆括号。#1. 变量声明语句#123456789// 全部报错let [(a)] = [1];let {x: (c)} = {};let ({x: c}) = {};let {(x: c)} = {};let {(x): c} = {};let { o: ({ p: p }) } = { o: { p: 2 } }; 上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 2. 函数参数#函数参数也属于变量声明，因此不能带有圆括号。 1234// 报错function f([(z)]) { return z; }// 报错function f([z,(x)]) { return x; } 3. 赋值语句的模式#123// 全部报错({ p: a }) = { p: 42 };([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[({ p: a }), { x: c }] = [{}, {}]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号的情况#可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确({ p: (d) } = {}); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。(这句话没看懂~~~) 用途#1. 交换变量的值#1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 2. 从函数返回多个值#函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213// 返回一个数组function example() { return [1, 2, 3];}let [a, b, c] = example();// 返回一个对象function example() { return { foo: 1, bar: 2 };}let { foo, bar } = example(); 3. 函数参数的定义#解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) { ... }f([1, 2, 3]);// 参数是一组无次序的值function f({x, y, z}) { ... }f({z: 3, y: 2, x: 1}); 4. 提取 JSON 数据#解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678let jsonData = { id: 42, status: &quot;OK&quot;, data: [867, 5309]};let { id, status, data: number } = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取 JSON 数据的值。 5. 函数参数的默认值#1234567891011jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config} = {}) { // ... do stuff}; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 6. 遍历 Map 结构#任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) { console.log(key + &quot; is &quot; + value);}// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 12345678// 获取键名for (let [key] of map) { // ...}// 获取键值for (let [,value] of map) { // ...} 7. 输入模块的指定方法#加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);","link":"/2021/03/11/ES6%E7%AC%94%E8%AE%B02-%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"},{"title":"NoSQL-MongoDB","text":"今天尝试把egg/koa的好搭档mongodb整一下试试，正好用来记录中台的所有请求日志！ 概述 什么是NoSQL? 为什么使用NoSQL ? 安装 子账户 配合midway(egg) 不约束实体字段类型 概述#什么是NoSQL?#NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 为什么使用NoSQL ?#今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。 安装#参考文档–简书操作手册 123# 请先安装dockerdocker pull mongo:latestdocker run -name mongo -d mongo -p 27017:27017 --auth 我是在mac上直接通过docker安装，全程没遇到问题！ 使用vscode上的mongodb组件来验证是否正常。 子账户#1docker exec -it mongo mongo admin 第一个mongo是指容器名称，建议重新取个名字.第二个mongo是指令名称,就想我们使用mysql链接关系型数据库一样最后的admin是指默认登录的账户。=&gt; 也可能是我理解错误了 12# 先创建一个管理权限的账户 =&gt; 交做admin超管, 也可以是root或者其他什么名字db.createUser({ user:'admin',pwd:'123456',roles:[ { role:'userAdminAnyDatabase', db: 'admin'}]}); user：用户名 pwd：密码 roles：指定用户的角色，可以用一个空数组给新用户设定空角色；在roles字段,可以指定内置角色和用户定义的角色。role里的角色可以选：Built-In Roles（内置角色）： 1. 数据库用户角色：read、readWrite; 2. 数据库管理角色：dbAdmin、dbOwner、userAdmin； 3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager； 4. 备份恢复角色：backup、restore； 5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase 6. 超级用户角色：root // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase） 7. 内部角色：__system 具体角色： Read：允许用户读取指定数据库 readWrite：允许用户读写指定数据库 dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户 clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。 readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限 readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限 userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限 dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。 root：只在admin数据库中可用。超级账号，超级权限。 刚建立了 userAdminAnyDatabase 角色，用来管理用户，可以通过这个角色来创建、删除用户。 接下来为了创建各种环境的库(建议最好还是部署在不同的服务器上，或者直接使用成熟的云库) 12345678910111213db.createUser({ user:'u_name',pwd:'u_pw',roles:[ { role:'dbOwner', db: 'u_db'}]}); # 查看是否创建成功show users # 验证子账户db.auth(&quot;u_name&quot;, &quot;u_pw&quot;)# 创建你的库 =&gt; 没插入数据前，show dbs不会显示出来use u_db# 创建集合，类似于sql中的表db.createCollection('students')# 新建数据db.students.save({&quot;name&quot;: &quot;zhang san&quot;})# 查看数据集合是否创建成功show dbs NOTE:当我们使用docker exec 进入mongo时，(还没进行其他操作),使用指令show users可以看到所有的用户。 123456789101112131415161718192021222324252627282930313233343536373839&gt; show users{ &quot;_id&quot; : &quot;admin.eft&quot;, &quot;userId&quot; : UUID(&quot;b68b4686-22bc-4e20-9dc6-a48582c4b560&quot;), &quot;user&quot; : &quot;eft&quot;, &quot;db&quot; : &quot;admin&quot;, &quot;roles&quot; : [ { &quot;role&quot; : &quot;dbOwner&quot;, &quot;db&quot; : &quot;prod&quot; } ], &quot;mechanisms&quot; : [ &quot;SCRAM-SHA-1&quot;, &quot;SCRAM-SHA-256&quot; ]}{ &quot;_id&quot; : &quot;admin.mid&quot;, &quot;userId&quot; : UUID(&quot;cd0b0d67-4e6e-4392-9f3f-d8bc9c022e8d&quot;), &quot;user&quot; : &quot;mid&quot;, &quot;db&quot; : &quot;admin&quot;, &quot;roles&quot; : [ { &quot;role&quot; : &quot;dbOwner&quot;, &quot;db&quot; : &quot;midway&quot; } ], &quot;mechanisms&quot; : [ &quot;SCRAM-SHA-1&quot;, &quot;SCRAM-SHA-256&quot; ]}&gt; show dbsadmin 0.000GBconfig 0.000GBlocal 0.000GBmidway 0.000GBprod 0.000GB 此时admin.mid对应的数据库即为midway，如果我进入mongo之后使用了use midway，然后再db.createUser(…)，则创建的用户名为 midway.${newUserName}, 对应的DB实际上是midway下的字表/库。切记！ 所以如果是创建不同环境下的链接用户，应该直接在根目录下创建！！！ 配合midway(egg)#midway参考文档typegoose文档 不约束实体字段类型#/model/log.ts1234567891011121314151617181920212223import {ModelOptions, prop, Severity } from '@typegoose/typegoose';@ModelOptions({options: {allowMixed: Severity.ALLOW}}) //这一行是关键export class Log { @prop() public path: string; @prop() public path_desc?: string; @prop() public query?: any; @prop() public params?: any; @prop() public req_body?: any; @prop() public res_body?: any; @prop() timestamp: number; @prop() date: string;// @prop({ type: () =&gt; [String] })// public jobs?: string[];}","link":"/2021/03/29/NoSQL-MongoDB/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#Create a new post#1$ hexo new &quot;My New Post&quot; More info: Writing Run server#1$ hexo server More info: Server Generate static files#1$ hexo generate More info: Generating Deploy to remote sites#1$ hexo deploy More info: Deployment","link":"/2020/10/30/hello-world/"},{"title":"build Blog-site by Hexo","text":"记录使用hexo搭建github博客的过程(mac) 准备# node npm github账号 START# 全局安装hexo12$ npm i hexo -g$ hexo init Blog 在此site选择hexo的主题，默认主题landscape。很多主题都比较陈旧，坚持维护的不多，我选择的是icarus. 安装icarus123//Blog根目录$ npm install hexo-theme-icarus$ hexo config theme icarus 启动服务12345$ npm i$ hexo s//实际运行可能会报错并提示有部分组件未安装，按照提示安装即可//浏览器地址`localhost:4000`预览//若端口占用，可使用`lsof -i:4000`查看进程，配合`kill -9 ${pid}`指令清除进程 写作#创建分类#12//Blog根目录$ hexo n page categories 打开生成的index.md文件，修改如下 12345---title: categoriesdate: 2020-10-30 10:42:43type: &quot;categories&quot;--- 而后在任意文章顶部标记新的分类名称即可 123456---title: Hexo建站date: 2020-10-30 10:41:03categories:- 建站--- 创建标签#与创建分类同理 12//Blog根目录$ hexo n page tags 打开生成的index.md文件，修改如下 12345---title: tagsdate: 2020-10-30 10:42:43type: &quot;tags&quot;--- 而后在任意文章顶部标记新的分类名称即可 123456---title: Hexo建站date: 2020-10-30 10:41:03tags:- hexo--- 引用图片#在配置文件中允许使用资源文件 1post_aeest_folder: true 在文章中引用的方式参考链接注意: 上述配置对已经创建的文章不会生效，需要重新hexo n XXX才会在_post文件夹下创建同名的资源文件夹，直接将要用的图片丢进去就OK啦 1{% asset_img avatar.jpg %} 如下图 部署#hexo官方提供了配合Travis CI的github pages部署教程， 但是流程实在太长，对新手不友好，推荐使用懒人一键部署 1$ npm install hexo-deployer-git --save 修改_config.yml配置文件,注意同名文件可能有好几个，改的是本目录下的文件 12345deploy: type: 'git' repo: 'https://github.com/xxx/xxx.github.io' branch: master message: 'init' 一键部署 1$ hexo clean &amp;&amp; hexo deploy 其他#markdown语法#折叠#12345&lt;details&gt;&lt;summary&gt;Title&lt;/summary&gt;content!!!&lt;/details&gt; 折叠示例如下 Title content!!! 标注#这是要标注的地方^脚注1，注脚后的冒号请注意，它也是一部分 1234这是要标注的地方[^脚注1]。[^脚注1]: 巴拉巴拉.. 配置主题icarus#bash12$ npm install hexo-theme-icarus$ hexo config theme icarus 如果需要更加个性化定制/修改css等，就需要使用git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus的方式直接导入源码。当然直接下载源码扔到对应文件夹也是OK的，记得去掉git相关文件就行。 开启busuanzi访问统计#_config.icarus.yml &gt; plugins &gt; busuanzi: true即可，记得重新运行hexo,可以在审查元素中查看是否拉取busuanzi.js即可。更加具体的解释和配置可以看这个文章 链接","link":"/2020/10/30/hexo-site/"},{"title":"RN项目笔记(基础篇)","text":"本文主要记录在写rn项目过程中的一些要点。 …尴尬，其中使用UI框架为ant-d, 但是其listview在上拉加载的时候无法触发fetch, github上维护看着也不积极。已准备弃用 1. 基础样式 1.1 常用属性 2. 使用要点 2.1 设置本文自动省略 2.2 对文本设置圆角 2.3 文本元素长度auto,不跟随父元素(不超过父元素长度时) 2.4 为Text/View添加点击事件 3. 杂记(开发中遇到的问题) 1. 如何使用熟悉的js中class来设置样式 2. icon框架 react-native-vector-icons ant-ui有多个版本,请务必仔细核对自己的版本是否正确。本文对应的ui框架网站为官网、文档 2020.12.11 目前是混合使用ant和elements框架 1. 基础样式#参考文章 js12345678910111213141516171819202122232425export default class App extends Component&lt;Props&gt; { render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={{color: 'red'}}&gt;I Love React Native!&lt;/Text&gt; &lt;Text style={[styles.fs14, styles.red]}&gt;two styles in array!&lt;/Text&gt; &lt;/View&gt; ); }, }const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, fs14: { fontSize: 14 }, red: { color: 'red' }}); 设定组件/子元素的样式有两种方式： 直接行内设置 通过StyleSheet 需要注意的是， 通过StyleSheet设置的时候，只有一对大括号，而行内需要两对; 当一个元素的样式被分拆成多个时，需要用数组形式 1.1 常用属性#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960width //宽height //高backgroundColoropacity //透明度//边框圆角设置borderTopLeftRadius //左上角圆角borderTopRightRadius //右上角的圆角borderBottomLeftRadius //左下角的圆角borderBottomRightRadius //右下角的圆角borderRadius //所有角的圆角//边框宽度borderLeftWidth //左边边框宽度borderRightWidth //右边边框宽度borderTopWidth //顶部边框宽度borderBottomWidth //底部边框宽度borderWidth //所有边框宽度//边框颜色borderColor //边框颜色marginBottom //距下外边距marginLeft //距左外边距marginRight //距右外边距marginTop //距上外边距marginVertical //垂直外边距(也就是距上,距下边距)marginHorizontal //水平外边距(距左,距右边距)margin //所有边距paddingBottom //距下内边距paddingLeft //距左内边距paddingRight //距右内边距paddingTop //距上内边距paddingVertical//垂直内边距paddingHorizontal //水平内边距padding //所有内边距//图像变换ImagescaleX //水平方向缩放scaleY //垂直方向缩放rotation //旋转translateX //水平方向平移translateY //水平方向平移resizemode //拉伸图片 'cover' ,'strech','contain'//文本Textcolor //文字颜色textAlign //对其方式 ('left','right','auto','center','justify')fontSize //字体大小fontStyle //字体风格 正常:'normal', 斜体:'italic'fontWeight //字体粗细 加粗:'bold', '100', '200' letterSpacing //字符间距lineHeight //行间距textDecorationLine //字体装饰线 下划线:'underline', 删除线:'line-through',下划线删除线:'underline line-through'textDecorationStyle //字体装饰线风格 单线:'solid' 双线:'double' 虚线:'dotted','dashed'textDecorationColor //字体装饰线颜色 2. 使用要点#2.1 设置本文自动省略#Text在设置了文本之后会在到达width的位置自动截断，如果需要设置以省略号...结尾的话需要在行内设置参数 1&lt;Text numberOfLines={1}&gt;我是文本&lt;/Text&gt; 2.2 对文本设置圆角#ios下无法通过给Text设置Radius来设置圆角，需要通过外部加一层View元素设置圆角 12345&lt;View style={{borderRadius: 2}}&gt; &lt;Text style={{height: 20, backgroundColor: '#0c3', color: '#fff'}}&gt; 本文 &lt;/Text&gt;&lt;/View&gt; 2.3 文本元素长度auto,不跟随父元素(不超过父元素长度时)#js1234&lt;View style={{width: 200, flexDirection: 'column'}}&gt; &lt;View style={{width: 100}}&gt;&lt;/View&gt; &lt;Text style={{backgroundColor: 'red'}}&gt;这是文本&lt;/Text&gt;&lt;/View&gt; 上述代码中，从背景色可以发现text元素始终长度和父元素保持一致。此时，如果需要设置Text的长度根据文本来动态变化，则可以通过position来处理.修改后的代码如下： 12345678&lt;View style={{width: 200, flexDirection: 'column'}}&gt; &lt;View style={{width: 100}}&gt;&lt;/View&gt; &lt;View&gt; &lt;View style={{position: 'absolute', borderRadius: 5}}&gt; &lt;Text style={{backgroundColor: 'red'}}&gt;这是文本&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&lt;/View&gt; 2.4 为Text/View添加点击事件#12345678import {TouchableHighlight} from 'react-native';... &lt;TouchableHighlight onPress={this.submit}&gt; &lt;View&gt; &lt;Text&gt;文本 &lt;/View&gt;&lt;/TouchableHighlight&gt; 需要注意的是，TouchableHighlight的子元素只能是一个。 3. 杂记(开发中遇到的问题)#1. 如何使用熟悉的js中class来设置样式#2. icon框架 react-native-vector-icons#123yarn add react-native-vector-iconscd iospod install 如果遇到Unrecognized font family 'Material Icons'报错，则需要修改info.plist 123456789101112131415161718&lt;key&gt;UIAppFonts&lt;/key&gt;&lt;array&gt;&lt;string&gt;AntDesign.ttf&lt;/string&gt;&lt;string&gt;Entypo.ttf&lt;/string&gt;&lt;string&gt;EvilIcons.ttf&lt;/string&gt;&lt;string&gt;Feather.ttf&lt;/string&gt;&lt;string&gt;FontAwesome.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Brands.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Regular.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Solid.ttf&lt;/string&gt;&lt;string&gt;Foundation.ttf&lt;/string&gt;&lt;string&gt;Ionicons.ttf&lt;/string&gt;&lt;string&gt;MaterialIcons.ttf&lt;/string&gt;&lt;string&gt;MaterialCommunityIcons.ttf&lt;/string&gt;&lt;string&gt;SimpleLineIcons.ttf&lt;/string&gt;&lt;string&gt;Octicons.ttf&lt;/string&gt;&lt;string&gt;Zocial.ttf&lt;/string&gt;&lt;/array&gt; 参考文章icon列表从上面的报错也可以知道此框架默认的Icon类别为Material,列表一览列表中的icon名称如果包含下划线，请记得改为短横：_ 改为 -, 貌似是某个版本改过命名规则。","link":"/2020/12/01/rn-ant-ui/"},{"title":"nginx静态网站优化","text":"本文初略介绍针对静态网站的nginx优化 参考文章一参考文章一 设置nginx配置文件#sh123456789101112131415161718192021server { listen 80; server_name xxx.com gzip on; #开启或关闭gzip on off gzip_static on; gzip_disable &quot;msie6&quot;; #不使用gzip IE6 gzip_min_length 1024; #gzip压缩最小文件大小，超出进行压缩（自行调节） gzip_buffers 4 16k; #buffer 不用修改 gzip_comp_level 8; #压缩级别:1-10，数字越大压缩的越好，时间也越长 gzip_types application/javascript text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; location / { try_files $uri $uri/ /index.html; root /your/site/path/from/root; index index.html; expires 24h; #静态文件缓存时间 }} 请务必核对gzip_types, 本人之前一般js文件是text/javascript格式，导致页面上加载js时，速度极其缓慢 gzip_min_length可以适当设置的小一点 expires 可以大幅度加快文件的读取速度，当然弊端就是遇到更新会触发缓存，自行斟酌。 try_files 是针对vue spa静态站点的设置，为了使浏览器输入具体url时能直达页面，而不是只能看到首页 PS#谨防 HSTS#参考文章 HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。服务器开启HSTS的方法是，当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议响应头中包含Strict-Transport-Security字段。非加密传输时设置的HSTS字段无效。 比如，https://www.liberalman.cn 的响应头含有Strict-Transport-Security: max-age=31536000; includeSubDomains。这意味着两点：在接下来的一年（即31536000秒）中，浏览器只要向xxx或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如，用户点击超链接或在地址栏输入 http://www.liberalman.cn/ ，浏览器应当自动将 http 转写成 https，然后直接向 https://www.liberalman.cn/ 发送请求。 在接下来的一年中，如果 www.liberalman.cn 服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。 服务器端配置HSTS，减少302跳转，其实HSTS的最大作用是防止302 HTTP劫持。HSTS的缺点是浏览器支持率不高，另外配置HSTS后HTTPS很难实时降级成HTTP。同时，也建议启用SPDY来提高性能，不累述。","link":"/2020/12/10/nginx%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"title":"React Native APP开发(1)","text":"采用RN开发APP准备篇 准备工作# RN的准备工作请参考官方教程 UI框架选择的是蚂蚁那套Ant-UI MARK# 度娘能找到的rn教程很多不注明版本号，盲目使用其中的解决方案容易导致项目长跪不起，所以再不确定其版本号的情况下，请尽量使用最新的解决方案 ant-ui分别有对应react和rn的两套版本,请注意区分 引用ant-ui需要在xcode中引用对应的tff文件，否则会出现字体找不到的报错 启动#启动前请先打开xcode确保command tool是最新的 123$ npx react-native init AwesomeProject$ cd AwesomeProject$ yarn react-native run-ios 首次启动比较慢，根据电脑配置几分钟到十几分钟不等 核心组件#react-redux#参考vue的vuex, rn也有对应的状态管理，基本教程请参考此链接 axios#基本用法参照vue内的用法，不再赘述。 react-native-router-flux#对应vue-router, rn的路由管理参考链接, 不是很好理解，需要实际上手 页面传参#参考链接 NEXT 基础篇","link":"/2020/10/30/rn-app-step1/"},{"title":"React Native APP开发(3)","text":"采用RN开发APP进阶篇 常用框架 减少样板代码 简化action creator 1234567891011121314151617function makeActionCreator(type, ...argNames) { return function(...args) { let action = { type } argNames.forEach((arg, index) =&gt; { action[argNames[index]] = args[index] }) return action }}const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'export const addTodo = makeActionCreator(ADD_TODO, 'todo')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') 异步action creator + middleware 第三方授权登录 1. 微信授权 一些注意点 1. safeAreaView只对ios有效 2. setSate webview 保存图片、视频等 相册选择图片/视频、拍照等 safearea兼容 常用框架#参考链接 减少样板代码#简化action creator#1234567891011121314151617function makeActionCreator(type, ...argNames) { return function(...args) { let action = { type } argNames.forEach((arg, index) =&gt; { action[argNames[index]] = args[index] }) return action }}const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'export const addTodo = makeActionCreator(ADD_TODO, 'todo')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') 异步action creator + middleware#继上一篇的异步action， 当我们需要获取用户信息、评论列表、产品列表时，一种方案是抽象一个公共的request来处理各个请求，但是这样做共用了request.state, 无法应对单个请求异常超时的情况。这时候可以考虑换个思路抽象，使用thunk提供的中间件功能。 123456789101112export function loadPosts(userId) { return { // 要在之前和之后发送的 action types types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'], // 检查缓存 (可选): shouldCallAPI: (state) =&gt; !state.users[userId], // 进行取： callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`), // 在 actions 的开始和结束注入的参数 payload: { userId } };} 搭配中间件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function callAPIMiddleware({ dispatch, getState }) { return next =&gt; action =&gt; { const { types, callAPI, shouldCallAPI = () =&gt; true, payload = {} } = action if (!types) { // Normal action: pass it on return next(action) } if ( !Array.isArray(types) || types.length !== 3 || !types.every(type =&gt; typeof type === 'string') ) { throw new Error('Expected an array of three string types.') } if (typeof callAPI !== 'function') { throw new Error('Expected callAPI to be a function.') } if (!shouldCallAPI(getState())) { return } const [ requestType, successType, failureType ] = types dispatch(Object.assign({}, payload, { type: requestType })) return callAPI().then( response =&gt; dispatch(Object.assign({}, payload, { response, type: successType })), error =&gt; dispatch(Object.assign({}, payload, { error, type: failureType })) ) }} 至此，可以用下面的例子构造拉取评论、追加评论的异步action 1234567891011121314151617181920212223export function loadComments(postId) { return { types: ['LOAD_COMMENTS_REQUEST', 'LOAD_COMMENTS_SUCCESS', 'LOAD_COMMENTS_FAILURE'], shouldCallAPI: (state) =&gt; !state.posts[postId], callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`), payload: { postId } };}export function addComment(postId, message) { return { types: ['ADD_COMMENT_REQUEST', 'ADD_COMMENT_SUCCESS', 'ADD_COMMENT_FAILURE'], callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`, { method: 'post', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({ message }) }), payload: { postId, message } };} 第三方授权登录#1. 微信授权#参考文章 https://www.cnblogs.com/lude1994/p/10784457.html https://www.npmjs.com/package/react-native-wechat https://www.jianshu.com/p/b1a081165fba 一些注意点#1. safeAreaView只对ios有效#2. setSate#js1234567891011this.setState({ name: 'abc',})console.log(this.state.name) // 输出并不是abc//正确的写法应该是this.setState({ name: 'abc'}, ()=&gt; { console.log(this.state.name) //abc}) webview# 参考文章1参考文章2 失效github 保存图片、视频等# yarn add @react-native-community/camerarollios需要配置info.list NSPhotoLibraryUsageDescription 你懂的安卓需要额外配置权限npm说明 相册选择图片/视频、拍照等# github项目 bash1234567yarn add react-native-image-picker# RN &gt;= 0.60cd ios &amp;&amp; pod install# RN &lt; 0.60react-native link react-native-image-picker safearea兼容# 参考文章","link":"/2020/11/04/rn-app-step3/"},{"title":"sentry-docker","text":"服务器端使用docker部署sentry服务端。 部署参考文章sentry官方文档 架构#Q：Sentry到底是如何实现实时日志监控报警的呢？A：Sentry是一个C/S架构，我们需要在自己应用中集成Sentry的SDK(支持前后端语言)才能在应用发生错误是将错误信息发送给Sentry服务端。根据语言和框架的不同，我们可以选择自动或自定义设置特殊的错误类型报告给Sentry服务端。Sentry的服务端分为web、cron、worker这几个部分，应用（客户端）发生错误后将错误信息上报给web，web处理后放入消息队列或Redis内存队列，worker从队列中消费数据进行处理，postgresql对数据持久化。 my-sentry：sentry的web服务 sentry-cron：sentry的定时任务，活性检测 sentry-worker：业务处理，数据持久化，报警 综上，想在自建服务器上搭建sentry服务端需要跑多个docker容器，请选购稍微大点的配置。 安装#服务器系统环境: centos: 7+ docker: 1.31.1 12345678910111213141516171819# 获取镜像，可能会比较慢docker pull sentry docker pull redisdocker pull postgres# 启动服务docker run -d --name sentry-redis --restart=always redis ###保证了，异常自动拉起docker run -d --name sentry-postgres -e POSTGRES_PASSWORD=密码 -e POSTGRES_USER=sentry --restart=always postgres# 生成sentry秘钥，记得保存哦~docker run --rm sentry config generate-secret-key# 数据库及账户初始化、需要你设置的账号就是WEB的登录账号和密码，稍微有点慢docker run -it --rm -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry upgrade# 启动WEBdocker run -d -p 9000:9000 --name my-sentry -e SENTRY_SECRET_KEY='秘钥' --link sentry-redis:redis --link sentry-postgres:postgres --restart=always sentry# 启动sentry-cron/work服务docker run -d --name sentry-cron -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry run crondocker run -d --name sentry-worker-1 -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry run worker# 查看所有容器，是否有某明奇妙挂了的docker ps -a 在http://{ip}:9000上开始探索新大陆吧~ WEB# 好不犹豫就是Installation Instructions走起来，选择vue项目 傻眼了，刚才登录后的那个设置页面写错了地址，导致sentry.init配置项直接出现了ip…=&gt; 用nginx给9000配置一个域名 1npm install @sentry/browser main.js12345678910import Vue from 'vue'import * as Sentry from '@sentry/browser';import * as Integrations from '@sentry/integrations';Sentry.init({ dsn: 'http://8565417f11494c2b9ad05524717464a9@xxxx.yyy.com/1', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: '20210121v1', //版本号 logErrors: true //开发环境下打印错误}); 这个dsn会报错cros.但是可以不用管，不影响使用。=&gt; 找到好的解决办法再来补充 TEST#在首页mounted中随便写个console.log(abc)，运行页面即可。MARK: 如果使用try-catch把上面的log包含的话，sentry并不能捕获到。 稍微改造下引入函数，只在生产环境中使用sentry 1234567process.env.NODE_ENV == 'production' &amp;&amp; Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: '20210121v1', //版本号 logErrors: true //开发环境下打印错误}); 快速定位错误#获取token的参考文章配置参数位置的参考文章-官方文档配置参数答疑vue/cli4+的插件答疑 安装#我使用的是vue/cli 4+， 所以第一篇文章讲的web.config.js没用上，参照了插件答疑的文章进行配置 12#安装cnpm install --save-dev @sentry/webpack-plugin vue.config.js1234567891011121314151617181920212223242526272829303132333435363738const SentryWebpackPlugin = require(&quot;@sentry/webpack-plugin&quot;);//拼接路径function resolve(dir) { return path.join(__dirname, dir)}module.exports = { // ...其他配置 chainWebpack: config =&gt; { // ...其他插件 config .plugin('@sentry/webpack-plugin') .use( new SentryWebpackPlugin({ release:&quot;20210121v9&quot;, authToken: 'xxxxx', project: 'project_name', url: 'http://xxx.yyy.com', org: 'org_name', include: &quot;.&quot;, ignoreFile: &quot;.sentrycliignore&quot;, ignore: [&quot;node_modules&quot;, &quot;webpack.config.js&quot;], // configFile: &quot;sentry.properties&quot;, urlPrefix:&quot;~/js&quot; }) ) },}//plugin配置例子1chainWebpack(config) { config.plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin)}//plugin配置例子2const MyPlugin = require('plugin')config.plugin('plugin').use(new MyPlugin()) 获取配置参数#token# url# project# org# 测试#一开始跑得很流畅，但是后续几个上传sourceMap之后就无法定位错误位置，才明白是urlPrefix配置错误。 1这个 --url-prefix 是你线上访问到js文件的路径，~ 就是你网站的根目录，比如我网站的静态文件是这样 http://192.168.144.163:8080/static/js/xxxx.js，那么按照上面例子填就是正确的，因为我网站根目录就是 http://192.168.144.163:8080，上传成功后可以在 Releases -&gt; Artifacts 中看到刚才上传的文件 我的线上项目访问js是这样的：http://xx.yy.com/js/chunk.xxxx.js =&gt;所以urlPrefix得配置成 ~/js 配置sourseMap前的报错是这样的 配置后的报错定位。请注意右手边的一排小按钮，可以切换 =&gt; 快速定位报错位置 优化#为了成为项目应用，需要在开发环境中屏蔽sentry, 同时将版本号统一管理。 main.js123456process.env.NODE_ENV == 'production' &amp;&amp; Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: process.env.VUE_APP_RELEASE_VERSION, //版本号 logErrors: true //开发环境下打印错误}); vue.config.js12345678910111213141516process.env.NODE_ENV == 'production' &amp;&amp; config .plugin('@sentry/webpack-plugin') .use( new SentryWebpackPlugin({ release: process.env.VUE_APP_RELEASE_VERSION, authToken: 'f38e0c1683e84581be211f4ffce5287d2c776fd78fac4afba4c30ab92a2b9f39', project: 'abc', url: 'http://xxx.yyy.com', org: 'sentry', include: &quot;.&quot;, ignoreFile: &quot;.sentrycliignore&quot;, ignore: [&quot;node_modules&quot;, &quot;webpack.config.js&quot;], // configFile: &quot;sentry.properties&quot;, urlPrefix:&quot;~/js&quot; }) ) Q &amp; A#Q: error pulling image configuration: unknown blob# 查看docker文件 /etc/docker/daemon.json (没有的话 手动创建下), 我之前用的是163的镜像，切换成aliyun的。 打开阿里云容器镜像服务页面, 加加速器地址复制到上述json中。123{ &quot;registry-mirrors&quot;: [&quot;https://7ctk7xl2.mirror.aliyuncs.com&quot;]} 重启docker,记得把其他容器也重新跑起来。一般改了阿里云之后，拉取镜像的速度会起飞。 Q： chrome下的cors问题#我的服务端版本号是9.1.2， vue端是7在safari中上传没问题，报错时只发送一次xxx.yyy.com/api/2/store?xxx=xxxx.但是到了chrome下，出了上述报错外，还额外发了两次xxx.yyy.com/api/2/envelope?xxx=xxxx一开始还以为是客服端的cors配置出了问题，尝试半天未果。然后有怀疑是chorme的问题，还关掉了ad-block等，依旧不能解决。最后在官方github下看到这个issueSeems I can fix it by adding startTransactionOnPageLoad: false in BrowserTracing, closed然并卵！！！ 最终，我把nginx配置设置成这样 123456789101112131415161718server { listen 80; server_name xxx.yyy.com; proxy_set_header Connection ''; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Request-Id $request_id; proxy_read_timeout 30s; proxy_send_timeout 5s; location / { proxy_pass http://sentryServer; }} main.js123456789101112Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [ new Integrations.Vue({Vue, attachProps: true}), new TracingIntegrations.BrowserTracing({ startTransactionOnPageLoad: false, }), ], release: process.env.VUE_APP_RELEASE_VERSION, //版本号 logErrors: true, //开发环境下打印错误 // _experiments: { useEnvelope: true },}); sentry服务端设置： projects -&gt; your_project -&gt; setting -&gt; general settings -&gt; domain 改为* stroe请求正常发送，envelope依旧不消停。 sad~ 知道原因的小伙伴请速速留言！！！","link":"/2021/01/21/sentry-docker/"},{"title":"rn-elements","text":"本文介绍react-native-elements在rn项目中的使用。 参考文章官方文档","link":"/2020/12/02/rn-elements/"},{"title":"vue-step-by-step","text":"vue教程(在实际项目中的基本使用) Step 1 起步 编辑器 VS Code cnpm 运行项目 项目结构 Step 2 组件的生命周期 页面 vue-router 全局钩子 路由钩子 组件钩子 vuex - store Step 3 思考 More keepActive的存在意义 为什么router-link时使用name vue-bus 全局通知 Step 4 优化加载 混入 自定义指令 客户端数据库 loki.js 服务端渲染 Nuxt 国际化 i18n 规范总结 Step 1#起步#vue有大版本区别，建议使用最新版。@vue/cli对于vue就像是spring-boot-starter对于spring-boot一样。 sh1234567## 全局安装cli工具，以后开发都会用到，所以建议全局安装npm install -g @vue/clicd someDir ..## 创建项目vue create step-by-step# ORvue ui vue create之后默认选择就行ESLint一开始会有所不适应，可以先放放。至此,创建一个叫做step-by-step项目。 编辑器 VS Code#和所有前端项目一样，可以直接使用idea/eclipse/sublime等工具来编写vue项目，在此推荐vscode cnpm#cnpm是国内采用淘宝镜像的组件工具，相比npm，获取依赖速度大大加快。以后项目中都会用到，建议全局安装。 12npm install cnpm -gnpm install cnpm -g --registry=https://registry.npm.taobao.org 运行项目#12345cd step-by-step#获取依赖cnpm i #测试运行npm run serve 不出意外将在命令窗口看到如下输出语句 12345DONE Compiled successfully in 1901ms 2:16:44 PMApp running at:- Local: http://localhost:8080/ - Network: http://192.168.3.32:8080/Note that the development build is not optimized. 项目结构#初始的项目距离开发需求还很远，先对项目结构做一下补充。 12345678910111213141516+ public+ src + assets - css //需要自己创建 - images //需要自己创建 + components + layouts //需要自己创建 + pages //需要自己创建 + configs //需要自己创建 + apis //需要自己创建 + utils //需要自己创建 - App.vue - main.js- vue.config.js //需要自己创建- babel.config.js- package.json 一个呈现在浏览器上的页面需要符合这样的层级结构：app &gt; layout &gt; page &gt; component。当我们项目需要不同的框架布局时，就可以定义不同的layout。举例子：正常浏览器访问查询列表的时候，我们需要header和footer，但是当我们的页面被别的项目用iframe引用时，就需要全局调整header和footer Step 2#组件的生命周期#改造初始后的项目，使其符合上一节所说的层级结构。阅读下面内容前，请先查看DEMO-S1从console中我们能看到打印结果为 1234567891011before layout createlayout createdbefore header createheader createdbefore content createcontent createdbefore footer createfooter createdheader mountedcontent mountedfooter mounted 由此，当我们在项目中加载数据的时候就需要注意了，layout/page/compontent各个阶段加载数据的先后顺序。父组件先create -&gt; 子组件 create -&gt; 子组件mounted -&gt; 父组件mounted 页面#阅读下面内容前，请先查看DEMO-S2了解了组件加载的先后顺序，我们尝试写一个符合规范的页面.为此我们需要新增依赖。 sh12cnpm i vue-router axios vuex --save# 记得重新npm run serve vue-router#基本用法: 123456789101112131415161718import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter);const router = new VueRouter({ mode: 'history', routes: [ { path: '/', //懒加载 component: () =&gt; import('../pages/index.vue') //or component: IndexPage } ]});export default router router-view 在src/components/common/content中包含这个标签，可以理解为根据配置的router来匹配组件。参考文档 router 与 钩子 全局钩子: beforeEach与afterEach的使用，配合store来查询用户权限、追加日志等 路由独享: 组件钩子: 全局钩子# to:router即将进入的路由对象 from:当前导航即将离开的路由 next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。 1234567891011121314151617181920212223router.beforeEach((to, from, next) =&gt; { console.log(store.state.token) const route = ['index', 'list']; let isLogin = store.state.token; // 是否登录 // 未登录状态；当路由到route指定页时，跳转至login if (route.indexOf(to.name) &gt;= 0) { if (isLogin == null) { router.push({ path: '/login', }); } } // 已登录状态；当路由到login时，跳转至home console.log(to.name) localStorage.setItem('routerName', to.name) if (to.name === 'login') { if (isLogin != null) { router.push({ path: '/HomeMain', });; } } next();});router.afterEach((to, from) =&gt; { console.log(to.fullPath, to.path, location.href)}); 路由钩子#12345678910111213const router = new VueRouter({ mode: 'history', routes: [ { path: '/dashboard', //懒加载 component: resolve =&gt; require(['../components/page/Dashboard.vue'], resolve) meta: { title: '系统首页' }, beforeEnter: (to, from, next) =&gt; { }, beforeLeave: (to, from, next) =&gt; { }, } ]}); 组件钩子#12345678910111213141516171819&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data: ()=&gt; ({}), beforeRouteLeave(to, from, next) { next() }, beforeRouteEnter(to, from, next) { next() }, beforeRouteUpdate(to, from, next) { next() }, computed: {}, method: {}}&lt;/script&gt; vuex - store#官方文档 state:驱动应用的数据源； view: 以声明方式将 state 映射到视图； actions: 响应在 view 上的用户输入导致的状态变化。 mutation: 原函数改变state的数据 action: 异步请求 -&gt; 有必要的话可以在返回前调用mutation12this.$store.commit('clearUsrInfo') //mutationthis.$store.dispatch('getProductList') //action Step 3#思考#对于SPA项目，各种数据请求/处理应该在哪个位置发生？带着以下问题查看DEMO-S3 有登录用户吗？ 存在本地化的授权token 校验token是否有效 用户的基本信息什么时候更新，保存在哪？那些数据虽然需要，但不需要本地化? 只存token,其他数据在必要的时候远程更新 当前用户有权查看当前页面信息吗？ 查store校验 调用远程接口由后台判断 -&gt; nuxt 用户的浏览行为在哪里发出？逐个页面发送日志，还是统一发送？ 借用钩子(全局钩子/路由钩子) 不同级别的用户对应不同的界面/菜单，我应该在哪个层进行识别才能避免用户看到不该看的信息？ 根据数据敏感程度自行斟酌：低敏感度、高敏感度 api统一管理的意义何在？是否需要全部使用action 可以适当偷懒，直接调用axios 统一管理：解耦合 More#阅读以下以下代码时，请先查看DEMO-S4 keepActive的存在意义#router.js12345678910111213const router = new Router({ ... routes: [ { name: 'test', path: '/test', component: ()=&gt; import('@/pages/test/index'), meta: { keepAlive: true } } ] }) compontents/xx.js1234&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 为什么router-link时使用name#当我们需要修改某个页面的路径的时候，不必逐个页面修改，只需要在router.js中修改path即可。 vue-bus 全局通知#1cnpm i --save vue-bus 123456789101112import VueBus from 'vue-bus'Vue.use(VueBus)this.$bus.on('some-action', actionHandle)this.$bus.once('some-action-happen-once', actionHandle)this.$bus.emit('some-action', paylod)actionHanlle: function(paylod) {} Step 4#优化加载#阅读以下代码请先查看DEMO-S5 外部引用 loki.js为例 在public/index.html中顶部引用外部script 在vue.config.js中配置映射关系 按需引用 element-ui为例123456789101112131415161718192021222324252627/* 第一步cnpm i --save babel-preset-envcnpm i --dev babel-plugin-component*///第二步修改.babel.config.jsmodule.exports = { presets: [ '@vue/cli-plugin-babel/preset', ], plugins: [ // element官方教程 [ &quot;component&quot;, { libraryName: &quot;element-ui&quot;, styleLibraryName: &quot;theme-chalk&quot; } ] ]}//第三部在main.js中import { Button } from 'element-ui';Vue.use(Button);//第四部实际组件中&lt;el-button @click=&quot;addTodo&quot;&gt;Vue-Bus&lt;/el-button&gt; 包分析package.json123456// cnpm i -D webpack-bundle-analyzer// 追加指令 &quot;scripts&quot;: { ... &quot;analyz&quot;: &quot;npm run build --analyze&quot; }, vue.config.js123456789101112131415161718const path = require('path');//拼接路径function resolve(dir) { return path.join(__dirname, dir)}module.exports = { ... chainWebpack: config =&gt; { config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) config.resolve.alias .set('@', resolve('src')) .set('#', resolve('public')) },} gzip nginx配置缓存和压缩 webpack压缩设置 混入#阅读以下代码请先查看DEMO-S5对于需要鉴权的页面，都会包含用户的基本信息，怎么才能避免每个组件都复制黏贴呢？ -&gt; 全局混入demo中我们点击/mine页面中的按钮可以直接修改header中的显示。 main.js1234567891011Vue.mixin({ created: function () {}, //混入对象的钩子将在组件自身钩子之前调用 computed: { ...mapState({ citySN: state =&gt; state.citySN }), ...mapGetters({ authBJS: 'fromBJS', }) },}) 其他还有组件混入等，可以查看官方文档。需要注意各种混入方式中遇到名称冲突时的规则。 自定义指令#在手机端页面上常常会有这样的需求：页面/组件打开(show)时自动focus输入框 -&gt; 自定义指令focus官方文档我们修改之前根据三字码查询机场名称的代码（/loki页面） 123456789directives: { focus: { // 指令的定义 inserted: function (el) { let ipt = el.hasChildNodes() ? el.querySelector('input') : el ipt.focus() } }}, 客户端数据库 loki.js#Github关键是看下examples。结合localStorage避免页面多次加载json。 服务端渲染 Nuxt#准备额外开文章说，暂且略过。 国际化 i18n#官方文档 规范总结# 保证项目文档结构 vue页面/组件内尽可能少使用axios请求，统一到apis/xxx.js目录下 梳理store.state内容,灵活使用getters localStorage.item中只存储必要信息，切勿将state全部存在localStorage中(若后期增减/修改字段会需要额外维护) 利用router钩子进行鉴权，避免暴露敏感页面 抽象request.js，为所有api使用，保证数据处理的一致性(主要是错误编码、报错信息的一致) 灵活使用router-view组件，减少页面渲染 组件间(非父子关系)时，使用vue-bus,切勿使用localStorage 使用混入，减少组件的重复代码 外部引用、按需引用、代码压缩等优化加载。","link":"/2021/01/08/vue-step-by-step/"},{"title":"使用笔记之Midway","text":"简单记录在使用过程中遇到的问题 基本使用#在此不赘述，可以直接参考[midway官方文档(https://www.yuque.com/midwayjs/midway_v2) typeorm#github文档find详细用法=&gt;不一定完全满足实际业务需求 =&gt; 这时候就需要querybuilder@column详细用法英文文档=&gt;更加详细 1234//select: boolean - Defines whether or not to hide this column by default when making queries. When set to false, the column data will not show with a standard query. By default column is select: true@Column({ select: false}) mac下使用oracledb#本以为直接npm i xxx就可以解决，结果发现还是有很多小坑的。 首先按照orm的要求写完配置之后发现报错，进一步根据报错信息打开oracle文档。 但是这个文档其实不太容易让人明白具体要完成什么，只能莫名其妙的按照步骤一步一步走： 下载dmg/zip, 双击打开(dmg的话) 在terminal中运行指令$ /Volumes/instantclient-basic-macos.x64-19.8.0.0.0dbru/install_ic.sh，这时候显示如下123/Users/matthew/Downloads/instantclient_19_8Creating dir: /Users/matthew/Downloads/instantclient_19_8...Copying /Volumes/instantclient-basic-macos.x64-19.8.0.0.0dbru files ... 再次跑一下项目发现报错，显示没有找到dylib文件 回到文档，按照提示把这个文件拷贝到/usr/local/lib下 cp ~/Downloads/instantclient_19_8/{libclntsh.dylib.19.1,libclntshcore.dylib.19.1,libnnz19.dylib,libociei.dylib} /usr/local/lib/ 再次跑项目，显示 TNS:listener does not currently know of service requested in connect descrip... =&gt; 看了一下简书的文档，发现官方mysql的链接配置不适用oracle 更改连接配置如下12345678910export default { orm: { type: 'oracle', username: 'user', password: 'pw', connectString: '{u_ip}:{u_port}/{u_server_name}', synchronize: false, logging: false, }}; 再次跑项目，这次在调用findOne时发现报错orm ORA-00933: SQL command not properly ended =&gt; 放弃findOne, 使用find函数 将entity/model下实体类的属性名改成和oracle严格一致 =&gt; 大小写必须一致 enjoy @midwayjs/orm-数据库find的详细文档queryBuilder前人整理的文档，事务、缓存等都可以在这里查到 linux docker跑项目#最开始使用node:12来建立镜像跑服务，想起来上面说的官网配置oracle-client的事情，蹭蹭蹭按照文档搞了一遍，最后始终是环境变量无效。只好找个轮子试试docker pull migutak/oracledbnode:1.0.1. 开心，啥也不用配置了，简简单单按照官方文档跑服务就行。在这个过程中顺便学到了新的知识： Dockerfile 中的APP会自动解压、COPY不会 docker run指令中-e 可以设置容易的环境变量 =&gt; 如果设置了宿主的环境变量想要内部oracledb来获取XXX_PATH,即使获取到了也无法使用对应的XXX.so文件 环境配置#package.json的scripts中配置-env=test的优先级高于docker run中指定NODE_SERVER_ENV 1234//package.json&quot;test&quot;: &quot;egg-scripts start --title=my-midway-project --framework=@midwayjs/web --env=test&quot;,//docker rundocker run --name xxx -p 7012:7001 -e EGG_SERVER_ENV=prod -d xxx 生效的将是config.test.ts所以最好的办法是test中去掉–env参数 或者沿用推荐的online指令 1&quot;online&quot;: &quot;egg-scripts start --title=my-midway-project --framework=@midwayjs/web&quot;","link":"/2021/03/17/%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%E4%B9%8BMidway/"},{"title":"前端基础之Blob、ArrayBuffer","text":"ArrayBuffer 对象与 Blob 对象常见于文件上传操作处理（如处理图片上传预览等问题）。 ArrayBuffer 对象#ArrayBuffer 对象是 ES6 才纳入正式 ECMAScript 规范，是 JavaScript 操作二进制数据的一个接口。ArrayBuffer 对象是以数组的语法处理二进制数据，也称二进制数组。介绍 ArrayBuffer 对象还需介绍 TypedArray 视图和 DataView 视图，本文不具体介绍，详细可以查看阮一峰老师《ECMAScript 6 入门 ArrayBuffer》 章节。 1. 概念介绍#ArrayBuffer 对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图）来读写，视图的作用是以指定格式解读二进制数据。关于 TypedArray 视图和 DataView 视图 ，可以查看阮一峰老师《ECMAScript 6 入门 ArrayBuffer》 章节的介绍。 2. 对象使用#浏览器原生提供 ArrayBuffer() 构造函数，用来生成实例。 参数： 整数，表示二进制数据占用的字节长度。 返回值: 一个指定大小的 ArrayBuffer 对象，其内容被初始化为 0。1const buffer = new ArrayBuffer(32); 上面代码表示实例对象 buffer 占用 32 个字节。 3. 实例属性和方法#ArrayBuffer 对象有实例属性 byteLength ，表示当前实例占用的内存字节长度（单位字节），一单创建就不可变更（只读）： 12const buffer = new ArrayBuffer(32);buffer.byteLength; // 32 4. slice()#slice()用来复制一部分内存。 参数如下： start，整数类型，表示开始复制的位置。默认从 0 开始。 end，整数类型，表示结束复制的位置（不包括结束的位置）。如果省略，则表示复制到结束。12const buffer = new ArrayBuffer(32);const buffer2 = buffer.slice(0); Blob 对象#1. 概念介绍#Blob 全称：Binary Large Object （二进制大型对象）。Blob 对象表示一个二进制文件的数据内容，通常用来读写文件，比如一个图片文件的内容就可以通过 Blob 对象读写。 与 ArrayBuffer 区别： Blob 用于操作二进制文件 ArrayBuffer 用于操作内存 2. 对象使用#浏览器原生提供 Blob() 构造函数，用来生成实例。 Blob 的内容由参数数组中给出的值的串联组成。 1const leoBlob = new Blob(array [, options]); array，必填，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；成员可以是一个由 ArrayBuffer , ArrayBufferView , Blob , DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。 options，可选，是一个配置对象，这里介绍常用的属性 type，表示数据的 MIME 类型，默认空字符串； options 目前可能有两个属性： type 和 endings。 endings 用于指定包含行结束符 \\n 的字符串如何被写入，默认值 transparent。它只有这两个值：native （代表行结束符会被更改为适合宿主操作系统文件系统的换行符）和 transparent （代表会保持blob中保存的结束符不变）。 12const leoHtmlFragment = ['&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey leo！&lt;/b&gt;&lt;/a&gt;']; // 一个包含 DOMString 的数组const leoBlob = new Blob(leoHtmlFragment, {type : 'text/html'}); // 得到 blob 该代码中，实例对象 leoBlob 包含的是字符串。生成实例时，指定数据类型为 text/html。 还可以使用 Blob 保存 JSON 数据： 12const obj = { hello: 'leo' };const blob = new Blob([ JSON.stringify(obj) ], {type : 'application/json'}); 3. 实例属性和方法#Blob 具有两个实例属性： size：文件的大小，单位为字节。 type：文件的 MIME 类型。如果类型无法确定，则返回空字符串。12345const leoHtmlFragment = ['&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey leo！&lt;/b&gt;&lt;/a&gt;']; // 一个包含 DOMString 的数组const leoBlob = new Blob(leoHtmlFragment, {type : 'text/html'}); // 得到 blobleoBlob.size; // 38leoBlob.type; // &quot;text/html&quot; Blob 实例方法： slice：方法用于创建一个包含源 Blob 的指定字节范围内的数据的新 Blob 对象。 start，可选，起始的字节位置，默认 0； end，可选，结束的字节位置，默认 size 属性的值，不包含该位置； contentType，可选，新实例的数据类型（默认为空字符串）；1const newBlob = oldBlob.slice([start [, end [, contentType]]]) 4. 实际案例#获取文件信息#文件选择器 &lt;input type=&quot;file&quot;&gt; 用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的 value 属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。文件选择器返回一个 FileList 对象，该对象是个类数组对象，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了 name 和 lastModifiedDate 属性。也包括拖放 API 的 dataTransfer.files 返回的也是一个 FileList 对象，成员也是 File 实例对象。1234567891011121314// HTML 代码如下// &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&gt;function fileinfo(files) { for (let i = 0; i &lt; files.length; i++) { let f = files[i]; console.log( f.name, // 文件名，不含路径 f.size, // 文件大小，Blob 实例属性 f.type, // 文件类型，Blob 实例属性 f.lastModifiedDate // 文件的最后修改时间 ); }} 下载文件#在 AJAX 请求中，指定 responseType 属性为 blob ，皆可以下下载一个 Blob 对象。123456789function getBlob(url, callback) { const xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.responseType = 'blob'; xhr.onload = function () { callback(xhr.response); } xhr.send(null);} 然后，xhr.response 拿到的就是一个 Blob 对象。 生成 URL#浏览器允许使用 URL.createObjectURL() 方法，针对 Blob 对象生成一个临时URL，以便于某些 API 使用。 如作为图片预览的 URL。 这个 URL 以 blob:// 开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与 data://URL（URL 包含实际数据）和 file://URL（本地文件系统里面的文件）都不一样。 1234567891011121314151617const droptarget = document.getElementById('droptarget');droptarget.ondrop = function (e) { const files = e.dataTransfer.files; for (let i = 0; i &lt; files.length; i++) { let type = files[i].type; if (type.substring(0,6) !== 'image/') continue; let img = document.createElement('img'); img.src = URL.createObjectURL(files[i]); img.onload = function () { this.width = 100; document.body.appendChild(this); URL.revokeObjectURL(this.src); } }} 代码中，通过为拖放的图片文件生成一个 URL，作为预览的缩略图。 浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。 读取文件#取得 Blob 对象以后，可以通过 FileReader 对象，读取 Blob 对象的内容，即文件内容。 FileReader 对象提供四个方法。将 Blob 对象作为参数传入，然后以指定的格式返回。 FileReader.readAsText()：返回文本，需要指定文本编码，默认为 UTF-8。 FileReader.readAsArrayBuffer()：返回 ArrayBuffer 对象。 FileReader.readAsDataURL()：返回 Data URL。 FileReader.readAsBinaryString()：返回原始的二进制字符串。下面是 FileReader.readAsText() 方法的例子，用来读取文本文件：12345678910111213141516// HTML 代码如下// &lt;input type='file' onchange='readfile(this.files[0])'&gt;&lt;/input&gt;// &lt;pre id='output'&gt;&lt;/pre&gt;function readfile(f) { let reader = new FileReader(); reader.readAsText(f); reader.onload = function () { let text = reader.result; let out = document.getElementById('output'); out.innerHTML = ''; out.appendChild(document.createTextNode(text)); } reader.onerror = function(e) { console.log('Error', e); };} 下面是 FileReader.readAsArrayBuffer() 方法的例子，用于读取二进制文件：1234567891011121314151617181920212223// HTML 代码如下// &lt;input type=&quot;file&quot; onchange=&quot;typefile(this.files[0])&quot;&gt;&lt;/input&gt;function typefile(file) { // 文件开头的四个字节，生成一个 Blob 对象 let slice = file.slice(0, 4); let reader = new FileReader(); // 读取这四个字节 reader.readAsArrayBuffer(slice); reader.onload = function (e) { let buffer = reader.result; // 将这四个字节的内容，视作一个32位整数 let view = new DataView(buffer); let magic = view.getUint32(0, false); // 根据文件的前四个字节，判断它的类型 switch(magic) { case 0x89504E47: file.verified_type = 'image/png'; break; case 0x47494638: file.verified_type = 'image/gif'; break; case 0x25504446: file.verified_type = 'application/pdf'; break; case 0x504b0304: file.verified_type = 'application/zip'; break; } console.log(file.name, file.verified_type); };}","link":"/2021/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BBlob/"},{"title":"前端基础之WebSocket","text":"WebSocket 是一种网络通信协议，很多高级功能都需要它 why#初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 特点： 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 示例#123456789101112131415var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) { console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSockets!&quot;);};ws.onmessage = function(evt) { console.log( &quot;Received Message: &quot; + evt.data); ws.close();};ws.onclose = function(evt) { console.log(&quot;Connection closed.&quot;);}; API#WebSocket 构造函数#WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 webSocket.readyState#readyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。下面是一个示例。1234567891011121314151617switch (ws.readyState) { case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;} webSocket.onopen#实例对象的onopen属性，用于指定连接成功后的回调函数。123ws.onopen = function () { ws.send('Hello Server!');} 如果要指定多个回调函数，可以使用addEventListener方法。123ws.addEventListener('open', function (event) { ws.send('Hello Server!');}); webSocket.onclose#实例对象的onclose属性，用于指定连接关闭后的回调函数。12345678910111213ws.onclose = function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event};ws.addEventListener(&quot;close&quot;, function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event}); webSocket.onmessage#实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。123456789ws.onmessage = function(event) { var data = event.data; // 处理数据};ws.addEventListener(&quot;message&quot;, function(event) { var data = event.data; // 处理数据}); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。12345678910ws.onmessage = function(event){ if(typeof event.data === String) { console.log(&quot;Received data string&quot;); } if(event.data instanceof ArrayBuffer){ var buffer = event.data; console.log(&quot;Received arraybuffer&quot;); }} 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。1234567891011// 收到的是 blob 数据ws.binaryType = &quot;blob&quot;;ws.onmessage = function(e) { console.log(e.data.size);};// 收到的是 ArrayBuffer 数据ws.binaryType = &quot;arraybuffer&quot;;ws.onmessage = function(e) { console.log(e.data.byteLength);}; webSocket.send()#实例对象的send()方法用于向服务器发送数据。1234567891011121314ws.send('your message');//发送 Blob 对象的例子。var file = document .querySelector('input[type=&quot;file&quot;]') .files[0];ws.send(file);//发送 ArrayBuffer 对象的例子。// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) { binary[i] = img.data[i];}ws.send(binary.buffer); webSocket.bufferedAmount#实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。1234567var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) { // 发送完毕} else { // 发送还没结束} webSocket.onerror#实例对象的onerror属性，用于指定报错时的回调函数。1234567socket.onerror = function(event) { // handle error event};socket.addEventListener(&quot;error&quot;, function(event) { // handle error event}); 服务端#搭建#12brew install nodenpm install ws server.js123456789101112131415let WebSocketServer = require('ws').Server, wss = new WebSocketServer({ port: 8181 });//服务端口8181wss.on('connection', function (ws) { console.log('服务端：客户端已连接'); ws.on('message', function (event) { //打印客户端监听的消息 console.log(event); let data = JSON.parse(event) if(data &amp;&amp; data.msg) { ws.send(data.name + ', 你好, 消息已收到') } else { ws.send('你说了啥?') } });}); 1node server.js client.html12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;body&gt; &lt;form role=&quot;form&quot; id=&quot;chat_form&quot; onsubmit=&quot;sendMessage(); return false;&quot; style=&quot;margin-top:100px;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; name=&quot;message&quot; id=&quot;message&quot; value=&quot;&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;button&quot; id=&quot;send&quot; class=&quot;btn btn-primary&quot; onclick=&quot;sendMessage();&quot;&gt; 发送 &lt;/button&gt; &lt;/form&gt; &lt;script&gt; let ws = new WebSocket(&quot;ws://localhost:8181&quot;); ws.onopen = function (e) { //成功连接服务器回调 console.log('客户端（client）：与服务器的连接已打开') let msg = { time: new Date().toDateString(), id: 1, name: 'matthew', msg: '你好' } ws.send(JSON.stringify(msg)) } ws.onmessage = function(e) { console.log(e.data) } function sendMessage() { let msg = { time: new Date().toDateString(), id: 1, name: 'matthew', msg: document.getElementById('message').value } ws.send(JSON.stringify(msg)); } &lt;/script&gt;&lt;/body&gt; 运行#12node server.js # 不要关闭命令窗口 将html文件在浏览器中打开，查看console","link":"/2021/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BWebSocket/"},{"title":"前端基础之Worker","text":"Web Worker是HTML5中提出的概念，用来处理独立于主线程处理高费时的任务，从而不会阻塞主线程。目前绝大部分浏览器都支持Web Worker功能。 基本使用 创建 通信： 收发消息 worker加载脚本 错误处理 关闭 Worker 数据通信 同页面的 Web Worker Worker 新建 Worker API 示例 Web Worker的使用一般是指定一个脚本的URI来执行worker线程，通过postMessage方法和onmessage事件处理函数来进行数据传递。同时，如果Worker线程与主线程频繁的通信，仍然可能影响页面的性能。对于复杂的计算处理来说，只执行一次的话，也没有必要使得Worker线程一直存在. Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。 Web Worker 有以下几个使用注意点。 同源限制 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 DOM 限制 Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。 通信联系 Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 脚本限制 Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。 文件限制 Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。但可以使用Blob。 基本使用#创建#main.js12345678910const code = [ `self.fn = ${f.toString()};`, 'self.onmessage = (e) =&gt; {', ' const r = self.fn(e.data);', ' self.postMessage(r);', '}'];const blob = new Blob(code, { type: 'text/javascript' });const url = URL.createObjectURL(blob);const worker = new Worker(url); Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。 通信： 收发消息#主线程调用worker.postMessage()方法，向 Worker 发消息。 main.js123worker.postMessage('Hello World');worker.postMessage({method: 'echo', args: ['Work']});worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。 接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。 worker.js123456789worker.onmessage = function (event) { console.log('Received message ' + event.data); doSomething();}function doSomething() { // 执行任务 worker.postMessage('Work done!');} 上面代码中，事件对象的data属性可以获取 Worker 发来的数据。 Worker 完成任务以后，主线程就可以把它关掉。 main.js1worker.terminate(); Worker 线程内部需要有一个监听函数，监听message事件。 worker.js123self.addEventListener('message', function (e) { self.postMessage('You said: ' + e.data);}, false); 上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。 worker.js123456789// 写法一this.addEventListener('message', function (e) { this.postMessage('You said: ' + e.data);}, false);// 写法二addEventListener('message', function (e) { postMessage('You said: ' + e.data);}, false); 除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。 根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。 worker.js1234567891011121314self.addEventListener('message', function (e) { var data = e.data; switch (data.cmd) { case 'start': self.postMessage('WORKER STARTED: ' + data.msg); break; case 'stop': self.postMessage('WORKER STOPPED: ' + data.msg); self.close(); // Terminates the worker. break; default: self.postMessage('Unknown command: ' + data.msg); };}, false); 上面代码中，self.close()用于在 Worker 内部关闭自身。 worker加载脚本#Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。 worker.js123importScripts('script1.js');//该方法可以同时加载多个脚本。importScripts('script1.js', 'script2.js'); 错误处理#主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。 main.js123456789worker.onerror(function (event) { console.log([ 'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message ].join(''));});// 或者worker.addEventListener('error', function (event) { // ...}); Worker 内部也可以监听error事件。 关闭 Worker#使用完毕，为了节省系统资源，必须关闭 Worker。 12345// 主线程worker.terminate();// Worker 线程self.close(); 数据通信#主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。 12345678910111213// 主线程var uInt8Array = new Uint8Array(new ArrayBuffer(10));for (var i = 0; i &lt; uInt8Array.length; ++i) { uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]}worker.postMessage(uInt8Array);// Worker 线程self.onmessage = function (e) { var uInt8Array = e.data; postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString()); postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);}; 但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。 如果要直接转移数据的控制权，就要使用下面的写法。 main.js123456// Transferable Objects 格式worker.postMessage(arrayBuffer, [arrayBuffer]);// 例子var ab = new ArrayBuffer(1);worker.postMessage(ab, [ab]); 同页面的 Web Worker#通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。 123456789&lt;!DOCTYPE html&gt; &lt;body&gt; &lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt; addEventListener('message', function () { postMessage('some message'); }, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面是一段嵌入网页的脚本，注意必须指定&lt;script&gt;标签的type属性是一个浏览器不认识的值，上例是app/worker。 然后，读取这一段嵌入页面的脚本，用 Worker 来处理。 main.js1234567var blob = new Blob([document.querySelector('#worker').textContent]);var url = window.URL.createObjectURL(blob);var worker = new Worker(url);worker.onmessage = function (e) { // e.data === 'some message'}; 上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。 Worker 新建 Worker#Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持。 略 API#浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。 1var myWorker = new Worker(jsUrl, options); Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。 12345// 主线程var myWorker = new Worker('worker.js', { name : 'myWorker' });// Worker 线程self.name // myWorker Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下: Worker.onerror：指定 error 事件的监听函数。 Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。 Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。 Worker.postMessage()：向 Worker 线程发送消息。 Worker.terminate()：立即终止 Worker 线程。 Web Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。 Worker 线程有一些自己的全局属性和方法: self.name： Worker 的名字。该属性只读，由构造函数指定。 self.onmessage：指定message事件的监听函数。 self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。 self.close()：关闭 Worker 线程。 self.postMessage()：向产生这个 Worker 线程发送消息。 self.importScripts()：加载 JS 脚本。 示例#1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt; addEventListener('message', function (e) { postMessage('worker recieved message: ' + e.data.content); }, false); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var blob = new Blob([document.querySelector('#worker').textContent]); var url = window.URL.createObjectURL(blob); var worker = new Worker(url); worker.postMessage({ fromMain: true, content: 'I am from Main thread!' }) worker.onmessage = function(e){ console.log(e.data) worker.terminate() } &lt;/script&gt;&lt;/body&gt;","link":"/2021/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BWorker/"},{"title":"前端基础之bind、call、apply","text":"在上一篇文章简单介绍bind/call/apply之后，详细介绍下这三位js重量级选手 加深理解 call、apply apply - call 区别 使用示例 面试实例 bind 使用实例1：预定义参数 使用实例2： 与setTimeout/setinterval一起使用 使用实例3：作为构造函数 使用实例4： 捷径 自己来构造bind方法：bind并不是在所有浏览器中都支持(低版本浏览器不支持) mark: 多次bind无效，只有第一次bind是生效的 call/apply/bind 重写bind、call、apply、new 加深理解# apply/call/bind是Function自带的方法 改变Function中的this指向 -&gt; 移花接木 call、apply#1234567891011121314151617181920212223function fruits() { console.log('this from spell:', this) // fruits}fruits.prototype = { color: 'red', say: function() { console.log('this from say:', this) //指向fruits console.log('my color is ' + this.color) }, tell: () =&gt; { console.log('this from tell:', this) // 指向Windows }}let apple = new fruits //立即执行 function内的代码apple.say()apple.tell()//console.log//this from spell: fruits {}//this from say: fruits {}//my color is red//this from tell: Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} 此时如果我们构建一个banana = {color:’yellow’}对象，但是不想反复创建say方法，就可以直接使用apply/call来借用apply的方法 1234567891011let banana = { color: 'yellow'}apple.say.call(banana)apple.say.apply(banana)//console.log// this from say: {color: &quot;yellow&quot;} color: &quot;yellow&quot;__proto__: Object// my color is yellow// this from say: {color: &quot;yellow&quot;} color: &quot;yellow&quot;__proto__: Object// my color is yellow 此时say方法内的this指向了banana对象 apply - call 区别#入参方式不同 123456let func = function(arg1, arg2) {}func.call(this, arg1, arg2)func.apply(this, [arg1, arg2]) 使用示例#12345678let array1 = [12, 'foo', '-123', {name: 'Joe'}]let array2 = ['Deo', '555', 100]Array.prototype.push.apply(array1, array2)console.log(array1)//console(7) [12, &quot;foo&quot;, &quot;-123&quot;, {…}, &quot;Deo&quot;, &quot;555&quot;, 100] 12345let numbers = [1, 10, 12, 2, 4]let maxInNumers = Math.max.apply(Math, numbers)let minInNumbers = Math.min.call(Math, 1, 10, 2, 4)console.log(maxInNumers) // 12console.log(minInNumbers) // 1 1234// 验证是否是数组(toString未被修改)function isArray(obj) { return Object.prototype.toString.call(obj) === '[object Array]'} 面试实例#题1： 定义一个log方法，代理console.log方法 1234567891011121314151617181920212223function log(...args) { console.log(args)}function log1() { console.log.apply(console, arguments)}function log2() { let args = Array.prototype.slice.call(arguments) args.unshift('(app) ') console.log.apply(console, args)}log(1,2)log1(1,2,3)log2('1', 'wncwejcnk', {abc: 'test'})//console(2) [1, 2]1 2 3(app) 1 wncwejcnk {abc: &quot;test&quot;} bind#错误实例1：将方法从一个对象中拿出来赋值，并且希望this指向原来的对象，一般不做特殊处理都会丢失原来的对象 1234567let altwrite = document.writealtwrite('hello') // Uncaught TypeError: Illegal invocation//altwrite改变this的指向global或者window,导致非法调用//正确姿势altwrite.bind(document)('hello') // helloaltwrite.call(document, 'hello') // hello bind用于创建一个函数，使这个函数无论怎么调用都有相同的this值 当使用bind绑定函数时，以创建时传入bind的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数韩兆顺序作为原函数的参数来调用函数 示例1： 1234567891011121314151617181920212223let foo = { bar: 1, eventBind: function() { let _this = this $('.someClass').on('click', function(){ console.log(this) //&lt;h1 class=&quot;someClass&quot;&gt;abc&lt;/h1&gt; console.log(_this) //{bar: 1, eventBind: ƒ} }) }}foo.eventBind()let foo1 = { bar: 2, eventBind: function() { $('.someClass').on('click', function(){ console.log(this) //{bar: 2, eventBind: ƒ} }.bind(this)) }}foo1.eventBind() 示例2： 123456789101112let bar2 = function() { console.log(this.x)}bar2() //undefinedlet barObject = { x: 'this is from barObject'}let barFunc = bar2.bind(barObject) //不会立即执行barFunc() //this is from barObject 使用实例1：预定义参数#12345678910function list() { return Array.prototype.slice.call(arguments)}let list1 = list(1,2,3) // [1,2,3]let leading37List = list.bind(undefined, 37)let list2 = leading37List(1,2,3) // [37, 1, 2 ,3]let list3 = leading37List() // [37] 使用实例2： 与setTimeout/setinterval一起使用#12345678910111213141516171819202122232425function Bloomer() { this.petalCount = Math.ceil(Math.random() * 12 + 1)}Bloomer.prototype.bloom = function() { window.setTimeout(this.declare.bind(this), 1000)}Bloomer.prototype.declare = function() { console.log('declare.this', this) console.log('i have ' + this.petalCount + ' petal')}let bloo = new Bloomer // 等同于 new Bloomer()bloo.bloom() //i have 3 petallet myBloomer = { petalCount: 12}Bloomer.prototype.bloom2 = function(obj) { window.setTimeout(this.declare.bind(obj), 1000)}bloo.bloom2(myBloomer) //i have 12 petalbloo.bloom2().bind(myBloomer) // Uncaught TypeError: Cannot read property 'bind' of undefined 使用实例3：作为构造函数#适用于使用new操作符来构造目标函数的实例：此时this会被忽略，但传入的参数仍然有效(第二个参数开始) 12345678910111213141516171819202122function Point(x, y) { this.x = x; this.y = y;}Point.prototype.toString = function() { console.log(this.x + ',' + this.y)}let p = new Point(1, 2)p.toString() // 1,2let emptyObj = {}let YAxisPoint = Point.bind(emptyObj, 0) //x=0let YAxisPoint2 = Point.bind(null, 0) //不会报错，this被忽略let axisPoint = new YAxisPoint(5)axisPoint.toString() //0,5console.log(axisPoint instanceof Point) //trueconsole.log(axisPoint instanceof YAxisPoint) //trueconsole.log(new Point(1,3) instanceof YAxisPoint) //true 使用实例4： 捷径#12345678//改造前let slice = Array.prototype.sliceslice.call(arguments)//改造后let unbounSlice = Array.prototype.slicelet slice2 = Function.prototype.call.bind(unboundSlice)slice2(arguments) 自己来构造bind方法：bind并不是在所有浏览器中都支持(低版本浏览器不支持)#1234567891011121314151617181920Function.prototype.bind = function (oThis) { if (typeof this !== &quot;function&quot;) { throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {}, fBound = function () { return fToBind.apply( this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)) ); }; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;}; mark: 多次bind无效，只有第一次bind是生效的#bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。 call/apply/bind#123456789101112131415let obj = { x: 81,}; let fooObj = { x: 3, getX: function() { return this.x; }} console.log(fooObj.getX.bind(obj)()); //81 , 多一个（）console.log(fooObj.getX.call(obj)); //81console.log(fooObj.getX.apply(obj)); console.log(fooObj.getX()) // 3 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 重写bind、call、apply、new#参考文档-掘金","link":"/2021/02/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8Bbind-call-apply/"},{"title":"前端基础之页面渲染与网路请求","text":"新开主题介绍计算机基础，其实也是前端的基础！ 页面渲染 DOM CSSOM 加载JS Render Tree 页面的重绘（repaint）与重排（reflow） 重绘（repaint）： 重排/回流（reflow）： NOTE 1. 重排必将引起重绘，而重绘不一定会引起重排。 2. 何时回引起重排？ 3. **如何减少和避免重排 ** 网络请求 TCP 三次握手建立连接 TCP 四次握手断开连接 Q &amp; A 为什么要将js放到页脚部分 引入样式的几种方式的权重 css属性书写顺序建议 何种类型的DOM操作是耗费性能的 参考文档 Q:从用户输入浏览器输入url到页面最后呈现 有哪些过程？ 用户输入URL地址 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存） 浏览器将端口号从URL中解析出来 浏览器建立一条与目标Web服务器的TCP连接（三次握手） 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器返回一条HTTP响应报文 关闭连接 浏览器解析文档 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕 页面渲染#主流的两个浏览器内核为WebKit 和 Gecko(Mozilla) 两者在用词上稍有差异，但主题流程基本为： HTML解析出DOM Tree CSS解析出Style Rules 将二者关联生成Render Tree Layout 根据Render Tree计算每个节点的信息 Painting 根据计算好的信息绘制整个页面 DOM#DOM树构建过程： 读取html文档， 将字节转换成字符， 确定tokens（标签）， 再将tokens转换成节点，以节点构建 DOM 树 CSSOM#CSSOM树构建过程与DOM树构建流程一致： 读取CSS文档， 将字节转换成字符， 确定tokens（标签）， 再将tokens转换成节点，以节点构建 CSSOM 树 加载JS#若在构建DOM树的过程中，当 HTML 解析器遇到一个 script 标记时，即遇到了js，将立即阻塞DOM树的构建，将控制权移交给 JavaScript 引擎，等到 JavaScript 引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建。 其根本原因在于，JS会对DOM节点进行操作，浏览器无法预测未来的DOM节点的具体内容，为了防止无效操作，节省资源，只能阻塞DOM树的构建。譬如，若不阻塞DOM树的构建，若JS删除了某个DOM节点A，那么浏览器为构建此节点A花费的资源就是无效的。 若在HTML头部加载JS文件，由于JS阻塞，会推迟页面的首绘。为了加快页面渲染，一般将JS文件放到HTML底部进行加载，或是对JS文件执行async或defer加载。 Render Tree#渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。 构建渲染树，根据渲染树计算每个可见元素的布局，并输出到绘制流程，将像素渲染到屏幕上。 页面的重绘（repaint）与重排（reflow）#重绘（repaint）：#屏幕的一部分要重绘。渲染树节点发生改变，但不影响该节点在页面当中的空间位置及大小。譬如某个div标签节点的背景颜色、字体颜色等等发生改变，但是该div标签节点的宽、高、内外边距并不发生变化，此时触发浏览器重绘（repaint）。 重排/回流（reflow）：#当渲染树节点发生改变，影响了节点的几何属性（如宽、高、内边距、外边距、或是float、position、display：none;等等），导致节点位置发生变化，此时触发浏览器重排（reflow），需要重新生成渲染树。譬如JS为某个p标签节点添加新的样式：”display:none;”。导致该p标签被隐藏起来，该p标签之后的所有节点位置都会发生改变。此时浏览器需要重新生成渲染树，重新布局，即重排（reflow）。 NOTE#1. 重排必将引起重绘，而重绘不一定会引起重排。#2. 何时回引起重排？#当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排： 添加或者删除可见的DOM元素； 元素位置改变——display、float、position、overflow等等； 元素尺寸改变——边距、填充、边框、宽度和高度 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变； 页面渲染初始化； 浏览器窗口尺寸改变——resize事件发生时； 3. **如何减少和避免重排 **#Reflow 的成本比 Repaint 的成本高得多的多。一个节点的 Reflow 很有可能导致子节点，甚至父节点以及兄弟节点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）； 让要操作的元素进行”离线处理”，处理完后一起更新； 使用DocumentFragment进行缓存操作,引发一次回流和重绘； 使用display:none技术，只引发两次回流和重绘； 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存； 让元素脱离动画流，减少回流的Render Tree的规模； 网络请求#TCP 三次握手建立连接#TCP 四次握手断开连接#Q &amp; A#为什么要将js放到页脚部分#引入样式的几种方式的权重#css属性书写顺序建议#何种类型的DOM操作是耗费性能的#参考文档#参考文档1how browsers workhow browsers work中文翻译","link":"/2021/01/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BD%91%E8%B7%AF%E8%AF%B7%E6%B1%82/"},{"title":"前端进阶之LRU实现","text":"参考文档","link":"/2021/02/19/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8BLRU%E5%AE%9E%E7%8E%B0/"},{"title":"算法基础-递归","text":"L. Peter Deutsch 说过：To Iterate is Human, to Recurse, Divine.中文译为：人理解迭代，神理解递归。 概念#递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。 =&gt; 数学归纳法 数学归纳法适用于将解决的原问题转化为解决它的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在相同的逻辑归纳处理项。当然有一个是例外的，也就是归纳结束的那一个处理方法不适用于我们的归纳处理项，当然也不能适用，否则我们就无穷归纳了 三要素#明确递归终止条件#我们知道，递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递去而是开始实实在在的归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。 给出递归终止时的处理办法#我们刚刚说到，在递归的临界点存在一种简单情境，在这种简单情境下，我们应该直接给出问题的解决方案。一般地，在这种情境下，问题的解决方案是直观的、容易的。 提取重复的逻辑，缩小问题规模#我们在阐述递归思想内涵时谈到，递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，我们需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。 编程模型#模型一： 在递去的过程中解决问题#12345678function recursion(大规模){ if (end_condition) { // 明确的递归终止条件 end; // 简单情景 } else { // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题 solve; // 递去 recursion(小规模); // 递到最深处后，不断地归来 }} 模型二： 在归来的过程中解决问题#12345678function recursion(大规模){ if (end_condition) { // 明确的递归终止条件 end; // 简单情景 } else { // 先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题 recursion(小规模); // 递去 solve; // 归来 }} 例子#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235/*** Title: 阶乘的实现 * Description:* 递归解法* 非递归解法* @author rico*/const Factorial = (n)=&gt; { if(n == 1) // 递归终止条件 return 1; // 简单情景 return n * Factorial(n-1); // 相同重复逻辑，缩小问题的规模}/** 斐波那契数列如下：* 1,1,2,3,5,8,13,21,34,...*/const fibonacci = (n)=&gt; { if (n == 1 || n == 2) return 1; return fibonacci(n-1) + fibonacci(n-2);}/** * @description 对经典递归法的优化 * * 斐波那契数列如下： * * 1,1,2,3,5,8,13,21,34,... * * 那么，我们可以这样看：fib(1,1,5) = fib(1,2,4) = fib(2,3,3) = 5 * * 也就是说，以1,1开头的斐波那契数列的第五项正是以1,2开头的斐波那契数列的第四项， * 而以1,2开头的斐波那契数列的第四项也正是以2,3开头的斐波那契数列的第三项， * 更直接地，我们就可以一步到位：fib(2,3,3) = 2 + 3 = 5,计算结束。 * * 注意，前两个参数是数列的开头两项，第三个参数是我们想求的以前两个参数开头的数列的第几项。 * 时间复杂度：O(n)* * @param first 数列的第一项* @param second 数列的第二项* @param n 目标项* @return */const optimizeFibonacci = (first, second, n)=&gt; { if (n &gt; 0) { if(n == 1){ // 递归终止条件 return first; // 简单情景 }else if(n == 2){ // 递归终止条件 return second; // 简单情景 }else if (n == 3) { // 递归终止条件 return first + second; // 简单情景 } return optimizeFibonacci(second, first + second, n - 1); // 相同重复逻辑，缩小问题规模 } return -1;}/** * 杨辉三角 * 杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。* 它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。* * 例如，下面给出了杨辉三角形的前4行： * 1 * 1 1* 1 2 1* 1 3 3 1* @description 递归获取杨辉三角指定行、列(从0开始)的值* 注意：与是否创建杨辉三角无关* @x 指定行* @y 指定列 */const trangleValue = (x, y)=&gt; { if(y &lt;= x &amp;&amp; y &gt;= 0){ if(y == 0 || x == y){ // 递归终止条件 return 1; }else{ // 递归调用，缩小问题的规模 return trangleValue(x-1, y-1) + trangleValue(x-1, y); } } return -1;}/** * @description 递归判断一个字符串是否是回文字符串 * @param s * @return */const isPalindromeString_recursive = (s)=&gt; { let start = 0; let end = s.length - 1; if(end &gt; start){ // 递归终止条件:两个指针相向移动，当start超过end时，完成判断 if(s.charAt(start) != s.charAt(end)){ return false; }else{ // 递归调用，缩小问题的规模 return isPalindromeString_recursive(s.substring(start+1).substring(0, end-1)); } } return true;}/** * 字符串全排列 * @description 从字符串数组中每次选取一个元素，作为结果中的第一个元素;然后，对剩余的元素全排列* @param s* 字符数组* @param from* 起始下标* @param to* 终止下标*/const getStringPermutations3 = (s, from, to)=&gt; { if (s != null &amp;&amp; to &gt;= from &amp;&amp; to &lt; s.length &amp;&amp; from &gt;= 0) { // 边界条件检查 if (from == to) { // 递归终止条件 console.log(s); // 打印结果 } else { for (let i = from; i &lt;= to; i++) { swap(s, i, from); // 交换前缀,作为结果中的第一个元素，然后对剩余的元素全排列 getStringPermutations3(s, from + 1, to); // 递归调用，缩小问题的规模 swap(s, from, i); // 换回前缀，复原字符数组 } } } }const swap = (s, from, to)=&gt; { let temp = s[from]; s[from] = s[to]; s[to] = temp;}/*** @description 二分查找的递归实现* @param array 目标数组* @param low 左边界* @param high 右边界* @param target 目标值* @return 目标值所在位置*/const binarySearch = (array, low, high, target)=&gt; { //递归终止条件 if(low &lt;= high){ let mid = (low + high) &gt;&gt; 1; if(array[mid] == target){ return mid + 1; // 返回目标值的位置，从1开始 } else if(array[mid] &gt; target){ // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除 return binarySearch(array, low, mid-1, target); } else{ // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除 return binarySearch(array, mid+1, high, target); } } return -1; //表示没有搜索到}/*** Title: 递归求解二叉树的深度*/const getTreeDepth = (t) =&gt; { // 树为空 if (t == null) // 递归终止条件 return 0; let left = getTreeDepth(t.left); // 递归求左子树深度，缩小问题的规模 let right = getTreeDepth(t.left); // 递归求右子树深度，缩小问题的规模 return left &gt; right ? left + 1 : right + 1;}/* 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。*/var generateParenthesis = function (n) { const res = []; const dfs = (lRemain, rRemain, str) =&gt; { // 左右括号所剩的数量，str是当前构建的字符串 if (str.length == 2 * n) { // 字符串构建完成 res.push(str); // 加入解集 return; // 结束当前递归分支 } if (lRemain &gt; 0) { // 只要左括号有剩，就可以选它，然后继续做选择（递归） dfs(lRemain - 1, rRemain, str + &quot;(&quot;); } if (lRemain &lt; rRemain) { // 右括号比左括号剩的多，才能选右括号 dfs(lRemain, rRemain - 1, str + &quot;)&quot;); // 然后继续做选择（递归） } }; dfs(n, n, &quot;&quot;); // 递归的入口，剩余数量都是n，初始字符串是空串 return res;};/* 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。*/function ListNode(val, next) { this.val = (val===undefined ? 0 : val) this.next = (next===undefined ? null : next)}var reverseKGroup = function(head, k) { if(!head) return head; let tmpArray = [], tmpHeader = new ListNode(head.val, head.next) for(let i = 0; i &lt; k; i++) { if(tmpHeader) { tmpArray.push(tmpHeader) } else { break; } tmpHeader = tmpHeader.next } if(tmpArray.length &lt; k) { return head } let nextUnitHeader = reverseKGroup(tmpHeader, k) for(let i = k - 1; i &gt; 0; i --) { let node = tmpArray[i] node.next = tmpArray[i-1] } tmpArray[0].next = nextUnitHeader return tmpArray[k-1]};let reverseKGroupNode1 = new ListNode(1)let reverseKGroupNode2 = new ListNode(2, reverseKGroupNode1)let reverseKGroupNode3 = new ListNode(3, reverseKGroupNode2)let reverseKGroupNode4 = new ListNode(4, reverseKGroupNode3) 参考文档#csdn","link":"/2021/02/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92/"},{"title":"ES6笔记1-let与const","text":"mark: 本系列笔记是对照阮一峰ES6教程进行的查漏补缺。 let 不存在变量提升 暂时性死区 note: typeof 隐蔽的死区 不允许重复声明 块级作用域 函数声明 note: 避免在块级作用域内声明函数 const 顶层对象 globalThis 声明变量的六种方法 ES5 只有两种声明变量的方法：var命令和function命令。 ES6 除了添加let和const命令， 另外两种声明变量的方法：import命令和class命令 let#12345678//varvar a = [];for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 12345678//letvar a = [];for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 1234567for (let i = 0; i &lt; 3; i++) { let i = 'abc'; console.log(i);}// abc// abc// abc 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升#1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区#只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) { tmp = 'abc'; // ReferenceError let tmp;} 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) { // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123} 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 note: typeof#“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // &quot;undefined&quot; 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 隐蔽的死区#有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) { return [x, y];}bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) { return [x, y];}bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 不允许重复声明#let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() { let a = 10; var a = 1;}// 报错function func() { let a = 10; let a = 1;} 因此，不能在函数内部重新声明参数。 1234567891011function func(arg) { let arg;}func() // 报错function func(arg) { { let arg; }}func() // 不报错 块级作用域#ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() { console.log(tmp); if (false) { var tmp = 'hello world'; }}f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) { console.log(s[i]);}console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 let实际上为 JavaScript 新增了块级作用域。 1234567function f1() { let n = 5; if (true) { let n = 10; } console.log(n); // 5} 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 1234{{{{ {let insane = 'Hello World'} console.log(insane); // 报错}}}}; 上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。 内层作用域可以定义外层作用域的同名变量。 1234{{{{ let insane = 'Hello World'; {let insane = 'Hello World'}}}}}; 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。 12345678910// IIFE 写法(function () { var tmp = ...; ...}());// 块级作用域写法{ let tmp = ...; ...} 函数声明#ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 1234567891011// 情况一if (true) { function f() {}}// 情况二try { function f() {}} catch(e) { // ...} 上面两种函数声明，根据 ES5 的规定都是非法的。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 12345678910function f() { console.log('I am outside!'); }(function () { if (false) { // 重复声明一次函数f,即使if语句进不来 function f() { console.log('I am inside!'); } } f();}()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 123456789// ES5 环境function f() { console.log('I am outside!'); }(function () { function f() { console.log('I am inside!'); } if (false) { } f();}()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 123456789101112// 浏览器的 ES6 环境function f() { console.log('I am outside!'); }(function () { if (false) { // 重复声明一次函数f function f() { console.log('I am inside!'); } } f();}());// Uncaught TypeError: f is not a function 上面的代码在 ES6 浏览器中，都会报错。 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。 1234567891011// 浏览器的 ES6 环境function f() { console.log('I am outside!'); }(function () { var f = undefined; if (false) { function f() { console.log('I am inside!'); } } f();}());// Uncaught TypeError: f is not a function note: 避免在块级作用域内声明函数#考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 123456789101112131415// 块级作用域内部的函数声明语句，建议不要使用{ let a = 'secret'; function f() { return a; }}// 块级作用域内部，优先使用函数表达式{ let a = 'secret'; let f = function () { return a; };} 另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。 1234567// 第一种写法，报错if (true) let x = 1;// 第二种写法，不报错if (true) { let x = 1;} 上面代码中，第一种写法没有大括号，所以不存在块级作用域，而let只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。 函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。 12345678910// 不报错'use strict';if (true) { function f() {}}// 报错'use strict';if (true) function f() {} const#const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = {};// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = {}; // TypeError: &quot;foo&quot; is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 12345const foo = Object.freeze({});// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; { if ( typeof obj[key] === 'object' ) { constantize( obj[key] ); } });}; 顶层对象#顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。 ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 globalThis#JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node.js 模块中this返回的是当前模块，ES6 模块中this返回的是undefined。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () { if (typeof self !== 'undefined') { return self; } //web worker if (typeof window !== 'undefined') { return window; } //window if (typeof global !== 'undefined') { return global; } // node throw new Error('unable to locate global object');}; ES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。","link":"/2021/03/04/ES6%E7%AC%94%E8%AE%B01-let%E4%B8%8Econst/"},{"title":"ES6笔记11-class","text":"最近看了知乎上的超智能体栏目，决定给ES6系列收个尾，class然后是module。还记得被A.proto.prototype 和 A.prototype__proto__支配的恐惧吗？？？？~~~~ 关于__proto__和prototype的区别于联系，参阅知乎问答后补充在文章最末尾.请不要过度纠结阮一峰老师教程中的一些细节。 0. 简介#ES5的写法:构造函数 12345678910function Point(x, y) { this.x = x; this.y = y;}Point.prototype.toString = function () { return '(' + this.x + ', ' + this.y + ')';};var p = new Point(1, 2); ES6的写法：class语法糖 1234567891011121314class Point { //构造方法 constructor(x, y) { this.x = x; //this指向实例 this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; }}typeof Point // &quot;function&quot;Point === Point.prototype.constructor // true 类的数据类型就是函数，类本身就指向构造函数。构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 1234567891011121314151617181920class Point { constructor() { // ... } toString() { // ... } toValue() { // ... }}// 等同于Point.prototype = { constructor() {}, toString() {}, toValue() {},}; 因此，在类的实例上面调用方法，其实就是调用原型上的方法。 123456class B {}const b = new B();b.constructor === B.prototype.constructor // true //进一步 b.constructor === B //true 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类添加多个方法。 12345678910class Point { constructor(){ // ... }}Object.assign(Point.prototype, { toString(){}, toValue(){}}); prototype对象的constructor()属性，直接指向“类”的本身，这与 ES5 的行为是一致的。 1Point.prototype.constructor === Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 constructor 方法#constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。 1234567class Point {}// 等同于class Point { constructor() {}} constructor()方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 类必须使用new调用，否则会报错 类的实例#与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 123456789101112131415161718//定义类class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; }}var point = new Point(2, 3);point.toString() // (2, 3)point.hasOwnProperty('x') // truepoint.hasOwnProperty('y') // truepoint.hasOwnProperty('toString') // falsepoint.__proto__.hasOwnProperty('toString') // truepoint.__proto__ === Point.prototype //true x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty()方法返回true，而toString()是原型对象的属性（因为定义在Point类上），所以hasOwnProperty()方法返回false。这些都与 ES5 的行为保持一致。 与 ES5 一样，类的所有实例共享一个原型对象。 1234var p1 = new Point(2,3);var p2 = new Point(3,2);p1.__proto__ === p2.__proto__ //true p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。 取值函数（getter）和存值函数（setter）#与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 12345678910111213141516171819class MyClass { constructor() { // ... } get prop() { return 'getter'; } set prop(value) { console.log('setter: '+value); }}let inst = new MyClass();inst.prop = 123;// setter: 123inst.prop// 'getter' 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。存值函数和取值函数是设置在属性的 Descriptor 对象上的。 属性表达式 -&gt; 联想symbol作为属性名#类的属性名，可以采用表达式。 12345678910let methodName = 'getArea';class Square { constructor(length) { // ... } [methodName]() { // ... }} 上面代码中，Square类的方法名getArea，是从表达式得到的。 Class 表达式#与函数一样，类也可以使用表达式的形式定义。 12345const MyClass = class Me { getClassName() { return Me.name; }}; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。 123let inst = new MyClass();inst.getClassName() // MeMe.name // ReferenceError: Me is not defined 上面代码表示，Me只在 Class 内部有定义。如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 1const MyClass = class { /* ... */ }; 采用 Class 表达式，可以写出立即执行的 Class。 1234567891011let person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); }}('张三');person.sayName(); // &quot;张三&quot; 上面代码中，person是一个立即执行的类的实例。 注意点#1. 严格模式#类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式 2. 不存在提升#3. name 属性#由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 12class Point {}Point.name // &quot;Point&quot; name属性总是返回紧跟在class关键字后面的类名。 4. Generator 方法#如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。 5. this 的指向 =&gt; 切勿脱离对象后单独使用#类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger { printName(name = 'there') { this.print(`Hello ${name}`); } print(text) { console.log(text); }}const logger = new Logger();const { printName } = logger;printName(); // TypeError: Cannot read property 'print' of undefined 1. 静态方法#如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。如果静态方法包含this关键字，这个this指的是类，而不是实例。 123456789101112131415161718class Foo { static classMethod() { return 'hello'; } static bar() { this.baz(); } static baz() { console.log('hello'); }}Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a functionFoo.bar() // hello 父类的静态方法，可以被子类继承。静态方法也是可以从super对象上调用的。 12345678910111213class Foo { static classMethod() { return 'hello'; }}class Bar extends Foo { static classMethod() { return super.classMethod() + ', too'; }}Bar.classMethod() // &quot;hello, too&quot; 2. 实例属性的新写法#实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。 12345678910class IncreasingCounter { _count = 0; get value() { console.log('Getting the current value!'); return this._count; } increment() { this._count++; }} 3. 静态属性#静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 12345class Foo {}Foo.prop = 1;Foo.prop // 1 4. 私有方法和私有属性#私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。 5. new.target 属性#new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 1234567891011// 另一种写法function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error('必须使用 new 命令生成实例'); }}var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 报错 Class 内部调用new.target，返回当前 Class。 123456789class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); this.length = length; this.width = width; }}var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 1234567891011121314151617class Shape { constructor() { if (new.target === Shape) { throw new Error('本类不能实例化'); } }}class Rectangle extends Shape { constructor(length, width) { super(); // ... }}var x = new Shape(); // 报错var y = new Rectangle(3, 4); // 正确 5. 继承简介#12345678910111213class Point {}class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString() }} 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。 ES6与ES5的区别：ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 6. Object.getPrototypeOf()#Object.getPrototypeOf方法可以用来从子类上获取父类。 12Object.getPrototypeOf(ColorPoint) === Point// true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 7. super 关键字#super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。 ES6 要求，子类的构造函数必须执行一次super函数。super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。1234567class A {}class B extends A { constructor() { super(); }} 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。1234567891011121314class A { p() { return 2; }}class B extends A { constructor() { super(); console.log(super.p()); // 2 }}let b = new B(); 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。1234567891011121314class A { constructor() { this.p = 2; }}class B extends A { get m() { return super.p; }}let b = new B();b.m // undefined 上面代码中，p是父类A实例的属性，super.p就引用不到它。如果属性定义在父类的原型对象上，super就可以取到。1234567891011class A {}A.prototype.x = 2;class B extends A { constructor() { super(); console.log(super.x) // 2 }}let b = new B(); ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。123456789101112131415161718192021class A { constructor() { this.x = 1; } print() { console.log(this.x); }}class B extends A { constructor() { super(); this.x = 2; } m() { super.print(); }}let b = new B();b.m() // 2 由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。1234567891011121314151617class A { constructor() { this.x = 1; }}class B extends A { constructor() { super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 }}let b = new B(); 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。 123456789101112131415161718192021222324class Parent { static myMethod(msg) { console.log('static', msg); } myMethod(msg) { console.log('instance', msg); }}class Child extends Parent { static myMethod(msg) { super.myMethod(msg); } myMethod(msg) { super.myMethod(msg); }}Child.myMethod(1); // static 1var child = new Child();child.myMethod(2); // instance 在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 123456789101112131415161718192021class A { constructor() { this.x = 1; } static print() { console.log(this.x); }}class B extends A { constructor() { super(); this.x = 2; } static m() { super.print(); }}B.x = 3; //静态属性B.m() // 3 8. 类的 prototype 属性和__proto__属性#这一节能容请直接参阅文章最末尾内容。 9. 原生构造函数的继承#略 10. Mixin 模式的实现#略 11. prototype 与 proto#实例的 proto 属性# 在JS里，万物皆对象. Function是对象，其原型Function.prototype是对象。因此，它们都会具有对象共有的特点。即：对象具有属性__proto__，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。 Function这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。 结合上图： 构造函数Function的属性prototype是一个对象：虽然写作Function.prototype，但实际是个对象=&gt; 原型对象 f1/f2实例的隐式原型(f1.proto)指向其构造函数(Foo)的原型(Foo.prototype):所有实例共享构造函数的原型-对象 Fuction.prototype保存所有实例共享的方法，其中Fuction.prototype.constructor指向构造函数Function =&gt; Fuction.prototype.constructor === Fuction （true） Foo作为构造函数的同时也是一个对象=&gt; Function的实例，那么它也有__proto__属性 Function是Object的一个实例 Object的隐式原型为null： Object.prototype.proto = null 类的prototype属性和__proto__属性#理顺了上面的关系，我们再来看阮老师教程里面的内容。 =&gt; 下面的内容涉及到了继承(子类和父类)，上面的内容讲的是实例和类的关系 Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。12345678class A {}class B extends A {}B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 原理点这！！！ 类的继承是按照下面的模式实现的。 12345678910111213class A {}class B {}// B 的实例继承 A 的实例Object.setPrototypeOf(B.prototype, A.prototype);// B 继承 A 的静态属性Object.setPrototypeOf(B, A);const b = new B(); 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 1234Object.setPrototypeOf = function (obj, proto) {obj.__proto__ = proto;return obj;} 因此，就得到了上面的结果。 1234567Object.setPrototypeOf(B.prototype, A.prototype);// 等同于B.prototype.__proto__ = A.prototype;Object.setPrototypeOf(B, A);// 等同于B.__proto__ = A; 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。 123B.prototype = Object.create(A.prototype);// 等同于B.prototype.__proto__ = A.prototype; 注意两种情况。第一种，子类继承Object类。 12345class A extends Object {}A.__proto__ === Object // trueA.prototype.__proto__ === Object.prototype // true 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种情况，不存在任何(显式)继承。 12345class A {}A.__proto__ === Function.prototype // trueA.prototype.__proto__ === Object.prototype // true 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。 ….嗯，自己再写点具有迷惑性的测试下记住了没 1234567class B {}class A extends B {}A.__proto__.__proto__ === B.prototype // 提示 A.__proto__ === BA.__proto__.prototype === undefinedA.prototype.__proto__ === B.prototypeB.prototype.__proto__ === Object.prototype 写到这想起来上面的图片，有一点忘记提了： 类的原型(对象),比如说Foo.prototype, 其实有个隐式的继承，继承自Object.prototype。这也就是为啥图上有个Foo.prototype.proto === Object.prototype的箭头。这里的proto__正是继承的体现。同样的Function.prototype.__proto__也是继承自Object.prototype,而Object.prototype.__proto == null表示的是这是根对象，没从其他类中继承。 特别指正Function.prototype是一个函数，而不是对象，感兴趣的小伙伴可以自己console下试一试！！ 12Function.prototypeƒ () { [native code] }","link":"/2021/03/29/ES6%E7%AC%94%E8%AE%B011-class/"},{"title":"ES6笔记3-字符串的拓展与新增方法","text":"字符串、数组、对象等等的拓展方法都比较零碎，找重点记一下。 拓展 字符的 Unicode 表示法 直接输入 U+2028 和 U+2029 模板字符串 =&gt; 反斜杠 新增方法 1. String.fromCodePoint() 2. String.raw() 3. 实例方法：codePointAt() 正确获取字符串长度和utf-16编码 4. 实例方法：normalize() =&gt; Unicode 正规化 5. 实例方法：includes(), startsWith(), endsWith() 6. 实例方法：repeat() 7. 实例方法：padStart()，padEnd() 8. 实例方法：trimStart()，trimEnd() 9. 实例方法：matchAll() 10. 实例方法：replaceAll() 关于replaceAll()的第二个参数 PS 表示字符串的6中方法 拓展#字符的 Unicode 表示法#ES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 也就是意味着length的返回为2，不是1 12345&quot;\\uD842\\uDFB7&quot;// &quot;𠮷&quot;&quot;\\u20BB7&quot;// &quot; 7&quot; 即使这种表示法，length 依旧为2 上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 12345678&quot;\\u{20BB7}&quot;// &quot;𠮷&quot;&quot;\\u{41}\\u{42}\\u{43}&quot;// &quot;ABC&quot;let hello = 123;hell\\u{6F} // 123'\\u{1F680}' === '\\uD83D\\uDE80'// true 为了获取字符串长度的问题，单纯使用length和for循环依旧无法获得准确值。这时候需要用for..of来解决let text = String.fromCodePoint(0x20BB7); 1234567891011121314151617for (let i = 0; i &lt; text.length; i++) { console.log(text[i]);}// &quot; &quot;// &quot; &quot;for (let i of text) { console.log(i);}// &quot;𠮷&quot;for (let codePoint of 'foo') { console.log(codePoint)}// &quot;f&quot;// &quot;o&quot;// &quot;o&quot; 直接输入 U+2028 和 U+2029#JavaScript 字符串允许直接输入字符，以及输入字符的转义形式。举例来说，“中”的 Unicode 码点是 U+4e2d，你可以直接在字符串里面输入这个汉字，也可以输入它的转义形式\\u4e2d，两者是等价的。 JavaScript 规定有5个字符，不能在字符串里面直接使用，只能使用转义形式。 U+005C：反斜杠（reverse solidus) U+000D：回车（carriage return） U+2028：行分隔符（line separator） U+2029：段分隔符（paragraph separator） U+000A：换行符（line feed） 模板字符串 =&gt; 反斜杠#传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 新增方法#1. String.fromCodePoint()#ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。 12String.fromCharCode(0x20BB7)// &quot;ஷ&quot; 上面代码中，String.fromCharCode()不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正好与下面的codePointAt()方法相反。 1234String.fromCodePoint(0x20BB7)// &quot;𠮷&quot;String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'// true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 2. String.raw()#ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。 1234String.raw`Hi\\n${2+3}!`// 实际返回 &quot;Hi\\\\n5!&quot;，显示的是转义后的结果 &quot;Hi\\n5!&quot;String.raw`Hi\\u000A!`;// 实际返回 &quot;Hi\\\\u000A!&quot;，显示的是转义后的结果 &quot;Hi\\u000A!&quot; 如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。 123String.raw`Hi\\\\n`// 返回 &quot;Hi\\\\\\\\n&quot;String.raw`Hi\\\\n` === &quot;Hi\\\\\\\\n&quot; // true 3. 实例方法：codePointAt()#JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 1234567var s = &quot;𠮷&quot;;s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。 ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。 总之，codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。 codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。 1234let s = '𠮷a';s.codePointAt(0).toString(16) // &quot;20bb7&quot;s.codePointAt(2).toString(16) // &quot;61&quot; 你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别 32 位的 UTF-16 字符。 正确获取字符串长度和utf-16编码#123456let s = '𠮷a';for (let ch of s) { console.log(ch.codePointAt(0).toString(16));}// 20bb7// 61 另一种方法也可以，使用扩展运算符（…）进行展开运算。 123456let arr = [...'𠮷a']; // arr.length === 2arr.forEach( ch =&gt; console.log(ch.codePointAt(0).toString(16)));// 20bb7// 61 codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 12345function is32Bit(c) { return c.codePointAt(0) &gt; 0xFFFF;}is32Bit(&quot;𠮷&quot;) // trueis32Bit(&quot;a&quot;) // false 4. 实例方法：normalize() =&gt; Unicode 正规化#许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。 1234'\\u01D1'==='\\u004F\\u030C' //false'\\u01D1'.length // 1'\\u004F\\u030C'.length // 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。12'\\u004F\\u030C'.normalize('NFC').length // 1'\\u004F\\u030C'.normalize('NFD').length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 5. 实例方法：includes(), startsWith(), endsWith()#传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。6. 实例方法：repeat()#repeat方法返回一个新字符串，表示将原字符串重复n次。12345678910111213141516171819202122'x'.repeat(3) // &quot;xxx&quot;'hello'.repeat(2) // &quot;hellohello&quot;'na'.repeat(0) // &quot;&quot;//参数如果是小数，会被取整。'na'.repeat(2.9) // &quot;nana&quot;//如果repeat的参数是负数或者Infinity，会报错。'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError//但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。'na'.repeat(-0.9) // &quot;&quot;//参数NaN等同于 0。'na'.repeat(NaN) // &quot;&quot;//如果repeat的参数是字符串，则会先转换成数字。'na'.repeat('na') // &quot;&quot;'na'.repeat('3') // &quot;nanana&quot; 7. 实例方法：padStart()，padEnd()#ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。123456789// 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx'//如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。'abc'.padStart(10, '0123456789')// '0123456abc'//如果省略第二个参数，默认使用空格补全长度。'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。123'1'.padStart(10, '0') // &quot;0000000001&quot;'12'.padStart(10, '0') // &quot;0000000012&quot;'123456'.padStart(10, '0') // &quot;0000123456&quot; 另一个用途是提示字符串格式。12'12'.padStart(10, 'YYYY-MM-DD') // &quot;YYYY-MM-12&quot;'09-12'.padStart(10, 'YYYY-MM-DD') // &quot;YYYY-09-12&quot; 8. 实例方法：trimStart()，trimEnd()#ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。12345const s = ' abc ';s.trim() // &quot;abc&quot;s.trimStart() // &quot;abc &quot;s.trimEnd() // &quot; abc&quot; 上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。 9. 实例方法：matchAll()#matchAll()方法返回一个正则表达式在当前字符串的所有匹配 10. 实例方法：replaceAll()#历史上，字符串的实例方法replace()只能替换第一个匹配。 12'aabbcc'.replace('b', '_')// 'aa_bcc' 上面例子中，replace()只将第一个b替换成了下划线。如果要替换所有的匹配，不得不使用正则表达式的g修饰符。 是不是很熟悉~ 12'aabbcc'.replace(/b/g, '_')// 'aa__cc' 正则表达式毕竟不是那么方便和直观，ES2021 引入了replaceAll()方法，可以一次性替换所有匹配。(也就是说最新的浏览器已经开始支持这个方法，但是保险起见还是用老方法写吧，node端就随意了) 12'aabbcc'.replaceAll('b', '_')// 'aa__cc' 它的用法与replace()相同，返回一个新字符串，不会改变原字符串。 所以替换完了还得记得赋值。 1String.prototype.replaceAll(searchValue, replacement) 上面代码中，searchValue是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有g修饰符）。 (敲黑板！)如果searchValue是一个不带有g修饰符的正则表达式，replaceAll()会报错。这一点跟replace()不同。 12345// 不报错'aabbcc'.replace(/b/, '_')// 报错'aabbcc'.replaceAll(/b/, '_') 上面例子中，/b/不带有g修饰符，会导致replaceAll()报错。 关于replaceAll()的第二个参数#replaceAll()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。 $&amp;：匹配的子字符串。 $` ：匹配结果前面的文本。 $’：匹配结果后面的文本。 $n：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则表达式。 $$：指代美元符号$。下面是一些例子。 需要花心思消化下，但是能用到就会觉得很牛逼~(前提是ES2021….)123456789101112131415161718192021222324// $&amp; 表示匹配的字符串，即`b`本身// 所以返回结果与原字符串一致'abbc'.replaceAll('b', '$&amp;')// 'abbc'// $` 表示匹配结果之前的字符串// 对于第一个`b`，$` 指代`a`// 对于第二个`b`，$` 指代`ab`'abbc'.replaceAll('b', '$`')// 'aaabc'// $' 表示匹配结果之后的字符串// 对于第一个`b`，$' 指代`bc`// 对于第二个`b`，$' 指代`c`'abbc'.replaceAll('b', `$'`)// 'abccc'// $1 表示正则表达式的第一个组匹配，指代`ab`// $2 表示正则表达式的第二个组匹配，指代`bc`'abbc'.replaceAll(/(ab)(bc)/g, '$2$1')// 'bcab'// $$ 指代 $'abc'.replaceAll('b', '$$') 更厉害的是 这个第二参数还可以是函数！！！！replaceAll()的第二个参数replacement除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数searchValue匹配的文本。12'aabbcc'.replaceAll('b', () =&gt; '_')// 'aa__cc' 上面例子中，replaceAll()的第二个参数是一个函数，该函数的返回值会替换掉所有b的匹配。这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。(要是这个能用…语法不指明数组大小的黑魔法就很愉快了，可惜)此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。123456789const str = '123abc456';const regex = /(\\d+)([a-z]+)(\\d+)/g;function replacer(match, p1, p2, p3, offset, string) { return [p1, p2, p3].join(' - ');}str.replaceAll(regex, replacer)// 123 - abc - 456 上面例子中，正则表达式有三个组匹配，所以replacer()函数的第一个参数match是捕捉到的匹配内容（即字符串123abc456），后面三个参数p1、p2、p3则依次为三个组匹配。 PS#表示字符串的6中方法#123456'z''\\z' === 'z' // true'\\172' === 'z' // true'\\x7A' === 'z' // true'\\u007A' === 'z' // true'\\u{7A}' === 'z' // true","link":"/2021/03/11/ES6%E7%AC%94%E8%AE%B03-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%93%E5%B1%95%E4%B8%8E%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"},{"title":"ES6笔记5-数值的拓展","text":"比较基本，没有特别需要注意的点。mark BigInt 二进制与八进制 Number.isFinite(), Number.isNaN() Number.parseInt(), Number.parseFloat() Number.isInteger() Number.EPSILON 安全整数和 Number.isSafeInteger() Math 对象的扩展 1. Math.trunc() 2. Math.sign 3. Math.cbrt() 4. Math.clz32() 5. Math.imul 6. Math.fround() 7. Math.hypot() 8. 对数方法 1. Math.expm1() 2. Math.log1p() 3. Math.log10() 4. Math.log2() 9. 双曲函数方法 指数运算符 BigInt 二进制与八进制# 这个是英文的简写，B=BIN，八进制Octal，缩写OCT或O ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。=&gt; 要养成0o的好习惯，避免在严格模式下闹笑话 12345678910// 非严格模式(function(){ console.log(0o11 === 011);})() // true// 严格模式(function(){ 'use strict'; console.log(0o11 === 011);})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode. 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 12Number('0b111') // 7Number('0o10') // 8 Number.isFinite(), Number.isNaN()#ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false 注意，如果参数类型不是数值，Number.isFinite一律返回false。 12345678Number.isNaN()用来检查一个值是否为NaN。Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true' / 0) // trueNumber.isNaN('true' / 'true') // true 如果参数类型不是NaN，Number.isNaN一律返回false。它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 12345678910isFinite(25) // trueisFinite(&quot;25&quot;) // trueNumber.isFinite(25) // trueNumber.isFinite(&quot;25&quot;) // falseisNaN(NaN) // trueisNaN(&quot;NaN&quot;) // trueNumber.isNaN(NaN) // trueNumber.isNaN(&quot;NaN&quot;) // falseNumber.isNaN(1) // false Number.parseInt(), Number.parseFloat()#ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true Number.isInteger()#用来判断一个数值是否为整数。 12Number.isInteger(25) // trueNumber.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 12Number.isInteger(25) // trueNumber.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。 1234Number.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger('15') // falseNumber.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 1Number.isInteger(3.0000000000000002) // true 上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。 12Number.isInteger(5E-324) // falseNumber.isInteger(5E-325) // true 上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。 Number.EPSILON#ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 123456Number.EPSILON === Math.pow(2, -52)// trueNumber.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// &quot;0.00000000000000022204&quot; Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// '0.00000000000000005551' 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。 10.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 125.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)// true 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。 123456789function withinErrorMargin (left, right) { return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);}0.1 + 0.2 === 0.3 // falsewithinErrorMargin(0.1 + 0.2, 0.3) // true1.1 + 1.3 === 2.4 // falsewithinErrorMargin(1.1 + 1.3, 2.4) // true 上面的代码为浮点数运算，部署了一个误差检查函数。 安全整数和 Number.isSafeInteger()#JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1// true 上面代码中，超出 2 的 53 次方之后，一个数就不精确了。 ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true 上面代码中，可以看到 JavaScript 能够精确表示的极限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 123456789101112131415Number.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false 这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。 123456Number.isSafeInteger = function (n) { return (typeof n === 'number' &amp;&amp; Math.round(n) === n &amp;&amp; Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp; n &lt;= Number.MAX_SAFE_INTEGER);} 实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。 123456789Number.isSafeInteger(9007199254740993)// falseNumber.isSafeInteger(990)// trueNumber.isSafeInteger(9007199254740993 - 990)// true9007199254740993 - 990// 返回结果 9007199254740002// 正确答案应该是 9007199254740003 上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。 129007199254740993 === 9007199254740992// true 所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。 123456789101112131415function trusty (left, right, result) { if ( Number.isSafeInteger(left) &amp;&amp; Number.isSafeInteger(right) &amp;&amp; Number.isSafeInteger(result) ) { return result; } throw new RangeError('Operation cannot be trusted!');}trusty(9007199254740993, 990, 9007199254740993 - 990)// RangeError: Operation cannot be trusted!trusty(1, 2, 3) Math 对象的扩展#1. Math.trunc()#Math.trunc方法用于去除一个数的小数部分，返回整数部分。 12345Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 1234Math.trunc('123.456') // 123Math.trunc(true) //1Math.trunc(false) // 0Math.trunc(null) // 0 对于空值和无法截取整数的值，返回NaN。 1234Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaNMath.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.trunc = Math.trunc || function(x) { return x &lt; 0 ? Math.ceil(x) : Math.floor(x);}; 2. Math.sign#用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他值，返回NaN。12345Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。12345678Math.sign('') // 0Math.sign(true) // +1Math.sign(false) // 0Math.sign(null) // 0Math.sign('9') // +1Math.sign('foo') // NaNMath.sign() // NaNMath.sign(undefined) // NaN =&gt; 只有在入参为空、undefined、无法转化为数值的字符串时返回NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 1234567Math.sign = Math.sign || function(x) { x = +x; // convert to a number if (x === 0 || isNaN(x)) { return x; } return x &gt; 0 ? 1 : -1;}; 3. Math.cbrt()#用于计算一个数的立方根。 1234Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948732 对于非数值，Math.cbrt()方法内部也是先使用Number()方法将其转为数值。 12Math.cbrt('8') // 2Math.cbrt('hello') // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 1234Math.cbrt = Math.cbrt || function(x) { var y = Math.pow(Math.abs(x), 1/3); return x &lt; 0 ? -y : y;}; 4. Math.clz32()#Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2 上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。左移运算符（&lt;&lt;）与Math.clz32方法直接相关。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1 &lt;&lt; 1) // 30Math.clz32(1 &lt;&lt; 2) // 29Math.clz32(1 &lt;&lt; 29) // 2 对于小数，Math.clz32方法只考虑整数部分。 12Math.clz32(3.2) // 30Math.clz32(3.9) // 30 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。 12345678Math.clz32() // 32Math.clz32(NaN) // 32Math.clz32(Infinity) // 32Math.clz32(null) // 32Math.clz32('foo') // 32Math.clz32([]) // 32Math.clz32({}) // 32Math.clz32(true) // 31 5. Math.imul#返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。 123Math.imul(2, 4) // 8Math.imul(-1, 8) // -8Math.imul(-2, -2) // 4 如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。 1(0x7fffffff * 0x7fffffff)|0 // 0 上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。 1Math.imul(0x7fffffff, 0x7fffffff) // 1 6. Math.fround()#Math.fround方法返回一个数的32位单精度浮点数形式。对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -2^24 至 2^24 之间的整数（不含两个端点），返回结果与参数本身一致。 123Math.fround(0) // 0Math.fround(1) // 1Math.fround(2 ** 24 - 1) // 16777215 如果参数的绝对值大于 224，返回的结果便开始丢失精度。 12Math.fround(2 ** 24) // 16777216Math.fround(2 ** 24 + 1) // 16777216 Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。 12345678// 未丢失有效精度Math.fround(1.125) // 1.125Math.fround(7.25) // 7.25// 丢失精度Math.fround(0.3) // 0.30000001192092896Math.fround(0.7) // 0.699999988079071Math.fround(1.0000000123) // 1 对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。 12345678Math.fround(NaN) // NaNMath.fround(Infinity) // InfinityMath.fround('5') // 5Math.fround(true) // 1Math.fround(null) // 0Math.fround([]) // 0Math.fround({}) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.fround = Math.fround || function (x) { return new Float32Array([x])[0];}; 7. Math.hypot()#Math.hypot方法返回所有参数的平方和的平方根。 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 上面代码中，3 的平方加上 4 的平方，等于 5 的平方。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。 8. 对数方法#ES6 新增了 4 个对数相关方法。 1. Math.expm1()#Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。 123Math.expm1(-1) // -0.6321205588285577Math.expm1(0) // 0Math.expm1(1) // 1.718281828459045 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.expm1 = Math.expm1 || function(x) { return Math.exp(x) - 1;}; 2. Math.log1p()#Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 1234Math.log1p(1) // 0.6931471805599453Math.log1p(0) // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log1p = Math.log1p || function(x) { return Math.log(1 + x);}; 3. Math.log10()#Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。 12345Math.log10(2) // 0.3010299956639812Math.log10(1) // 0Math.log10(0) // -InfinityMath.log10(-2) // NaNMath.log10(100000) // 5 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log10 = Math.log10 || function(x) { return Math.log(x) / Math.LN10;}; 4. Math.log2()#Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。 1234567Math.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log2 = Math.log2 || function(x) { return Math.log(x) / Math.LN2;}; 9. 双曲函数方法#ES6 新增了 6 个双曲函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 指数运算符#ES2016 新增了一个指数运算符（**）。 122 ** 2 // 42 ** 3 // 8 这个运算符的一个特点是右结合，而不是常见的左结合。多个指数运算符连用时，是从最右边开始计算的。 123// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512 上面代码中，首先计算的是第二个指数运算符，而不是第一个。指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 1234567let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b; BigInt#JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。 12345// 超过 53 个二进制位的数值，无法保持精度Math.pow(2, 53) === Math.pow(2, 53) + 1 // true// 超过 2 的 1024 次方的数值，无法表示Math.pow(2, 1024) // Infinity ES2020 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。 12345678const a = 2172141653n;const b = 15346349309n;// BigInt 可以保持精度a * b // 33334444555566667777n// 普通整数无法保持精度Number(a) * Number(b) // 33334444555566670000 为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n。 1234567891011121314151617181920212223242526272829303132331234 // 普通整数1234n // BigInt// BigInt 的运算1n + 2n // 3n//BigInt 同样可以使用各种进制表示，都要加上后缀n。0b1101n // 二进制0o777n // 八进制0xFFn // 十六进制//BigInt 与普通整数是两种值，它们之间并不相等。42n === 42 // false//typeof运算符对于 BigInt 类型的数据返回bigint。typeof 123n // 'bigint'//BigInt 可以使用负号（-），但是不能使用正号（+），因为会与 asm.js 冲突。-42n // 正确+42n // 报错//JavaScript 以前不能计算70的阶乘（即70!），因为超出了可以表示的精度。let p = 1;for (let i = 1; i &lt;= 70; i++) { p *= i;}console.log(p); // 1.197857166996989e+100//现在支持大整数了，就可以算了，浏览器的开发者工具运行下面代码，就OK。let p = 1n;for (let i = 1n; i &lt;= 70n; i++) { p *= i;}console.log(p); // 11978571...00000000n JavaScript 原生提供BigInt对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt。 1234567891011121314BigInt(123) // 123nBigInt('123') // 123nBigInt(false) // 0nBigInt(true) // 1n//BigInt()构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。new BigInt() // TypeErrorBigInt(undefined) //TypeErrorBigInt(null) // TypeErrorBigInt('123n') // SyntaxErrorBigInt('abc') // SyntaxError//上面代码中，尤其值得注意字符串123n无法解析成 Number 类型，所以会报错。BigInt(1.5) // RangeErrorBigInt('1.5') // SyntaxError","link":"/2021/03/11/ES6%E7%AC%94%E8%AE%B05-%E6%95%B0%E5%80%BC%E7%9A%84%E6%8B%93%E5%B1%95/"},{"title":"ES6笔记4-正则的拓展","text":"mark: 正则的后行断言 RegExp 构造函数 =&gt; 在ES6中的调整 字符串的正则方法 =&gt; 内部调用指向 RegExp u 修饰符 =&gt; Unicode 模式 1. 点字符 . 2. Unicode 字符表示法 =&gt; 识别大括号表示法 3. 量词 =&gt; 正确获取个数 4. 预定义模式 5. i 修饰符 =&gt; 识别非规范的字符 6. 转义 RegExp.prototype.unicode 属性 y 修饰符 lastIndex 属性 从字符串提取 token（词元） RegExp.prototype.sticky 属性 RegExp.prototype.flags 属性 s 修饰符：dotAll 模式 =&gt; 即点（dot）代表一切字符 后行断言 Unicode 属性类 具名组匹配 1. 解构赋值和替换 引用 正则匹配索引 =&gt; 还在第三阶段，虽然还没成为正式规范，但也是迟早的事情 String.prototype.matchAll() RegExp 构造函数 =&gt; 在ES6中的调整#在 ES5 中，RegExp构造函数的参数有两种情况。 123456789101112//第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。var regex = new RegExp('xyz', 'i');// 等价于var regex = /xyz/i;//第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i;//但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。var regex = new RegExp(/xyz/, 'i');//Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6中，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/ig, 'i').flags// &quot;i&quot; 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 字符串的正则方法 =&gt; 内部调用指向 RegExp#ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符 =&gt; Unicode 模式#12/^\\uD83D/u.test('\\uD83D\\uDC2A') // false/^\\uD83D/.test('\\uD83D\\uDC2A') // true 上面代码中，\\uD83D\\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。 该模式下部分正则表达式的行为也会有所改变 1. 点字符 .#点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 123var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 2. Unicode 字符表示法 =&gt; 识别大括号表示法#ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 123/\\u{61}/.test('a') // false/\\u{61}/u.test('a') // true/\\u{20BB7}/u.test('𠮷') // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\\u{61}这种表示法，只会认为这匹配 61 个连续的u。 3. 量词 =&gt; 正确获取个数#使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 1234/a{2}/.test('aa') // true/a{2}/u.test('aa') // true/𠮷{2}/.test('𠮷𠮷') // false/𠮷{2}/u.test('𠮷𠮷') // true 4. 预定义模式#u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。 12/^\\S$/.test('𠮷') // false/^\\S$/u.test('𠮷') // true 上面代码的\\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。利用这一点，可以写出一个正确返回字符串长度的函数。 1234567function codePointLength(text) { var result = text.match(/[\\s\\S]/gu); return result ? result.length : 0;}var s = '𠮷𠮷';s.length // 4codePointLength(s) // 2 5. i 修饰符 =&gt; 识别非规范的字符#有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。 12/[a-z]/i.test('\\u212A') // false/[a-z]/iu.test('\\u212A') // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 6. 转义#mark 没理解其用意没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义,）无效，而在u模式会报错。 12/\\,/ // /\\,//\\,/u // 报错 上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。 RegExp.prototype.unicode 属性#正则实例对象新增unicode属性，表示是否设置了u修饰符。 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode // falser2.unicode // true 上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。 y 修饰符#除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 =&gt; 也就是说， 剩余的字符串的0开始匹配 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // [&quot;aaa&quot;]r2.exec(s) // [&quot;aaa&quot;]r1.exec(s) // [&quot;aa&quot;]r2.exec(s) // null 上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始(即_aa_a的第一个_开始匹配，巧了，正好不是字符a)，所以返回null。 lastIndex 属性#1234567891011const REGEX = /a/g;// 指定从2号位置（y）开始匹配REGEX.lastIndex = 2;// 匹配成功const match = REGEX.exec('xaya');// 在3号位置匹配成功match.index // 3// 下一次匹配从4号位开始REGEX.lastIndex // 4// 4号位开始匹配失败REGEX.exec('xaya') // null 上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。 y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。 1234567891011const REGEX = /a/y;// 指定从2号位置开始匹配REGEX.lastIndex = 2;// 不是粘连，匹配失败REGEX.exec('xaya') // null// 指定从3号位置开始匹配REGEX.lastIndex = 3;// 3号位置是粘连，匹配成功const match = REGEX.exec('xaya');match.index // 3REGEX.lastIndex // 4 实际上，y修饰符号隐含了头部匹配的标志^。 y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 12const REGEX = /a/gy;'aaxa'.replace(REGEX, '-') // '--xa' 上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 12'a1a2a3'.match(/a\\d/y) // [&quot;a1&quot;]'a1a2a3'.match(/a\\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;] 从字符串提取 token（词元）#y修饰符确保了匹配之间不会有漏掉的字符。 12345678910111213141516const TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y;const TOKEN_G = /\\s*(\\+|[0-9]+)\\s*/g;tokenize(TOKEN_Y, '3 + 4')// [ '3', '+', '4' ]tokenize(TOKEN_G, '3 + 4')// [ '3', '+', '4' ]function tokenize(TOKEN_REGEX, str) { let result = []; let match; while (match = TOKEN_REGEX.exec(str)) { result.push(match[1]); } return result;} 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。 1234tokenize(TOKEN_Y, '3x + 4')// [ '3' ]tokenize(TOKEN_G, '3x + 4')// [ '3', '+', '4' ] 上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。 RegExp.prototype.sticky 属性#与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 12var r = /hello\\d/y;r.sticky // true RegExp.prototype.flags 属性#ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 123456789// ES5 的 source 属性// 返回正则表达式的正文/abc/ig.source// &quot;abc&quot;// ES6 的 flags 属性// 返回正则表达式的修饰符/abc/ig.flags// 'gi' s 修饰符：dotAll 模式 =&gt; 即点（dot）代表一切字符#正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator）123/foo.bar/.test('foo\\nbar')// false//上面代码中，因为.不匹配\\n，所以正则表达式返回false。 很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。12/foo[^]bar/.test('foo\\nbar')// true 这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。1/foo.bar/s.test('foo\\nbar') // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。1234567const re = /foo.bar/s;// 另一种写法// const re = new RegExp('foo.bar', 's');re.test('foo\\nbar') // truere.dotAll // truere.flags // 's' /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 后行断言#mark 后续研究下JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。 “先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。 12/\\d+(?=%)/.exec('100% of US presidents have been male') // [&quot;100&quot;]/\\d+(?!%)/.exec('that’s all 44 of them') // [&quot;44&quot;] 上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。 “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=$)\\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!$)\\d+/。 12/(?&lt;=\\$)\\d+/.exec('Benjamin Franklin is on the $100 bill') // [&quot;100&quot;]/(?&lt;!\\$)\\d+/.exec('it’s is worth about €90') // [&quot;90&quot;] 上面的例子中，“后行断言”的括号之中的部分（(?&lt;=$)），也是不计入返回结果。 下面的例子是使用后行断言进行字符串替换。 123const RE_DOLLAR_PREFIX = /(?&lt;=\\$)foo/g;'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar');// '$bar %foo foo' 上面代码中，只有在美元符号后面的foo才会被替换。 “后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。 首先，后行断言的组匹配，与正常情况下结果是不一样的。 12/(?&lt;=(\\d+)(\\d+))$/.exec('1053') // [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]/^(\\d+)(\\d+)$/.exec('1053') // [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。 其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 12/(?&lt;=(o)d\\1)r/.exec('hodor') // null/(?&lt;=\\1d(o))r/.exec('hodor') // [&quot;r&quot;, &quot;o&quot;] 上面代码中，如果后行断言的反斜杠引用（\\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。 Unicode 属性类#ES2018 引入了一种新的类的写法\\p{…}和\\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 12const regexGreekSymbol = /\\p{Script=Greek}/u;regexGreekSymbol.test('π') // true 上面代码中，\\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。Unicode 属性类要指定属性名和属性值。 1\\p{UnicodePropertyName=UnicodePropertyValue} 对于某些属性，可以只写属性名，或者只写属性值。 12\\p{UnicodePropertyName}\\p{UnicodePropertyValue} \\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\P会报错，ECMAScript 预留了这两个类。由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。 12const regex = /^\\p{Decimal_Number}+$/u;regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。\\p{Number}甚至能匹配罗马数字。 12345// 匹配所有数字const regex = /^\\p{Number}+$/u;regex.test('²³¹¼½¾') // trueregex.test('㉛㉜㉝') // trueregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true 下面是其他一些例子。 1234567891011// 匹配所有空格\\p{White_Space}// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w[\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W[^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}]// 匹配 Emoji/\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\\p{Block=Arrows}+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 具名组匹配#ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 12345const RE_DATE = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // &quot;1999&quot;const month = matchObj.groups.month; // &quot;12&quot;const day = matchObj.groups.day; // &quot;31&quot; 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。如果具名组没有匹配，那么对应的groups对象属性会是undefined。 12345const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;const matchObj = RE_OPT_A.exec('');matchObj.groups.as // undefined'as' in matchObj.groups // true 上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。 1. 解构赋值和替换#有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 123let {groups: {one, two}} = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec('foo:bar');one // footwo // bar 字符串替换时，使用$&lt;组名&gt;引用具名组。 1234let re = /(?&lt;year&gt;\\d{4})-(?&lt;month&gt;\\d{2})-(?&lt;day&gt;\\d{2})/u;'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')// '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。replace方法的第二个参数也可以是函数，该函数的参数序列如下。 123456789101112'2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 {year, month, day} ) =&gt; { let {day, month, year} = groups; return `${day}/${month}/${year}`;}); 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。 引用#如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k&lt;组名&gt;的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;$/;RE_TWICE.test('abc!abc') // trueRE_TWICE.test('abc!ab') // false 数字引用（\\1）依然有效。 =&gt; 可以理解为 对应的第几个匹配项 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\1$/; // \\1 指的是&lt;word&gt;匹配到的文本RE_TWICE.test('abc!abc') // trueRE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 12345678910const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;!\\1$/;RE_TWICE.test('abc!abc!abc') // trueRE_TWICE.test('abc!abc!ab') // false/^(?&lt;word&gt;[a-z]+)!(?&lt;number&gt;[0-9]+)!\\2$/.test('abc!3!abc')//false/^(?&lt;word&gt;[a-z]+)!(?&lt;number&gt;[0-9]+)!\\2$/.test('abc!3!4')//false/^(?&lt;word&gt;[a-z]+)!(?&lt;number&gt;[0-9]+)!\\2$/.test('abc!3!3')//true 正则匹配索引 =&gt; 还在第三阶段，虽然还没成为正式规范，但也是迟早的事情#正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的exec()方法，返回结果有一个index属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。 现在有一个第三阶段提案，为exec()方法的返回结果加上indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置 123456const text = 'zabbcdef';const re = /ab/;const result = re.exec(text);result.index // 1result.indices // [ [1, 3] ] 12345const text = 'zabbcdef';const re = /ab+(cd)/;const result = re.exec(text);result.indices // [ [ 1, 6 ], [ 4, 6 ] ] 上面例子中，正则表达式包含一个组匹配，那么indices属性数组就有两个成员，第一个成员是整个匹配结果（abbcd）的开始位置和结束位置，第二个成员是组匹配（cd）的开始位置和结束位置。 String.prototype.matchAll()#如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 123456789101112131415var regex = /t(e)(st(\\d?))/g;var string = 'test1test2test3';var matches = [];var match;while (match = regex.exec(string)) { matches.push(match);}matches// [// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]// ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 ES2020增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 123456789const string = 'test1test2test3';const regex = /t(e)(st(\\d?))/g;for (const match of string.matchAll(regex)) { console.log(match);}// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;] 由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用…运算符和Array.from()方法就可以了。 1234// 转为数组的方法一[...string.matchAll(regex)]// 转为数组的方法二Array.from(string.matchAll(regex))","link":"/2021/03/11/ES6%E7%AC%94%E8%AE%B04-%E6%AD%A3%E5%88%99%E7%9A%84%E6%8B%93%E5%B1%95/"},{"title":"ES6笔记6-函数的拓展","text":"这一章用的到比较多~mark: 函数的尾调用、 递归尾调用优化、箭头函数与this 函数参数的默认值 与解构赋值一起设置默认值 参数默认值的位置 =&gt; 除了尾部参数不能省略，建议直接赋值undefined传入 默认值对 函数的 length 属性的影响 =&gt; 失真 默认值的作用域 使用函数作为默认值 rest 参数 =&gt; 尾参用… 严格模式 name 属性 箭头函数 使用注意点 请问下面的代码之中有几个this？ 不适用场合 嵌套使用 =&gt; 可读性会下降 尾调用优化 什么是尾调用 why 尾调用优化 尾递归 递归函数的改写 =&gt; 这下知道自己为啥leetcode上老是内存溢出了 尾递归优化的实现 =&gt; 蹦床函数 函数参数的尾逗号 Function.prototype.toString() catch 命令的参数省略 函数参数的默认值#与解构赋值一起设置默认值#请问下面两种写法有什么差别？ 123456789// 写法一function m1({x = 0, y = 0} = {}) { return [x, y];}// 写法二function m2({x, y} = { x: 0, y: 0 }) { return [x, y];} 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值； 调用函数时如果没有参数的话，就直接使用等号右边的{} =&gt; {}中的对象x,y都是严格等于undefind =&gt; 默认传参为{x:0, y:0} 写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 只有在调用函数不传参时候，等号右边的{x:0, y:0}才会生效 =&gt; 等号左边的{x,y} 就是普通的解构赋值 123456789101112131415161718// 函数没有参数的情况m1() // [0, 0] , 等号右边{}生效=&gt; 解构赋值的默认值生效 =&gt; x=0,y=0m2() // [0, 0] , 等号右边的{x:0, y:0}生效// x 和 y 都有值的情况m1({x: 3, y: 8}) // [3, 8]m2({x: 3, y: 8}) // [3, 8]// x 有值，y 无值的情况m1({x: 3}) // [3, 0]m2({x: 3}) // [3, undefined]// x 和 y 都无值的情况m1({}) // [0, 0];m2({}) // [undefined, undefined]m1({z: 3}) // [0, 0]m2({z: 3}) // [undefined, undefined] 参数默认值的位置 =&gt; 除了尾部参数不能省略，建议直接赋值undefined传入#通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) { return [x, y];}f() // [1, undefined]f(2) // [2, undefined]f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) { return [x, y, z];}f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 默认值对 函数的 length 属性的影响 =&gt; 失真#指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123456789(function (a) {}).length // 1(function (a = 5) {}).length // 0(function (a, b, c = 5) {}).length // 2``上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。```js(function(...args) {}).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) {}).length // 0(function (a, b = 1, c) {}).length // 1 默认值的作用域#一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567var x = 1;function f(x, y = x) { console.log(y);}f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 再看下面的例子。 12345678let x = 1;function f(y = x) { let x = 2; console.log(y);}f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 123456789101112131415function f(y = x) { let x = 2; console.log(y);}f() // ReferenceError: x is not defined//下面这样写，也会报错。var x = 1;function foo(x = x) { // ...}foo() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 =&gt; 等号右边的x被死区锁定，必须是预先定义的、且不同名的。 使用函数作为默认值#12345678910function throwIfMissing() { throw new Error('Missing parameter');}function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided;}foo()// Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。 rest 参数 =&gt; 尾参用…#ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数 1234567// arguments变量的写法function sortNumbers() { return Array.prototype.slice.call(arguments).sort();}// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。 严格模式#ES2016规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122// 报错function doSomething(a, b = a) { 'use strict'; // code}// 报错const doSomething = function ({a, b}) { 'use strict'; // code};// 报错const doSomething = (...a) =&gt; { 'use strict'; // code};const obj = { // 报错 doSomething({a, b}) { 'use strict'; // code }}; name 属性#123456789101112131415161718192021222324function foo() {}foo.name // &quot;foo&quot;//如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。var f = function () {};// ES5f.name // &quot;&quot;// ES6f.name // &quot;f&quot;//如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。const bar = function baz() {};// ES5bar.name // &quot;baz&quot;// ES6bar.name // &quot;baz&quot;//Function构造函数返回的函数实例，name属性的值为anonymous。(new Function).name // &quot;anonymous&quot;//bind返回的函数，name属性值会加上bound前缀。function foo() {};foo.bind({}).name // &quot;bound foo&quot;(function(){}).bind({}).name // &quot;bound &quot; 箭头函数#如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 1let fn = () =&gt; void doesNotReturn(); 使用注意点#箭头函数有几个使用注意点。 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的 123456789function foo() { setTimeout(() =&gt; { console.log('id:', this.id); }, 100);}var id = 21;foo.call({ id: 42 });// id: 42 上面代码中，setTimeout()的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以打印出来的是42。箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () { this.s2++; }, 1000);}var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。 123456789101112var handler = { id: '123456', init: function() { document.addEventListener('click', event =&gt; this.doSomething(event.type), false); }, doSomething: function(type) { console.log('Handling ' + type + ' for ' + this.id); }}; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 请问下面的代码之中有几个this？#123456789101112131415function foo() { return () =&gt; { return () =&gt; { return () =&gt; { console.log('id:', this.id); }; }; };}var f = foo.call({id: 1});var t1 = f.call({id: 2})()(); // id: 1var t2 = f().call({id: 3})(); // id: 1var t3 = f()().call({id: 4}); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() { setTimeout(() =&gt; { console.log('args:', arguments); }, 100);}foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() { return [ (() =&gt; this.x).bind({ x: 'inner' })() ];}).call({ x: 'outer' });// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 不适用场合#由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。 第一个场合是定义对象的方法，且该方法内部包括this。 =&gt; 对象方法不适合使用箭头函数 123456const cat = { lives: 9, jumps: () =&gt; { this.lives--; }} 上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致jumps箭头函数定义时的作用域就是全局作用域。 再看一个例子。 12345678globalThis.s = 21;const obj = { s: 42, m: () =&gt; console.log(this.s)};obj.m() // 21 上面例子中，obj.m()使用箭头函数定义。JavaScript 引擎的处理方法是，先在全局空间生成这个箭头函数，然后赋值给obj.m，这导致箭头函数内部的this指向全局对象，所以obj.m()输出的是全局空间的21，而不是对象内部的42。上面的代码实际上等同于下面的代码。 123456789globalThis.s = 21;globalThis.m = () =&gt; console.log(this.s);const obj = { s: 42, m: globalThis.m};obj.m() // 21 由于上面这个原因，对象的属性建议使用传统的写法定义，不要用箭头函数定义。 第二个场合是需要动态this的时候，也不应使用箭头函数。 1234var button = document.getElementById('press');button.addEventListener('click', () =&gt; { this.classList.toggle('on');}); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。=&gt; 除非写这个回调压根就不想要用到按钮对象 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 嵌套使用 =&gt; 可读性会下降#123456789const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。 12345const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;mult2(plus1(5))// 12 尾调用优化#什么是尾调用#尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x){ return g(x);} 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 1234567891011121314151617181920212223242526272829// 情况一 调用函数g之后，还有赋值操作，所以不属于尾调用function f(x){ let y = g(x); return y;}// 情况二 属于调用后还有操作function f(x){ return g(x) + 1;}// 情况三function f(x){ g(x);}//等同于下面的代码function f(x){ g(x); return undefined;}//尾调用不一定出现在函数尾部，只要是最后一步操作即可。function f(x) { if (x &gt; 0) { return m(x) } return n(x);}//上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 why 尾调用优化#我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() { let m = 1; let n = 2; return g(m + n);}f();// 等同于function f() { return g(3);}f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a){ var one = 1; function inner(b){ return b + one; } return inner(a);} 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。 尾递归#函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 12345function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1);}factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 12345function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5, 1) // 120 非尾递归的 Fibonacci 数列实现如下。 1234567891011121314151617181920function Fibonacci (n) { if ( n &lt;= 1 ) {return 1}; return Fibonacci(n - 1) + Fibonacci(n - 2);}Fibonacci(10) // 89Fibonacci(100) // 超时Fibonacci(500) // 超时//尾递归优化过的 Fibonacci 数列实现如下。function Fibonacci2 (n , ac1 = 1 , ac2 = 1) { if( n &lt;= 1 ) {return ac2}; return Fibonacci2 (n - 1, ac2, ac1 + ac2);}Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。 递归函数的改写 =&gt; 这下知道自己为啥leetcode上老是内存溢出了#尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 12345678910function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}function factorial(n) { return tailFactorial(n, 1);}factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 1234567891011121314function currying(fn, n) { return function (m) { return fn.call(this, m, n); };}function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total);}const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。 第二种方法就简单多了，就是采用 ES6 的函数默认值。 123456function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total);}factorial(5) // 120 上面代码中，参数total有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 尾递归优化的实现 =&gt; 蹦床函数#函数参数的尾逗号#ES2017 123456789function clownsEverywhere( param1, param2,) { /* ... */ }clownsEverywhere( 'foo', 'bar',); Function.prototype.toString()#ES2019 对函数实例的toString()方法做出了修改。toString()方法返回函数代码本身，以前会省略注释和空格。 123function /* foo comment */ foo () {}foo.toString()// function foo() {} 上面代码中，函数foo的原始代码包含注释，函数名foo和圆括号之间有空格，但是toString()方法都把它们省略了。修改后的toString()方法，明确要求返回一模一样的原始代码。 123function /* foo comment */ foo () {}foo.toString()// &quot;function /* foo comment */ foo () {}&quot; catch 命令的参数省略#ES2019 允许catch语句省略参数 =&gt; 如果用不到error的话 12345try { // ...} catch { // ...}","link":"/2021/03/15/ES6%E7%AC%94%E8%AE%B06-%E5%87%BD%E6%95%B0%E7%9A%84%E6%8B%93%E5%B1%95/"},{"title":"ES6笔记7-数组的拓展","text":"函数和数组应该算是平时用的最多的了. mark# [].copyWithin.call({length: 5, 3: 1}, 0, 3) =&gt; {0: 1, 3: 1, length: 5} ? 扩展运算符 基本使用 应用 赋值数组 =&gt; 浅拷贝 合并数组 与解构赋值结合 字符串 实现了 Iterator 接口的对象 =&gt; 转数组 Map 和 Set 结构(自带Iterator接口)，Generator 函数(自带遍历器对象) Array.from() 与…扩展符的差别 第二个参数 =&gt; 类似map 应用 Array.of() =&gt; 将传参变为数组 数组实例的 copyWithin() 数组实例的 find() 和 findIndex() 数组实例的 fill() 浅拷贝 数组实例的 entries()，keys() 和 values() 数组实例的 includes() 数组实例的 flat()，flatMap() 数组的空位 =&gt; 建议避免出现空位 Array.prototype.sort() 的排序稳定性 进一步了解sort排序 先转为字符串，再比较UTF-16代码单元值 参数 compareFunction 使用映射改善排序 =&gt; 又发现一个可以减少算法中内存使用的地方 扩展运算符#基本使用#扩展运算符与正常的函数参数可以结合使用，非常灵活。 =&gt; 前提是知道…args中有多少位参数 123456789function f(v, w, x, y, z) { }const args = [0, 1];f(-1, ...args, 2, ...[3]);扩展运算符后面还可以放置表达式。const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b',]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 12[...[], 1]// [1] 注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。 12345678(...[1, 2])// Uncaught SyntaxError: Unexpected numberconsole.log((...[1, 2]))// Uncaught SyntaxError: Unexpected numberconsole.log(...[1, 2])// 1 2 上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。 应用#赋值数组 =&gt; 浅拷贝#1234567891011121314//数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。const a1 = [1, 2];const a2 = a1;a2[0] = 2;a1 // [2, 2]//上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。//ES5 只能用变通方法来复制数组。const a1 = [1, 2];const a2 = a1.concat();a2[0] = 2;a1 // [1, 2]//上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。 扩展运算符提供了复制数组的简便写法。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二 =&gt; 看着有点反人类const [...a2] = a1; 上面的两种写法，a2都是a1的克隆。 合并数组#扩展运算符提供了数组合并的新写法。 1234567891011const arr1 = ['a', 'b'];const arr2 = ['c'];const arr3 = ['d', 'e'];// ES5 的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。 12345678const a1 = [{ foo: 1 }];const a2 = [{ bar: 2 }];const a3 = a1.concat(a2);const a4 = [...a1, ...a2];a3[0] === a1[0] // truea4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。 与解构赋值结合#扩展运算符可以与解构赋值结合起来，用于生成数组。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 下面是另外一些例子。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 字符串#扩展运算符还可以将字符串转为真正的数组。 12345[...'hello']// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]'x\\uD83D\\uDE80y'.length // 4[...'x\\uD83D\\uDE80y'].length // 3 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。 12345function length(str) { return [...str].length;}length('x\\uD83D\\uDE80y') // 3 凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。 1234567let str = 'x\\uD83D\\uDE80y';str.split('').reverse().join('')// 'y\\uDE80\\uD83Dx'[...str].reverse().join('')// 'y\\uD83D\\uDE80x' 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 实现了 Iterator 接口的对象 =&gt; 转数组#任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 12345678910111213let nodeList = document.querySelectorAll('div');let array = [...nodeList];//上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。Number.prototype[Symbol.iterator] = function*() { let i = 0; let num = this.valueOf(); while (i &lt; num) { yield i++; }}console.log([...5]) // [0, 1, 2, 3, 4] 上面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。=&gt; 提前学习下Symbol和yield的用法，感觉会有很多妙用 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 123456789let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3};// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 Map 和 Set 结构(自带Iterator接口)，Generator 函数(自带遍历器对象)#扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567const go = function*(){ yield 1; yield 2; yield 3;};[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。 12const obj = {a: 1, b: 2};let arr = [...obj]; // TypeError: Cannot spread non-iterable object Array.from()#Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。下面是一个类似数组的对象，Array.from将它转为真正的数组。 12345678910let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3};// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 12345678Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b']//如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。Array.from([1, 2, 3])// [1, 2, 3] 与…扩展符的差别#扩展运算符（…）也可以将某些数据结构转为数组。 123456// arguments对象function foo() { const args = [...arguments];}// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from({ length: 3 });// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 第二个参数 =&gt; 类似map#Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 应用#Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 12Array.from({ length: 2 }, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\\uFFFF的 Unicode 字符，算作两个字符的 bug。 123function countSymbols(string) { return Array.from(string).length;} Array.of() =&gt; 将传参变为数组#Array.of()方法用于将一组值，转换为数组。 12345678//ES6Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 1234//ES5Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array()方法没有参数、一个参数、三个参数时，返回的结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。 数组实例的 copyWithin()#数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 =&gt; 不包含这个点位的值 这三个参数都应该是数值，如果不是，会自动转为数值。 123456789101112131415161718192021222324252627[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5][1, 2, 3, 4, 5].copyWithin(0, 3, 3) // [1, 2, 3, 4, 5] =&gt; 啥也没发生// -2相当于3号位，即4，-1相当于4号位， 即5[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call({length: 5, 3: 1}, 0, 3)// {0: 1, 3: 1, length: 5}// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的 find() 和 findIndex()#数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于 0 的成员。 123[1, 5, 10, 15].find(function(value, index, arr) { return value &gt; 9;}) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 12345678910[1, 5, 10, 15].findIndex(function(value, index, arr) { return value &gt; 9;}) // 2//这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。function f(v){ return v &gt; this.age;}let person = {name: 'John', age: 20};[10, 12, 26, 15].find(f, person); // 26//上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。 另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 数组实例的 fill()#fill方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。fill方法还可以接受第二个和第三个参数，用于**指定填充的起始位置和结束位置(不含)**。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 浅拷贝#如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 123456789let arr = new Array(3).fill({name: &quot;Mike&quot;});arr[0].name = &quot;Ben&quot;;arr// [{name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 数组实例的 entries()，keys() 和 values()#ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对(键值对为数组结构[index, value])的遍历。 1234567891011121314151617for (let index of ['a', 'b'].keys()) { console.log(index);}// 0// 1for (let elem of ['a', 'b'].values()) { console.log(elem);}// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) { console.log(index, elem);}// 0 &quot;a&quot;// 1 &quot;b&quot; 如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组实例的 includes()#Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 =&gt; NaN 也可以哦 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 123if (arr.indexOf(el) !== -1) { // ...} indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。 12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 =&gt; some不能用来区分NaN 123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 数组实例的 flat()，flatMap()#数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 12[1, [2, [3]]].flat(Infinity)// [1, 2, 3] 如果原数组有空位，flat()方法会跳过空位。 12[1, 2, , 4, 5].flat()// [1, 2, 4, 5] **flatMap()**方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 =&gt; map + flat 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组。 123// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])// [[2], [4], [6], [8]] 上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个嵌套数组。flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。 123arr.flatMap(function callback(currentValue[, index[, array]]) { // ...}[, thisArg]) flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。 数组的空位 =&gt; 建议避免出现空位#数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 上面代码中，Array(3)返回一个具有 3 个空位的数组。注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false 上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。 ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。1234567891011121314151617181920212223// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// reduce方法[1,,2].reduce((x,y) =&gt; x+y) // 3// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // &quot;#a##&quot;// toString方法[,'a',undefined,null].toString() // &quot;,a,,&quot; ES6 则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 扩展运算符（…）也会将空位转为undefined。 copyWithin()会连空位一起拷贝。 fill()会将空位视为正常的数组位置。 for…of循环也会遍历空位。12345678910111213141516Array.from(['a',,'b'])// [ &quot;a&quot;, undefined, &quot;b&quot; ][...['a',,'b']]// [ &quot;a&quot;, undefined, &quot;b&quot; ][,'a','b',,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]new Array(3).fill('a') // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]let arr = [, ,];for (let i of arr) { console.log(1);}// 1// 1 上面代码中，数组arr有两个空位，for…of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。12345678910111213141516entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。// entries()[...[,'a'].entries()] // [[0,undefined], [1,&quot;a&quot;]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,&quot;a&quot;]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。 Array.prototype.sort() 的排序稳定性#排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。 1234567891011121314const arr = [ 'peach', 'straw', 'apple', 'spork'];const stableSorting = (s1, s2) =&gt; { if (s1[0] &lt; s2[0]) return -1; return 1;};arr.sort(stableSorting)// [&quot;apple&quot;, &quot;peach&quot;, &quot;straw&quot;, &quot;spork&quot;] 上面代码对数组arr按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法stableSorting是稳定排序。 1234567const unstableSorting = (s1, s2) =&gt; { if (s1[0] &lt;= s2[0]) return -1; //前面的代码是小于号，这边是小于等于 return 1;};arr.sort(unstableSorting)// [&quot;apple&quot;, &quot;peach&quot;, &quot;spork&quot;, &quot;straw&quot;] 上面代码中，排序结果是spork在straw前面，跟原始顺序相反，所以排序算法unstableSorting是不稳定的。 常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。 早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。 进一步了解sort排序#sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。 &lt;=源自官方文档 原地算法原地算法不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入的一种算法操作。 维基百科中的伪代码示例：假设要将具有 n 项内容的数组 a 翻转过来。一种看似简单的方法是创建一个大小相等的新数组，用适当的顺序填充副本，然后再删除： 12345function reverse(a[0..n-1]) allocate b[0..n-1] # 额外设定一个数组 for i from 0 to n-1 # 从 0 到 n-1 遍历数组 a b[n -1 - i] := a[i] return b 这种方法虽然简单，但是需要 O(n) 的额外空间以使数组 a 和 b 同时可用。此外，分配存储空间和释放存储空间通常是缓慢的操作。如果我们不再需要数组 a 的话，可使用原地算法，用它自己翻转的内容来覆盖掉原先的内容。这样，无论数组有多大，它都只需要辅助变量 i 和 tmp： 12345function reverse_in_place(a[0..n-1]) for i from 0 to floor((n-2)/2) tmp := a[i] a[i] := a[n − 1 − i] a[n − 1 − i] := tmp 这样既节省了存储器空间又加快了运算速度。 先转为字符串，再比较UTF-16代码单元值#123456789onst months = ['March', 'Jan', 'Feb', 'Dec'];months.sort();console.log(months);// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]const array1 = [1, 30, 4, 21, 100000];array1.sort();console.log(array1);// expected output: Array [1, 100000, 21, 30, 4] 参数 compareFunction#指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。=&gt; 又扯会稳定排序的问题 使用映射改善排序 =&gt; 又发现一个可以减少算法中内存使用的地方#compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。 1234567891011121314// 需要被排序的数组var list = ['Delta', 'alpha', 'CHARLIE', 'bravo'];// 对需要排序的数字和位置的临时存储var mapped = list.map(function(el, i) { return { index: i, value: el.toLowerCase() };})// 按照多个值排序数组mapped.sort(function(a, b) { return +(a.value &gt; b.value) || +(a.value === b.value) - 1;});// 根据索引得到排序的结果var result = mapped.map(function(el){ return list[el.index];});","link":"/2021/03/16/ES6%E7%AC%94%E8%AE%B07-%E6%95%B0%E7%BB%84%E7%9A%84%E6%8B%93%E5%B1%95/"},{"title":"ES笔记8-对象的扩展和新增方法","text":"关于对象的新特性也是实践中经常用到的.ES6新增： 链判断： a?.b || ‘XiaoMing’ Null判断： a ?? ‘studentA’ 属性的简洁表示法 属性名表达式 obj[‘key’] 方法的 name 属性 普通情况 get 与 set bind 与 Symbol 属性的可枚举性和遍历 属性的可枚举型 属性的遍历： 顺序(数值升序、字符串升序、symbol升序) 1. for…in 2. Object.keys(obj) 3. Object.getOwnPropertyNames(obj) 4. Object.getOwnPropertySymbols(obj) 5. Reflect.ownKeys(obj) super 关键字 对象的扩展运算符 解构赋值 扩展运算符 链判断运算符 判断对象/属性是否存在 判断对象方法是否存在，如果存在就立即执行的例子。 基本用法 注意点 1. 短路机制 2. delete 运算符 3. 括号的影响 4. 报错场合 5. 右侧不得为十进制数值 Null 判断运算符 优先级问题 属性的简洁表示法#ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。 12345const foo = 'bar';const baz = {foo};baz // {foo: &quot;bar&quot;}// 等同于const baz = {foo: foo}; 属性名表达式 obj[‘key’]#JavaScript 定义对象的属性，有两种方法。 1234// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。 1234var obj = { foo: true, abc: 123}; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 12345let propKey = 'foo';let obj = { [propKey]: true, ['a' + 'bc']: 123}; 下面是另一个例子。 12345678910let lastWord = 'last word';const a = { 'first word': 'hello', [lastWord]: 'world'};a['first word'] // &quot;hello&quot;a[lastWord] // &quot;world&quot;a['last word'] // &quot;world&quot; 表达式还可以用于定义方法名。 123456let obj = { ['h' + 'ello']() { return 'hi'; }};obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 12345678// 报错const foo = 'bar';const bar = 'abc';const baz = { [foo] };// 正确const foo = 'bar';const baz = { [foo]: 'abc'}; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 123456789const keyA = {a: 1};const keyB = {b: 2};const myObject = { [keyA]: 'valueA', [keyB]: 'valueB'};myObject // Object {[object Object]: &quot;valueB&quot;} 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 方法的 name 属性#普通情况#函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 1234567const person = { sayName() { console.log('hello!'); },};person.sayName.name // &quot;sayName&quot; 上面代码中，方法的name属性返回函数名（即方法名）。 get 与 set#如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 123456789101112const obj = { get foo() {}, set foo(x) {}};obj.foo.name// TypeError: Cannot read property 'name' of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // &quot;get foo&quot;descriptor.set.name // &quot;set foo&quot; bind 与 Symbol#有两种特殊情况： bind方法创造的函数，name属性返回bound加上原函数的名字； Function构造函数创造的函数，name属性返回anonymous。123456(new Function()).name // &quot;anonymous&quot;var doSomething = function() { // ...};doSomething.bind().name // &quot;bound doSomething&quot; 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。12345678const key1 = Symbol('description');const key2 = Symbol();let obj = { [key1]() {}, [key2]() {},};obj[key1].name // &quot;[description]&quot;obj[key2].name // &quot;&quot; 上面代码中，key1对应的 Symbol 值有描述，key2没有。 属性的可枚举性和遍历#属性的可枚举型#对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 12345678let obj = { foo: 123 };Object.getOwnPropertyDescriptor(obj, 'foo')// {// value: 123,// writable: true,// enumerable: true,// configurable: true// } 描述对象的enumerable属性，称为“可枚举性”，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性。 for…in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for…in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for…in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for…in遍历到。 12345Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable// falseObject.getOwnPropertyDescriptor([], 'length').enumerable// false 上面代码中，toString和length属性的enumerable都是false，因此for…in不会遍历到这两个继承自原型的属性。 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。 12Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable// false 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，**尽量不要用for…in循环，而用Object.keys()代替**。 属性的遍历： 顺序(数值升序、字符串升序、symbol升序)#ES6 一共有 5 种方法可以遍历对象的属性。 1. for…in#for…in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 2. Object.keys(obj)#Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 3. Object.getOwnPropertyNames(obj)#Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 4. Object.getOwnPropertySymbols(obj)#Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 5. Reflect.ownKeys(obj)#Reflect.ownKeys返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。12Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 super 关键字#关键字super，指向当前对象的原型对象 12345678910111213141516171819202122232425262728const proto = { foo: 'hello'};const obj = { foo: 'world', find() { return super.foo; }};Object.setPrototypeOf(obj, proto);obj.find() // &quot;hello&quot;// 报错const obj = { foo: super.foo}// 报错const obj = { foo: () =&gt; super.foo}// 报错const obj = { foo: function () { return super.foo }} 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 对象的扩展运算符#解构赋值#对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 12345678910111213141516171819202122let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };x // 1y // 2z // { a: 3, b: 4 }let { ...z } = null; // 运行时错误let { ...z } = undefined; // 运行时错误let { ...x, y, z } = someObject; // 句法错误let { x, ...y, ...z } = someObject; // 句法错误let obj = { a: { b: 1 } };let { ...x } = obj;obj.a.b = 2;x.a.b // 2 浅拷贝let o1 = { a: 1 };let o2 = { b: 2 };o2.__proto__ = o1;let { ...o3 } = o2;o3 // { b: 2 }o3.a // undefined 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。 =&gt; 必须是一个对象，或者能转化为对象 解构赋值必须是最后一个参数，否则会报错。 解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 不能复制继承自原型对象的属性 扩展运算符#对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 12345678910111213141516171819202122232425let z = { a: 3, b: 4 };let n = { ...z };n // { a: 3, b: 4 }let foo = { ...['a', 'b', 'c'] };foo// {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}//如果扩展运算符后面是一个空对象，则没有任何效果。{...{}, a: 1}// { a: 1 }//如果扩展运算符后面不是对象，则会自动将其转为对象。// 等同于 {...Object(1)}{...1} // {}// 等同于 {...Object(true)}{...true} // {}// 等同于 {...Object(undefined)}{...undefined} // {}// 等同于 {...Object(null)}{...null} // {}//如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。{...'hello'}// {0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;} 对象的扩展运算符等同于使用Object.assign()方法。 123let aClone = { ...a };// 等同于let aClone = Object.assign({}, a); 完整拷贝/克隆上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。 1234567891011121314151617// 写法一const clone1 = { __proto__: Object.getPrototypeOf(obj), ...obj};// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj);// 写法三const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。 扩展运算符可以用于合并两个对象。 后赋值的属性覆盖前面的同属性数值 可以使用表达式 注意原始实例的get方法1234567891011121314151617181920212223242526272829303132let ab = { ...a, ...b };// 等同于let ab = Object.assign({}, a, b);let aWithOverrides = { ...a, x: 1, y: 2 };// 等同于let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };// 等同于let x = 1, y = 2, aWithOverrides = { ...a, x, y };// 等同于let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });let aWithDefaults = { x: 1, y: 2, ...a };// 等同于let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);// 等同于let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);const obj = { ...(x &gt; 1 ? {a: 1} : {}), b: 2,};//扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。//下面例子中，取值函数get在扩展a对象时会自动执行，导致报错。let a = { get x() { throw new Error('not throw yet'); }}let aWithXGetter = { ...a }; // 报错 链判断运算符#判断对象/属性是否存在#?.运算符，直接在链式调用的时候判断，左侧的对象是否为null或undefined。如果是的，就不再往下运算，而是返回undefined。123456789101112// 错误的写法const firstName = message.body.user.firstName;// ES5正确的写法const firstName = (message &amp;&amp; message.body &amp;&amp; message.body.user &amp;&amp; message.body.user.firstName) || 'default';//ES2020的写法const firstName = message?.body?.user?.firstName || 'default';const fooValue = myForm.querySelector('input[name=foo]')?.value 判断对象方法是否存在，如果存在就立即执行的例子。#12iterator.return?.()//iterator.return如果有定义，就会调用该方法，否则iterator.return直接返回undefined，不再执行?.后面的部分。 基本用法#链判断运算符有三种用法。 obj?.prop // 对象属性 obj?.[expr] // 同上 func?.(…args) // 函数或对象方法的调用 下面是obj?.[expr]用法的一个例子。 1let hex = &quot;#C0FFEE&quot;.match(/#([A-Z]+)/i)?.[1]; 上面例子中，字符串的match()方法，如果没有发现匹配会返回null，如果发现匹配会返回一个数组，?.运算符起到了判断作用。下面是?.运算符常见形式，以及不使用该运算符时的等价形式。 123456789101112131415a?.b// 等同于a == null ? undefined : a.ba?.[x]// 等同于a == null ? undefined : a[x]a?.b()// 等同于a == null ? undefined : a.b()a?.()// 等同于a == null ? undefined : a() 注意点#1. 短路机制#?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行。 123a?.[++x]// 等同于a == null ? undefined : a[++x] 上面代码中，如果a是undefined或null，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。 2. delete 运算符#123delete a?.b// 等同于a == null ? undefined : delete a.b 上面代码中，如果a是undefined或null，会直接返回undefined，而不会进行delete运算。 3. 括号的影响#如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。 123(a?.b).c// 等价于(a == null ? undefined : a.b).c 上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的.c总是会执行。一般来说，使用?.运算符的场合，不应该使用圆括号。 4. 报错场合#以下写法是禁止的，会报错。 1234567891011121314// 构造函数new a?.()new a?.b()// 链判断运算符的右侧有模板字符串a?.`{b}`a?.b`{c}`// 链判断运算符的左侧是 supersuper?.()super?.foo// 链运算符用于赋值运算符左侧a?.b = c 5. 右侧不得为十进制数值#为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。 Null 判断运算符#读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。 12345678910111213//ES5的写法const headerText = response.settings.headerText || 'Hello, world!';const animationDuration = response.settings.animationDuration || 300;const showSplashScreen = response.settings.showSplashScreen || true;//上面的三行代码都通过||运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为null或undefined，默认值就会生效，但是属性的值如果为空字符串或false或0，默认值也会生效。//ES2020的写法const headerText = response.settings.headerText ?? 'Hello, world!';const animationDuration = response.settings.animationDuration ?? 300;const showSplashScreen = response.settings.showSplashScreen ?? true;//配合链判断 =&gt; 如果response.settings是null或undefined，或者response.settings.animationDuration是null或undefined，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。const animationDuration = response.settings?.animationDuration ?? 300; Null 判断运算符??。它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。 优先级问题#??与&amp;&amp;和||的优先级孰高孰低。现在的规则是，**如果多个逻辑运算符一起使用，必须用括号表明优先级**，否则会报错。 123456789101112131415161718// 报错lhs &amp;&amp; middle ?? rhslhs ?? middle &amp;&amp; rhslhs || middle ?? rhslhs ?? middle || rhs//上面四个表达式都会报错，必须加入表明优先级的括号。(lhs &amp;&amp; middle) ?? rhs;lhs &amp;&amp; (middle ?? rhs);(lhs ?? middle) &amp;&amp; rhs;lhs ?? (middle &amp;&amp; rhs);(lhs || middle) ?? rhs;lhs || (middle ?? rhs);(lhs ?? middle) || rhs;lhs ?? (middle || rhs);","link":"/2021/03/22/ES6%E7%AC%94%E8%AE%B08-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"},{"title":"ES6笔记9-Symbol","text":"Symbol相对老JSer来说有点用的少了，不过看完阮一峰老哥的文档感觉实际项目中还是很容易用起来的。 1. 概述 =&gt; 产生背景 1.1 注意点 2. Symbol.prototype.description 3. 作为属性名的 Symbol 注意点 使用示例 4. 实例：消除魔术字符串 =&gt; 其实就是3中示例 5. 属性名的遍历 使用示例 6. Symbol.for()，Symbol.keyFor() 重复使用同一个 Symbol 值 =&gt; Symbol.for() Symbol.for()与Symbol() 区别 Symbol.keyFor() 返回一个已登记的 Symbol 类型值的key 全局特性 7. 实例：模块的 Singleton 模式 8. 内置的 Symbol 值 8.1 Symbol.hasInstance =&gt; instanceof 8.2 Symbol.isConcatSpreadable =&gt; 展开: 数组默认展开，类数组对象默认不展开 8.3 Symbol.species =&gt; 衍生对象的类别 8.4 Symbol.match 8.5 Symbol.replace =&gt; 熟悉的string.replace又变得陌生了 8.6 Symbol.search 8.7 Symbol.split 8.8 Symbol.iterator =&gt; 划重点 8.9 Symbol.toPrimitive 8.10 Symbol.toStringTag 8.11 Symbol.unscopables with 1. 概述 =&gt; 产生背景#ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 1234567891011121314151617181920let s = Symbol();typeof s// &quot;symbol&quot;let s1 = Symbol('foo');s2.toString() // &quot;Symbol(bar)&quot;//如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值const obj = { toString() { return 'abc'; }};const sym = Symbol(obj);sym // Symbol(abc)// 有参数的情况 =&gt; 相同参数的Symbol函数的返回值是不相等的let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false 1.1 注意点#Symbol 值不能与其他类型的值进行运算，会报错。 123456let sym = Symbol('My symbol');&quot;your symbol is &quot; + sym// TypeError: can't convert symbol to string`your symbol is ${sym}`// TypeError: can't convert symbol to string 但是，Symbol 值可以显式转为字符串。 1234let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)' 另外，Symbol 值也可以转为布尔值，但是不能转为数值。 12345678910let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) { // ...}Number(sym) // TypeErrorsym + 2 // TypeError 2. Symbol.prototype.description#ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。 12const sym = Symbol('foo');sym.description // &quot;foo&quot; 3. 作为属性名的 Symbol#1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = {};a[mySymbol] = 'Hello!';// 第二种写法let a = { [mySymbol]: 'Hello!'};// 第三种写法let a = {};Object.defineProperty(a, mySymbol, { value: 'Hello!' });// 以上写法都得到同样结果a[mySymbol] // &quot;Hello!&quot; 注意点# Symbol 值作为对象属性名时，不能用点运算符。123456const mySymbol = Symbol();const a = {};a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // &quot;Hello!&quot; 在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。1234567891011let s = Symbol();let obj = { [s]: function (arg) { ... }};obj[s](123);//等同于let obj = { [s](arg) { ... }}; 使用示例#1234567const log = {};log.levels = { DEBUG: Symbol('debug'), INFO: Symbol('info'), WARN: Symbol('warn')}; 常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 4. 实例：消除魔术字符串 =&gt; 其实就是3中示例#魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。 5. 属性名的遍历#MARK：Symbol 作为属性名，遍历对象的时候，该属性 不会 出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols() 方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 123456789101112131415161718192021222324const obj = {};let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)]//Object.getOwnPropertySymbols()方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。const obj = {};const foo = Symbol('foo');obj[foo] = 'bar';for (let i in obj) { console.log(i); // 无输出}Object.getOwnPropertyNames(obj) // []Object.getOwnPropertySymbols(obj) // [Symbol(foo)] Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = { [Symbol('my_key')]: 1, enum: 2, nonEnum: 3};Reflect.ownKeys(obj)// [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] 使用示例#由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 1234567891011121314151617181920212223242526let size = Symbol('size');class Collection { constructor() { this[size] = 0; } add(item) { this[this[size]] = item; this[size]++; } static sizeOf(instance) { return instance[size]; }}let x = new Collection();Collection.sizeOf(x) // 0x.add('foo');Collection.sizeOf(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(size)] 上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。 6. Symbol.for()，Symbol.keyFor()#重复使用同一个 Symbol 值 =&gt; Symbol.for()#它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。 1234let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true Symbol.for()与Symbol() 区别#Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(“cat”)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”)30 次，会返回 30 个不同的 Symbol 值。 Symbol.keyFor() 返回一个已登记的 Symbol 类型值的key#12345let s1 = Symbol.for(&quot;foo&quot;);Symbol.keyFor(s1) // &quot;foo&quot;let s2 = Symbol(&quot;foo&quot;);Symbol.keyFor(s2) // undefined 全局特性#Symbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。 12345iframe = document.createElement('iframe');iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo') 7. 实例：模块的 Singleton 模式#123456789101112// mod.jsconst FOO_KEY = Symbol.for('foo');function A() { this.foo = 'hello';}if (!global[FOO_KEY]) { global[FOO_KEY] = new A();}module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。 123global[Symbol.for('foo')] = { foo: 'world' };const a = require('./mod.js'); 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。 1234// mod.jsconst FOO_KEY = Symbol('foo');// 后面代码相同 …… 上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。 8. 内置的 Symbol 值#8.1 Symbol.hasInstance =&gt; instanceof#对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是FooSymbol.hasInstance。 1234567class MyClass { [Symbol.hasInstance](foo) { return foo instanceof Array; }}[1, 2, 3] instanceof new MyClass() // true 上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。 下面是另一个例子。 12345678910111213141516class Even { static [Symbol.hasInstance](obj) { return Number(obj) % 2 === 0; }}// 等同于const Even = { [Symbol.hasInstance](obj) { return Number(obj) % 2 === 0; }};1 instanceof Even // false2 instanceof Even // true12345 instanceof Even // false 8.2 Symbol.isConcatSpreadable =&gt; 展开: 数组默认展开，类数组对象默认不展开#对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 1234567let arr1 = ['c', 'd'];['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']arr1[Symbol.isConcatSpreadable] // undefinedlet arr2 = ['c', 'd'];arr2[Symbol.isConcatSpreadable] = false;['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e'] 上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。 类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。 12345let obj = {length: 2, 0: 'c', 1: 'd'};['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']obj[Symbol.isConcatSpreadable] = true;['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e'] Symbol.isConcatSpreadable属性也可以定义在类里面。 =&gt; 两种写法 12345678910111213141516171819202122class A1 extends Array { constructor(args) { super(args); this[Symbol.isConcatSpreadable] = true; }}class A2 extends Array { constructor(args) { super(args); } get [Symbol.isConcatSpreadable] () { return false; }}let a1 = new A1();a1[0] = 3;a1[1] = 4;let a2 = new A2();a2[0] = 5;a2[1] = 6;[1, 2].concat(a1).concat(a2)// [1, 2, 3, 4, [5, 6]] 上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。注意，Symbol.isConcatSpreadable的位置差异，A1是定义在实例上，A2是定义在类本身，效果相同。 8.3 Symbol.species =&gt; 衍生对象的类别#对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。 123456789class MyArray extends Array {}const a = new MyArray(1, 2, 3);const b = a.map(x =&gt; x);const c = a.filter(x =&gt; x &gt; 1);b instanceof MyArray // truec instanceof MyArray // true 上面代码中，子类MyArray继承了父类Array，a是MyArray的实例，b和c是a的衍生对象。你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（Array的实例），但实际上它们也是MyArray的实例。 Symbol.species属性就是为了解决这个问题而提供的。现在，我们可以为MyArray设置Symbol.species属性。 123class MyArray extends Array { static get [Symbol.species]() { return Array; }} 上面代码中，由于定义了Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义Symbol.species属性要采用get取值器。默认的Symbol.species属性等同于下面的写法。 123static get [Symbol.species]() { return this;} 现在，再来看前面的例子。 123456789class MyArray extends Array { static get [Symbol.species]() { return Array; }}const a = new MyArray();const b = a.map(x =&gt; x);b instanceof MyArray // falseb instanceof Array // true 上面代码中，a.map(x =&gt; x)生成的衍生对象，就不是MyArray的实例，而直接就是Array的实例。 再看一个例子。 1234567891011class T1 extends Promise {}class T2 extends Promise { static get [Symbol.species]() { return Promise; }}new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // truenew T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false 上面代码中，T2定义了Symbol.species属性，T1没有。结果就导致了创建衍生对象时（then方法），T1调用的是自身的构造方法，而T2调用的是Promise的构造方法。 总之，Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。 8.4 Symbol.match#对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 1234567891011String.prototype.match(regexp)// 等同于regexp[Symbol.match](this)class MyMatcher { [Symbol.match](string) { return 'hello world'.indexOf(string); }}'e'.match(new MyMatcher()) // 1 8.5 Symbol.replace =&gt; 熟悉的string.replace又变得陌生了#对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。 123456789String.prototype.replace(searchValue, replaceValue)// 等同于searchValue[Symbol.replace](this, replaceValue)//下面是一个例子。const x = {};x[Symbol.replace] = (...s) =&gt; console.log(s);'Hello'.replace(x, 'World') // [&quot;Hello&quot;, &quot;World&quot;] Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。 8.6 Symbol.search#对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。 12345678910111213String.prototype.search(regexp)// 等同于regexp[Symbol.search](this)class MySearch { constructor(value) { this.value = value; } [Symbol.search](string) { return string.indexOf(this.value); }}'foobar'.search(new MySearch('foo')) // 0 8.7 Symbol.split#对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。 123456789101112131415161718192021222324String.prototype.split(separator, limit)// 等同于separator[Symbol.split](this, limit)//下面是一个例子。class MySplitter { constructor(value) { this.value = value; } [Symbol.split](string) { let index = string.indexOf(this.value); if (index === -1) { return string; } return [ string.substr(0, index), string.substr(index + this.value.length) ]; }}'foobar'.split(new MySplitter('foo')) // ['', 'bar']'foobar'.split(new MySplitter('bar')) // ['foo', '']'foobar'.split(new MySplitter('baz')) // 'foobar' 上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为 8.8 Symbol.iterator =&gt; 划重点#对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 12345678const myIterable = {};myIterable[Symbol.iterator] = function* () { yield 1; yield 2; yield 3;};[...myIterable] // [1, 2, 3] 对象进行for…of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器 12345678910111213141516171819class Collection { *[Symbol.iterator]() { let i = 0; while(this[i] !== undefined) { yield this[i]; ++i; } }}let myCollection = new Collection();myCollection[0] = 1;myCollection[1] = 2;for(let value of myCollection) { console.log(value);}// 1// 2 8.9 Symbol.toPrimitive#对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。 Number：该场合需要转成数值 String：该场合需要转成字符串 Default：该场合可以转成数值，也可以转成字符串12345678910111213141516171819let obj = { [Symbol.toPrimitive](hint) { switch (hint) { case 'number': return 123; case 'string': return 'str'; case 'default': return 'default'; default: throw new Error(); } }};2 * obj // 2463 + obj // '3default'obj == 'default' // trueString(obj) // 'str' 8.10 Symbol.toStringTag#对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。123456789101112// 例一({[Symbol.toStringTag]: 'Foo'}.toString())// &quot;[object Foo]&quot;// 例二class Collection { get [Symbol.toStringTag]() { return 'xxx'; }}let x = new Collection();Object.prototype.toString.call(x) // &quot;[object xxx]&quot; 8.11 Symbol.unscopables#对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。12345678910111213Array.prototype[Symbol.unscopables]// {// copyWithin: true,// entries: true,// fill: true,// find: true,// findIndex: true,// includes: true,// keys: true// }Object.keys(Array.prototype[Symbol.unscopables])// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys'] 上面代码说明，数组有 7 个属性，会被with命令排除。123456789101112131415161718192021222324// 没有 unscopables 时class MyClass { foo() { return 1; }}var foo = function () { return 2; };with (MyClass.prototype) { foo(); // 1}// 有 unscopables 时class MyClass { foo() { return 1; } get [Symbol.unscopables]() { return { foo: true }; }}var foo = function () { return 2; };with (MyClass.prototype) { foo(); // 2} 上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。 with#with 语句用于设置代码在特定对象中的作用域。它的语法如下： 1with (expression) statement 例如： 1234var sMessage = &quot;hello&quot;;with(sMessage) { alert(toUpperCase()); //输出 &quot;HELLO&quot;} 在这个例子中，with 语句用于字符串，所以在调用 toUpperCase() 方法时，解释程序将检查该方法是否是本地函数。如果不是，它将检查伪对象 sMessage，看它是否为该对象的方法。然后，alert 输出 “HELLO”，因为解释程序找到了字符串 “hello” 的 toUpperCase() 方法。 提示：with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。","link":"/2021/03/23/ES6%E7%AC%94%E8%AE%B09-Symbol/"},{"title":"canvas-weapp-h5","text":"忙完公司关于海报制作的需求，开这篇文章扯扯canvas！ fabric.js 画布 canvas 文本、图片：最基本的海报要素 Text Image 图层高度 自定义编辑框 自定义编辑功能 联调 1. 授权验证 WE-APP APP(RN) 2. 选择照片 WE-APP APP(RN) 3. 传递数据 WE-APP APP(RN) NOTE safeArea qrcode 二维码 fabricObject自定义附加字段 服务端处理 截取指定区域 字体 最开始的需求是在小程序内简单实现可以手动编辑的海报，不是根据数据直接套模板生成海报。找了github, 最终选的是疑似酷家乐团队的Painter。用下来基本能满足需求，但是遇到了两个问题： 新需求：可能需要整APP，那就意味着我得有个RN下的canvas组件、或者就是H5上整canvas; 调试困难：不知道是不是系统原因还是啥，mac上跑小程序编辑器一直都不是很流畅，一旦页面上跑得东西多了，动不动就可以去喝杯咖啡.. sad 接下来的小程序页面中又多加了一个需求：需要将整好的数据直接导出成图片。 首先想到的就是wxml-to-canvas。 用这还行，不过考虑到后续APP也会有相同的需求，最终把wxml-to-canvas放下，选择了H5上的canvas方案。wxml-to-canvas没法直接使用iconfont, 得把icon换成img才行。 在H5的现有方案中，首先选中的是小飞飞的easy-canvas. 但这个项目尚未支持z-index, 担心后续有图层调整相关的要求，无奈放弃。在小飞飞推荐下，开始折腾fabric.js 不用翻墙就能看的官网地址 github上有好心的前人写了中文文档. 稍微有点久远，不过用来初步入门已经足够了。 在此，就不赘述一些基本使用方法，直接按照项目中常见的需求来展开。 fabric.js#画布 canvas#12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;canvas-box&quot;&gt; &lt;canvas id=&quot;canvas&quot; :width='width' :height='height'&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import {fabric} from 'fabric';export default { data: ()=&gt; ({ width: 360, height: 640, canvas: '' }), created: function() { //预加载数据,组装等 }, mounted: function() { //canvas赋值必须得等页面加载之后才行 this.canvas = new fabric.Canvas('canvas') }, methods: { }}&lt;/script&gt; 文本、图片：最基本的海报要素#fabric.js项目作者将所有画布上的对象抽象为fabric.Object。其他所有的文本、图像之类全是基于这个基类。 Text#12345678910111213141516171819202122232425262728let obj = { text: '文本内容', //这里有借鉴Painter项目 css: { left: 100, top: 100, fontWeight: 600, color: '#fff', }}let text = new fabric.Text( obj.text, { left: obj.css.left, top: obj.css.top, fontFamily: 'Comic Sans' , fontSize: obj.css.fontSize || 20, fontWeight: obj.css.fontWeight, fill:obj.css.color, originX: obj.css.originX ||'left', })//绑定点击(选中)事件，默认是支持的，这里是为了调用自定义的编辑框text.on('selected', _this.selectedHandle)//可以配置fabric.Object不可被选中text.set('selectable', !!obj.editAble);this.canvas.add(text);//moveTo方法将在后续控制层高的地方讲到text.moveTo(1) Text有个进阶的Object: IText tips: Text可以设置padding, 默认的编辑框border距离文本实在是太近了，尤其是需要自定义编辑框按钮的时候，挨得太近根本没办法好好显示按钮，通过设置这个参数，就可以开心的留一些区域给按钮啦 Image#12345678910111213141516171819202122232425262728//加载跨域图片new fabric.Image.fromURL(obj.url, function(img) { //这里img.width/height是图片的原始宽高，单位px console.log(img.width , img.height, obj.css.width) let scaleRatio = obj.css.width / img.width //通过scale使图片适应设定的宽高 img.scale(scaleRatio); //可以设置翻转 // oImg.scale(0.5).set('flipX, true); img.on('selected', _this.selectedHandle) img.top = obj.css.top img.left = obj.css.left //不设置height,避免选择框不能匹配图像边缘 img.on('selected', _this.selectedHandle) img.set('selectable', !!obj.editAble);}, {crossOrigin: 'anonymous'})//加载本地图片// &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;// &lt;img src=&quot;my_image.png&quot; id=&quot;my-image&quot;&gt;var canvas = new fabric.Canvas('c');var imgElement = document.getElementById('my-image');var imgInstance = new fabric.Image(imgElement, { left: 100, top: 100, angle: 30, opacity: 0.85});canvas.add(imgInstance); 加载跨域图片时候需要设置crossOrigin参数。 所有的fabric.Object下子类都是公用编辑框(controls)的 加载图片是个异步操作，不能保证所有Object的先后顺序。这就需要配合之前所说的moveTo函数来控制其图层高度。 图层高度#点此查看介绍文档 图层高度同z-index, 数值大的可以遮挡数值小的。控制图层一般用到这几个方法： 12345obj.bringToFront(); // 置顶obj.bringForward(); // 向上一层obj.sendToBack(); // 置底obj.sendBackwards(); // 向下一层obj.moveTo(n); // 设置层高N 自定义编辑框#fabric.js自带的编辑框还是蛮丑的… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103selectedHandle: function() { //getActiveObject()可以获取当前被选中的对象 -&gt; 进而获取其类型 let type = this.canvas.getActiveObject() ? this.canvas.getActiveObject().type : null type &amp;&amp; this.setupEditBox(type) //如果是文本, 则显示文本编辑菜单，如果是图片则显示图片菜单 this.showTextMenu = type == 'text' this.showImgMenu = type == 'image'},setupEditBox: function(targetType) { //首先隐藏默认的编辑框上的所有小点(按钮) Object.values(fabric.Object.prototype.controls).forEach(c =&gt; c.visible = false); //可以理解为原生按钮支持的事件handler let controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls; //icon直接用的base64 png图片，这里不适合全部黏贴上来，后续补充demo的时候，可以去demo查看 //编辑框画自定义的按钮还没尝试其他方法... 后续尝试下新的放方法 let _this = this, editIcon64 = 'data:image/png;base64,...' let eidtIconImg = document.createElement('img'); eidtIconImg.src = editIcon64; let scaleIcon64 = 'data:image/png;base64,...' let scaleIconImg = document.createElement('img'); scaleIconImg.src = scaleIcon64; let textCloseIcon64 = 'data:image/png;base64,...'; let textCloseIconImg = document.createElement('img'); textCloseIconImg.src = textCloseIcon64; //edit即为这个新按钮的名称，可以随意取 fabric.Object.prototype.controls.edit = new fabric.Control({ x: 0, //x y是以Object中心点为0的, 向上为Y负轴， 向左为X负轴 y: -0.5, //0.5其实指的是 height * 0.5 offsetY: -30, //30的单位是px cursorStyle: 'pointer', mouseUpHandler: _this.showEditPopover, //点击事件的handler，请看下一小节 render: renderTextEditIcon, //自定义绘制按钮 cornerSize: 32, visible: targetType == 'text' }); fabric.Object.prototype.controls.scale = new fabric.Control({ x: 0.5, y: 0.5, cursorStyle: 'pointer', render: renderImageScaleIcon, cornerSize: 32, actionHandler:scalingEqually, visible: targetType == 'image' }); fabric.Object.prototype.controls.text_close = new fabric.Control({ x: 0, y: 0.5, offsetY: 30, cursorStyle: 'pointer', render: renderTextCloseIcon, cornerSize: 32, mouseUpHandler: _this.deleteTextHandle, visible: targetType == 'text' }); //其实我也不想在这里写function, 试了下写外面，结果绘制没成功... sad function renderImageScaleIcon(ctx, left, top, styleOverride, fabricObject) { let w = 32, h = 32; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(scaleIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw edit box for img done') } function renderTextEditIcon(ctx, left, top, styleOverride, fabricObject) { let w = 32, h = 32; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(eidtIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw edit icon for text done') } function renderTextCloseIcon(ctx, left, top, styleOverride, fabricObject) { let w = 30, h = 30; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(textCloseIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw close icon for text done') }}, 自定义编辑功能#在controls.edit我们指定了mouseUpHandler为showEditPopover。control.close用了一样的方式来获取点击事件。 12345678910showEditPopover: function(eventData, target) { //没直接用传参 let obj = this.canvas.getActiveObject() if (!obj || obj.type != 'text') { return } //如果是文本被点击，则弹出modle允许编辑 this.showTextEditModel = true; this.textEditModelContent = obj.text}, 当我们的model中修改文本内容完成，则可以用下面的方法替换画布上的文本 12345678confirmTextEdit: function() { let obj = this.canvas.getActiveObject() if (!!obj &amp;&amp; obj.type == 'text') { obj.text = this.textEditModelContent } this.canvas.requestRenderAll(); //重新渲染画布 this.showTextEditModel = false //清除model}, 联调#涉及到联调的主要是这几个功能点： we-app的授权验证 选取移动端本地(相册)的照片 fabric.js生成的图片传给APP或者we-app使用 1. 授权验证#WE-APP#先引入wx-jdk，我是先在index.html顶部加载，然后通过vue的配置来获取的 vue.config.js12345configureWebpack: { externals: { 'weixin-js-sdk': 'wx' },}, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364created: function() { let _this = this //确认是否是在小程序中 wx.miniProgram.getEnv(function(res) { console.log(res.miniprogram) _this.weAppEnv = res.miniprogram })},mounted: function() { if(this.weAppEnv) { this.initWxConfig() }},methods: { initWxConfig: function() { let url = window.location.href url = url.split('#')[0] const promise = axios.get('/api/wechat/h5/sign/share' + '?app_id=' + this.appId + '&amp;url=' + url); promise.then(res =&gt; { if (res.data.code == 200) { const sign = res.data.data; this._wxConfigJSSDK(sign); } }); promise.catch((err) =&gt; { console.log(err.response); }) }, _wxConfigJSSDK: function(sign){ wx.config({ debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: sign.appId + '', // 必填，公众号的唯一标识 timestamp: parseInt(sign.timestamp), // 必填，生成签名的时间戳 nonceStr: sign.nonceStr + '', // 必填，生成签名的随机串 signature: sign.signature + '',// 必填，签名 jsApiList: ['chooseImage', 'downloadImage', 'previewImage', 'uploadImage'] // 必填，需要使用的JS接口列表 }) wx.ready(function(){ wx.checkJsApi({ jsApiList: [ 'chooseImage', 'previewImage', 'uploadImage', 'downloadImage' ], success: function (res) { if (res.checkResult.getLocation == false) { console.error('你的微信版本太低，不支持微信JS接口，请升级到最新的微信版本！'); return; }else{ console.log('授权成功', res) } }, fail: err=&gt; { console.log(err) } }); }); wx.error(function(res){ console.error(res) }); },} 中间涉及到一个appId,即为调用该页面的小程序关联的公众号appid 当我们需要调用分享(APP、H5内),就需要进行签名。具体逻辑参照官方文档 切记将这个fabric.js所在的域名添加到公众号下的安全域名内，没错，公众号！！！和小程序关联的公众号，同主体，同开发者平台账号下 切记将这个fabric.js所在的域名添加到小程序的合法业务域名下 小程序开发工具-网页模式可以用来调试当前fabric.js页面 小程序开发工具-小程序模式没办法使用模拟器来测试授权，必须真机测试！！！一般来说上一步的网页模式测试没问题，真机也不会有问题 不涉及选择照片功能的话，可以不授权。 APP(RN)#RN内好像没涉及授权问题 2. 选择照片#WE-APP#借用wx-js-sdk来手机上的照片，也可以支持拍照。前提是完成wx.config 1234567891011121314151617181920212223242526272829303132_getLocalImage: function() { let _this = this return new Promise((resolve, reject)=&gt; { wx.chooseImage({ count: 1, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) { var localIds = res.localIds; // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 let targetImgId = localIds[0] console.log('wkwebview is' + !!window.__wxjs_is_wkwebview) wx.getLocalImgData({ localId: targetImgId, success: (res) =&gt; { let localData = res.localData // localData是图片的base64数据，可以用img标签显示 if (localData.indexOf('data:image') != 0) { //判断是否有这样的头部 =&gt; 兼容安卓机型（安卓机不包含data头） localData = 'data:image/jpeg;base64,' + localData } resolve(localData) }, fail: err=&gt; { reject(err) } }) }, fail: err=&gt; { reject(err) } }); })}, APP(RN)#rn中的选择照片就相对简单一点。主要是用到组件react-native-image-picker 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;Avatar containerStyle={styles.avatar} rounded size=&quot;large&quot; source={{ uri: 'https://' + this.props.agent.avatar }} title={!this.props.agent.avatar ? '店': null} &gt; &lt;Avatar.Accessory name=&quot;edit&quot; size={25} onPress={()=&gt; { let options = { mediaType: 'photo', maxWidth: '320', maxHeight: '320', quality: '0.8', }, callback = async (res) =&gt; { if(res &amp;&amp; res.uri) { let loading = Toast.loading('即将上传，请稍候', 0) let token = await applyToken() if(token) { Toast.remove(loading) let uploadLoading = Toast.loading('正在上传', 0), key = 'agent/avatar/' + this.props.agent.id + '/' + new Date().getTime() + '.jpg' upload( { key: key, path: res.uri.replace('file://', ''), //这个是关键 mimeType: res.type, token: token, zone: ZONE.HUABEI, }, null ).then(data =&gt; { console.log(data) Toast.remove(uploadLoading) Toast.success('上传成功', 2, ()=&gt; { let avatarURL = 'oss-xxx.XXX.com/' + data.key this.props.updateAgentAvatar({avatar: avatarURL}) //追加同步服务器的步骤 }) }) .catch(err =&gt; { console.error(err) if (err.code === CODE.UPLOAD_FAILURE) { console.log('upload error') } }) } } } launchImageLibrary(options, callback) }} /&gt;&lt;/Avatar&gt; 3. 传递数据#WE-APP#H5传数据给小程序的webview，难点在于接收数据的时机和页面切换。 用户点击H5上的生成海报时，先将base64数据postMsg给小程序，然后执行wx.miniProgram.redirectTo(‘url?params’) 嵌套H5的页面中webview绑定msgHandler接收H5传上来的数据,并存storage 跳转后的页面接收params, 稍作定时(假装loading)后，从storage中获取数据，转base64为本地文件展示。 APP(RN)#h512345let obj = { type: 'generate-img', img: cripedImage //base64}window.ReactNativeWebView &amp;&amp; window.ReactNativeWebView.postMessage(JSON.stringify(obj)) rn1234567891011121314151617181920212223242526272829//为了更好的区分H5是谁调用的，可以在此webview中设置前缀script(后续再补充)&lt;WebView onLoad={(e) =&gt; console.log('onLoad')} onLoadEnd={(e) =&gt; console.log('onLoadEnd')} onLoadStart={(e) =&gt; console.log('onLoadStart')} renderError={() =&gt; { console.log('renderError') return &lt;View&gt;&lt;Text&gt;renderError回调了，出现错误&lt;/Text&gt;&lt;/View&gt; }} renderLoading={() =&gt; { return &lt;View&gt;&lt;Text&gt;这是自定义Loading...&lt;/Text&gt;&lt;/View&gt; }} source={{uri: this.state.url}} //h5页面地址 style={{marginTop: 20}} onMessage={this._onMessage} //接收上面传过来的参数/&gt;_onMessage = (event)=&gt; { let webString = event.nativeEvent ? event.nativeEvent.data : '' if(webString) { let obj = JSON.parse(webString) if(obj &amp;&amp; obj.type == 'generate-img') { Actions['poster-preview']({ img: obj.img }) return } } console.log('H5-&gt;RN传参错误')} NOTE#safeArea#qrcode 二维码#fabricObject自定义附加字段#服务端处理#参考文档 截取指定区域#参考文档 123456789101112131415161718192021222324252627282930313233/** Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately* @param {Object} [options] Options object* @param {String} [options.format=png] The format of the output image. Either &quot;jpeg&quot; or &quot;png&quot;* @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.* @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent* @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14* @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14* @param {Number} [options.width] Cropping width. Introduced in v1.2.14* @param {Number} [options.height] Cropping height. Introduced in v1.2.14* @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0* @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format* @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}*/// @example &lt;caption&gt;Generate jpeg dataURL with lower quality&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'jpeg', quality: 0.8 });// @example &lt;caption&gt;Generate cropped png dataURL (clipping of canvas)&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'png', left: 100, top: 100, width: 200, height: 200 });// @example &lt;caption&gt;Generate double scaled png dataURL&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'png', multiplier: 2 }); 字体#Q: 小程序内嵌H5， H5使用fabric, 但画布上的英文字很明显不是选用的字体? (后来发现这个是Times New Roman)A: 最开始怀疑是微信浏览器最字体做了限制，官方文档,后台注意到嵌入fabric的H5页面，非canvas内部的字体并没有受到影响。至此： 字体支持应该是设置的字体在电脑端(测试时)存在，但真机时并没有 尝试在真机上设置Text的字体为苹方，上述猜想得到证实 接下来就是得想办法让真机能支持自己设置的字体-&gt; 区分机型，并为不同机型寻找合适的字体PS: 至于node端设置字体，请参考这个文章","link":"/2020/12/28/canvas-weapp-h5/"},{"title":"React Native APP开发(2)","text":"采用RN开发APP基础篇 React基础 1. class组件 2. 路由-组件跳转 3. 状态管理 action reducer Store 数据流 全局引用 异步Action 4. 数据持久化 后记 React基础#安利个网站snack，方便在线调试自己写的代码(尤其是起步阶段，避免眼高手低) 可以不用注册，保存个链接，必要的时候赋值代码进去修改/运行 1. class组件#javascript123456789import React, { Component } from 'react';import { Text } from 'react-native';export default class Cat extends Component { render() { return ( &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; ); }} props对应外部传入的参数， 一般不在内部修改state对应组件内部的参数, 根据用户交互行为变更/赋值 javascript12345678910111213141516171819202122232425262728293031323334import React, { Component } from &quot;react&quot;;import { Button, Text, View } from &quot;react-native&quot;;export class Cat extends Component { state = { isHungry: true }; render() { return ( &lt;View&gt; &lt;Text&gt; I am {this.props.name}, and I am {this.state.isHungry ? &quot; hungry&quot; : &quot; full&quot;}! &lt;/Text&gt; &lt;Button onPress={() =&gt; { this.setState({ isHungry: false }); }} disabled={!this.state.isHungry} title={ this.state.isHungry ? &quot;Pour me some milk, please!&quot; : &quot;Thank you!&quot; } /&gt; &lt;/View&gt; ); }}export default class Cafe extends Component { render() { return ( &lt;&gt; &lt;Cat name=&quot;Munkustrap&quot; /&gt; &lt;Cat name=&quot;Spot&quot; /&gt; &lt;/&gt; ); }} 在class形式的组件中，不用管props的内部结构，只需要注意引用组件时怎么传递参数。 state 参数的命名方式需要注意。 onPress赋值的应该是一个函数，也可以直接提出来写 render返回必须用()包起来， 所有的模板内容必须用一个元素包起来，不能出现并列的多个元素javascript12345678910111213141516171819202122232425import React, { Component } from 'react';import { Text, Button, View } from 'react-native';export default class Cat extends Component { state = { showName: false, } showName = ()=&gt; { if(this.state.showName) return; this.setState({ showName: true }) } render() { return ( &lt;View&gt; &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; { this.state.showName ? (&lt;Text&gt;My name is Lily!&lt;/Text&gt;) : (null)} &lt;Button onPress={this.showName} title=&quot;show my name&quot;&gt;&lt;/Button&gt; &lt;/View&gt; // &lt;View&gt; // &lt;Text&gt;这个View-Text不能写, 类似于Vue只能有一个根元素&lt;/Text&gt; // &lt;/View&gt; ); }} 2. 路由-组件跳转#类似于vue-router，rn的路由管理组件为react-native-router-flux, 需要注意的是该组件有多个大版本，对应不同版本的react-navigation，查阅文档的时候请先留意版本是否匹配。官方还有react-router方案可选.当前以最新版V4.2.0为例。 首先构建两个页面(sence) javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//login.jsimport React, {Component} from 'react';import {View, Text, SafeAreaView,StatusBar} from 'react-native';import {Actions} from &quot;react-native-router-flux&quot;;export default class Login extends Component { gotoRegister = (params)=&gt; { Actions.register() } render() { return ( &lt;&gt; &lt;StatusBar&gt;&lt;/StatusBar&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text&gt;登录页面&lt;/Text&gt; &lt;Button onPress={this.gotoRegister} type=&quot;primary&quot; title=&quot;没有账号，立即注册&quot;&gt;&lt;/Button&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); }}//import React, {Component} from 'react';import {View, Text, SafeAreaView,StatusBar} from 'react-native';import {Actions} from &quot;react-native-router-flux&quot;;export default class Register extends Component { gotoIndex = (params)=&gt; { Actions.reset('index', {}) } render() { return ( &lt;&gt; &lt;StatusBar&gt;&lt;/StatusBar&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text&gt;注册页面&lt;/Text&gt; &lt;Button onPress={this.gotoIndex} type=&quot;primary&quot; title=&quot;前往首页&quot;&gt;&lt;/Button&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); }} 构建APP.js javascript123456789101112131415161718192021222324import React, { Component } from 'react';import Login from './container/Login';import Register from './container/Register';import Index from './container/Index';import {Stack, Scene, Router, Actions, Tabs} from 'react-native-router-flux';export default class App extends Component&lt;Props&gt; { render() { return ( &lt;Router&gt; &lt;Stack key=&quot;root&quot; title=&quot;测试&quot;&gt; &lt;Scene key=&quot;login&quot; component={Login} initial=&quot;true&quot; //设置默认页面 title=&quot;Login&quot; /&gt; &lt;Scene key=&quot;register&quot; component={Register} title=&quot;Register&quot; /&gt; &lt;Scene key=&quot;index&quot; component={Index} hideNavBar /&gt; &lt;/Stack&gt; &lt;/Router&gt; ); }} react-native-router-flux提供了便捷的路由跳转API,可以通过在app.js内设置的sence.key搭配Actions直接跳转 javascript123456let props = { shopId: 123}Actions.login(props)// 等同于Actions.push('login', props) 常用的的API如下, javascript123456789101112131415// 返回上一页面Actions.pop();// 返回指定页面(堆栈中)Actions.popTo('key'); // 刷新页面Actions.refresh({ param1: 'hello', param2: 'world' });// 清空当前页面堆栈，重新打开指定的页面Actions.reset('index', props)// tabbar之间切换Actions.jump('key') 3. 状态管理#APP内往往需要全局共享用户的登录状态、昵称、头像等，这时候就需要状态管理组件react-redux。在使用react-redux之前，先了解下redux的一些基本概念。 action reducer store NOTE应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。惟一改变 state 的办法是触发 action(一个描述发生什么的对象)。为了描述 action 如何改变 state 树，你需要编写 reducers。 action#Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。 javascript12345678910//建议单独文件存放const ADD_TODO = 'ADD_TODO'import { ADD_TODO, REMOVE_TODO } from '../actionTypes'//action对象{ type: ADD_TODO, text: 'Build my first Redux app'} action creator之前说action是一个普通对象，action creator则是一个函数，根据传参来返回需要的action.如果我们把store对应的state想象成是一个人， 那么action就是各种人所包含动作的描述。 javascript123456789{ type: '跑步',}{ type: '平躺',}... action除type可以自定义各种属性，所以我们可以这样来细化action javascript12345678910111213141516{ type: '跑步', speed: '慢速',}{ type: '跑步', speed: '中速',}{ type: '跑步', speed: '快速',}... 这时候我们就会想，需要根据某个传参(比如说跑步前吃的多不多)来确定自己具体使用哪个action(跑多快),这就引出了creator函数 javascript12345678910111213141516171819function run(payload) { if(payload.full == 1) { return { type: '跑步', speed: '慢速', } } else if (payload.full == 0) { return { type: '跑步', speed: '快速', } } else { return { type: '跑步', speed: '中速', } }} 进一步， 我们也会根据其他参数来定义更加丰富的action(根据零花钱来确定是跑回去呢，还是打车等等)总的来看action creator的思路和java中的工厂模式类似。 javascript12345678910111213141516171819202122232425262728293031323334/* * action 类型 */export const ADD_TODO = 'ADD_TODO';export const TOGGLE_TODO = 'TOGGLE_TODO'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'/* * 其它的常量 */export const VisibilityFilters = { SHOW_ALL: 'SHOW_ALL', SHOW_COMPLETED: 'SHOW_COMPLETED', SHOW_ACTIVE: 'SHOW_ACTIVE'}/* * action 创建函数 */export function addTodo(text) { return { type: ADD_TODO, text }}export function toggleTodo(index) { return { type: TOGGLE_TODO, index }}export function setVisibilityFilter(filter) { return { type: SET_VISIBILITY_FILTER, filter }} Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。 javascript12dispatch(addTodo(text))dispatch(completeTodo(index)) 或者创建一个 被绑定的 action 创建函数 来自动 dispatch： javascript12const boundAddTodo = text =&gt; dispatch(addTodo(text))const boundCompleteTodo = index =&gt; dispatch(completeTodo(index)) 然后直接调用它们： javascript12boundAddTodo(text);boundCompleteTodo(index); reducer#reducer 是一个纯函数，接收旧的 state 和 action，返回新的 state。 1(previousState, action) =&gt; newState 保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 1234567891011121314151617181920212223242526272829303132333435import { WALK, RUN, TAXI } from './actions'const initialState = { useVehicle: false, costMoney: false speed: null};function backHome(state, action) { if (typeof state === 'undefined') { return initialState } //处理其他action return state}//上述undefined的判断可以精简为如下function todoApp(state = initialState, action) { switch (action.type) { case WALK.type: return Object.assign({}, state, { useVehicle: false, costMoney: false speed: '5km/h' }) case RUN.type: return { ...state, useVehicle: false, costMoney: false speed: '15km/h' }) default: return state }} reducer合并 12345678910111213141516import { combineReducers } from 'redux'const todoApp = combineReducers({ visibilityFilter, mytodo: todos})export default todoApp//等价于export default function todoApp(state = {}, action) { return { visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) }} Store#Store的功能： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器。 12345import { createStore } from 'redux'import todoApp from './reducers'let store = createStore(todoApp)// 设置初始状态let store = createStore(todoApp, window.STATE_FROM_SERVER) 数据流#严格的单向数据流是 Redux 架构的设计核心。应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。 Redux 应用中数据的生命周期遵循下面 4 个步骤： 调用 store.dispatch(action); Redux store 调用传入的 reducer 函数: Store 会把两个参数(当前的 state 树和 上述action)传入 reducer; 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树 Redux store 保存了根 reducer 返回的完整 state 树 NOTE Redux 和 React 之间没有关系 Redux 的 React 绑定库(react-redux)是基于 容器组件和展示组件相分离 的开发思想 全局引用#React Redux 组件 让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。 123456789101112131415import React from 'react'import { render } from 'react-dom'import { Provider } from 'react-redux'import { createStore } from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp)render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 异步Action#默认情况下，createStore() 所创建的 Redux store 没有使用 middleware，所以只支持 同步数据流。你可以使用 applyMiddleware() 来增强 createStore()。虽然这不是必须的，但是它可以帮助你用简便的方式来描述异步的 action。像 redux-thunk 或 redux-promise 这样支持异步的 middleware 都包装了 store 的 dispatch() 方法，以此来让你 dispatch 一些除了 action 以外的其他内容，例如：函数或者 Promise。你所使用的任何 middleware 都可以以自己的方式解析你 dispatch 的任何内容，并继续传递 actions 给下一个 middleware。比如，支持 Promise 的 middleware 能够拦截 Promise，然后为每个 Promise 异步地 dispatch 一对 begin/end actions。当 middleware 链中的最后一个 middleware 开始 dispatch action 时，这个 action 必须是一个普通对象。这是 同步式的 Redux 数据流 开始的地方（译注：这里应该是指，你可以使用任意多异步的 middleware 去做你想做的事情，但是需要使用普通对象作为最后一个被 dispatch 的 action ，来将处理流程带回同步方式）。项目中，我们常常会需要发起异步请求，这时候action就会需要异步等待请求的结果(success or fail)。请先在项目引入redux-thunk，以发起请求为例 actions123{ type: 'REQUEST_POST' }{ type: 'RECEIVE_POSTS', error: 'Oops', response: null }{ type: 'RECEIVE_POSTS', response: { ... }, error: null } 构建action creator, 三个同步action: 发起请求 请求成功 请求失败123456789101112131415161718192021222324//通知 reducer 请求开始的 actionexport function requestPosts(){ return { type: REQUEST_POSTS, isFetch:true //进度条相关 }} //通知 reducer 请求成功的 actionexport function receviePostOnSuccess(data){ return { type: RECEIVE_POSTS, isFetch:false, amount: data }} //通知 reducer 请求失败的 action。export function receviePostOnError( message){ return{ type: RECEIVE_POSTS, isFetch:false, errorMsg:message }} 假设我们的请求是用来获取阅读量amount, 实际项目中建议改为data12345const initState={ isFetch: false, amount: 0, errorMsg: null,} reducers12345678910111213141516171819export function request_reducer(state=initState, action) { console.log(action.type, JSON.stringify(action)) switch (action.type){ case REQUEST_POSTS: return { ...state, isFetch: action.isFetch ? true : false, } case RECEIVE_POSTS: return { ...state, isFetch: false, amount: action.amount ? action.amount : 0, errorMsg: action.errorMsg ? action.errorMsg : null } default: return state; }} 异步action的关键在于action creator返回的不是一个简单对象{type: ...}, 而是一个函数/Promise(归功于thunk) 1234567891011121314151617181920212223242526272829//最核心的异步操作export function fetchAmount() { return axios.get('http://www.baidu.com')}//异步action//异步请求action 【将上面3个基础的action整合】export function getAmountPromise(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) const {num} = getState() return new Promise((resolve, reject)=&gt; { let success = (res)=&gt; { setTimeout(()=&gt; { dispatch(receviePostOnSuccess(num.number)) resolve(res) }, 2000) }, fail = (err)=&gt; { console.log(error); dispatch(receviePostOnError('error')) reject(err) } fetchAmount().then(success, fail) }) }} 完整例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//一个异步请求import axios from 'axios';const REQUEST_POSTS = &quot;REQUEST_POST&quot;;const RECEIVE_POSTS = &quot;RECEIVE_POSTS&quot;;const initState={ isFetch: false, amount: 0, errorMsg: null,}export function request_reducer(state=initState, action) { console.log(action.type, JSON.stringify(action)) switch (action.type){ case REQUEST_POSTS: return { ...state, isFetch: action.isFetch ? true : false, } case RECEIVE_POSTS: return { ...state, isFetch: false, amount: action.amount ? action.amount : 0, errorMsg: action.errorMsg ? action.errorMsg : null } default: return state; }}export function fetchAmount() { return axios.get('http://www.baidu.com')}//通知 reducer 请求开始的 actionexport function requestPosts(){ return { type: REQUEST_POSTS, isFetch:true //进度条相关 }} //通知 reducer 请求成功的 actionexport function receviePostOnSuccess(data){ return { type: RECEIVE_POSTS, isFetch:false, amount: data }} //通知 reducer 请求失败的 action。export function receviePostOnError( message){ return{ type: RECEIVE_POSTS, isFetch:false, errorMsg:message }} //异步请求action 【将上面3个基础的action整合】//写法一export function getAmount(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 // console.log( JSON.stringify(this), JSON.stringify(_this)) console.log(&quot;==================&quot;) dispatch(requestPosts()) const {num} = getState() //异步请求后端接口 return fetchAmount().then( data=&gt; { console.log(num); dispatch(receviePostOnSuccess(num.number)) }, error=&gt; { console.log(error); dispatch(receviePostOnError('error')) } ) }}//异步请求action 【将上面3个基础的action整合】//写法二export function getAmountPromise(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) const {num} = getState() return new Promise((resolve, reject)=&gt; { let success = (res)=&gt; { setTimeout(()=&gt; { dispatch(receviePostOnSuccess(num.number)) resolve(res) }, 2000) }, fail = (err)=&gt; { console.log(error); dispatch(receviePostOnError('error')) reject(err) } fetchAmount().then(success, fail) }) }} 4. 数据持久化#TODO 后记#写异步action的时候一直有疑惑，如果把所有的网络请求都用redux的思路来写的话，这个代码量简直爆炸。请教了之前写RN的朋友，被告知，异步网络请求可以不走action, 简单封装下axios, 统一管理API即可。","link":"/2020/10/30/rn-app-step2/"},{"title":"前端基础之CommonJs、AMD、CMD、UMD","text":"本文主要介绍CommonJs、AMD、CMD、UMD以及由此衍生的require、export、exports、import等。 CommonJs module.exports和exports的区别 AMD 异步模块定义 CMD CMD 与 AMD 的区别 UMD 实现 export 命名式导出 注意 默认导出（定义式导出） import 引入模块 命名式导入 默认导入 ES6中的 Module 概述 自动严格模式 export 注意点 import 注意点 提升 表达式和变量 只加载，不执行 单例模式 与CommonJS/require混用时注意点 整体加载 export default export 符合 import 模块的集成 跨模块常量 参考文档 CommonJs#一种服务器端模块化的规范，Nodejs实现了这种规范，所以就说Nodejs支持CommonJS。 CommonJS分为三部分： require 模块加载 exports 模块导出 module 模块本身 根据规范一个单独的JS文件就是一个module，每个单独的module是一个单独的作用域。也就是说在一个文件里定义的变量和函数都是私有，对其他文件不可见，除非用exports导出了。在CommonJS中,暴露模块使用module.exports和exports，很多人不明白暴露对象为什么会有两个,后面会介绍区别 在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载和调用。 math.js123456const math = { add: function(x, y) { return x + y }}module.exports = math utils.js123exports.toInt = function(string) =&gt; { return parseInt(string) || 0} 123var math = require('math');let {toInt} = require('utils')math.add(2,3); // 5 正是由于CommonJS 使用的require方式的推动，才有了后面的AMD、CMD 也采用的require方式来引用模块的风格. module.exports和exports的区别#module和exports是Node.js给每个js文件内置的两个对象。 在node.js中打印console.log(module)可以看出 module 和 exports 都是node中提供的两个对象，其中module里包裹着exports 123456789Module { id: '.', exports: {}, parent: null, filename: '', loaded: false, children: [], paths:[] } 实际上这两个对象指向同一块内存。这也就是说module.exports和exports是等价的。 12exports.age = 18; module.exports.age = 18; 这两种写法是一致的（都相当于给最初的空对象{}添加了一个属性，通过require得到的就是{age: 18}）。 但是 每个导出模块 node.js 默认会返回 return module.exports; 当直接给module.exports或exports赋值时，就相当于改变了内存，两者指代的就不是同一内存，这样就会导致exports中的内容失效，因为module.exports所指向的内存永远是真正的内存 直接给module.exports赋值导致内存改变，新生成的内存依然是真正的内存，那exports原先指向的内存就无效了 1234567//song.jsmodule.exports = {name: '樱花树下'}；exports = {name: '不吐不快'};//main.jslet song= require('./song');console.log(song);//输出：{name: '樱花树下'} 直接给exports赋值导致内存改变，那么exports所指的内存就是无效内存，所以会返回module.exports空对象 123456//song.jsexports = {name: '不吐不快'};//main.jslet song= require('./song');console.log(song);//输出：{} soexports = module.exports 这个用来重新建立引用关系的就是重新把无效内存指向真正内存 这样 exports 和 module.exports 就重新建立了联系 AMD 异步模块定义#产生背景：第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 AMD是浏览器上的规范. 123456789101112131415161718192021222324252627define(id?, dependencies?, factory)/* 参数解释- id:字符串，模块名称(可选)- dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式- factory: 工厂方法，返回一个模块函数*/// math.js 如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。define(function (){ var add = function (x,y){ return x+y; }; return { add: add };});//如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。define(['Lib'], function(Lib){ function foo(){ Lib.doSomething(); } return { foo : foo };}); AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： 123456789require([module], callback);/* 第一个参数[module]，是一个数组，里面的成员就是要加载的模块； 第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：*/require(['math'], function (math) { math.add(2, 3);} 主要有两个Javascript库实现了AMD规范：require.js和curl.js。 CMD#CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的： 1234define(function(require, exports, module) { var clock = require('clock'); //主要是这行代码 clock.start();} CMD与AMD一样，也是采用特定的define()函数来定义,用require方式来引用模块 1234567891011121314define(id?, dependencies?, factory)/* id:字符串，模块名称(可选) dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式 factory: 工厂方法，返回一个模块函数*/define('hello', ['jquery'], function(require, exports, module) { // 模块代码});//如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。define(function(require, exports, module) { // 模块代码} CMD 与 AMD 的区别#AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。 AMD依赖前置，js可以方便知道依赖模块是谁，立即加载； 而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 UMD#Universal Module Definition。从名字就可以看出来UMD做的是大一统的工作，把前后端加载糅合在了一起，提供了一个前后端统一的解决方案。支持AMD和CommonJS模式。 实现# 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 前两个都不存在，则将模块公开到全局（window或global）。 example123456789101112131415161718192021// if the module has no dependencies, the above pattern can be simplified to(function (root, factory) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD. Register as an anonymous module. define([], factory); } else if (typeof exports === 'object') { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); } else { // Browser globals (root is window) root.returnExports = factory(); }}(this, function () { // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return {};})); export#export语法声明用于导出函数、对象、指定文件（或模块）的原始值。ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块.(浏览器)但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports/exports导出接口。 export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。 1234567891011121314151617181920export { name1, name2, …, nameN };export { variable1 as name1, variable2 as name2, …, nameN };export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, const export default expression;export default function (…) { … } // also class, function*export default function name1(…) { … } // also class, function*export { name1 as default, … }; export * from …;export { name1, name2, …, nameN } from …;export { import1 as name1, import2 as name2, …, nameN } from …;/*name1… nameN－导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用import引用default－设置模块的默认导出。设置后import不通过“标识符”而直接引用默认导入－继承模块并导出继承模块所有的方法和属性as－重命名导出“标识符”from－从已经存在的模块、脚本文件…导出*/ 命名式导出#12345678910export { myFunction }; // 导出一个已定义的函数export const foo = Math.sqrt(2); // 导出一个常量export * from 'article'; //使用*和from关键字来实现的模块的继承：=&gt;这句话没怎么理解var name = 'IT笔录';var domain = 'http://itbilu.com'; export {name as siteName, domain}; 注意#下面的语法有严重错误的情况： 12345// 错误演示export 1; // 绝对不可以 var a = 100;export a; export在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出1没有任何意义，也不可能在import的时候有一个变量与之对应.上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样export a虽然看上去成立，但是a的值是一个数字，根本无法完成解构，因此必须写成export {a}的形式。即使a被赋值为一个function，也是不允许的。而且，大部分风格都建议，模块中最好在末尾用一个export导出所有的接口，例如： 1export {fun as default,a,b,c}; 正确的写法应该是这样 12345const D = 123; export default D;export { D as default }; 或者按照ES6的规则:export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 12345678910111213141516// 写法一export var m = 1;// 写法二var m = 1;export {m};// 写法三var n = 1;export {n as m};// 同理, 以下写法也是对的export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 默认导出（定义式导出）#默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在import引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块import导入时也会很容易引用。 12export default function() {}; // 可以导出一个函数export default class(){}; // 也可以出一个类 import 引入模块#import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。 import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。 import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。 123456789101112131415161718import defaultMember from &quot;module-name&quot;;import * as name from &quot;module-name&quot;;import { member } from &quot;module-name&quot;;import { member as alias } from &quot;module-name&quot;;import { member1 , member2 } from &quot;module-name&quot;;import { member1 , member2 as alias2 , [...] } from &quot;module-name&quot;;import defaultMember, { member [ , [...] ] } from &quot;module-name&quot;;import defaultMember, * as name from &quot;module-name&quot;;import &quot;module-name&quot;;/* name－从将要导入模块中收到的导出值的名称 member, memberN－从导出模块，导入指定名称的多个成员 defaultMember－从导出模块，导入默认导出成员 alias, aliasN－别名，对指定导入成员进行的重命名 module-name－要导入的模块。是一个文件名 as－重命名导入成员名称（“标识符”） from－从已经存在的模块、脚本文件等导入*/ 命名式导入#花括号里面的变量与export后面的变量一一对应 12import {myMember} from &quot;my-module&quot;;import {foo, bar} from &quot;my-module&quot;; 通过*符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（’my-module.js’）所有的导出绑定内容，插入到当前模块（’myModule’）的作用域中： 1import * as myModule from &quot;my-module&quot;; 导入模块对象时，也可以使用as对导入成员重命名，以方便在当前模块内使用： 1import {reallyReallyLongModuleMemberName as shortName} from &quot;my-module&quot;; 导入多个成员时，同样可以使用别名： 1import {reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short} from &quot;my-module&quot;; 导入一个模块，但不进行任何绑定： 1import &quot;my-module&quot;; 默认导入#在模块导出时，可能会存在默认导出。同样的，在导入时可以使用import指令导出这些默认值。 直接导入默认值： 1import myDefault from &quot;my-module&quot;; 也可以在命名空间导入和名称导入中，同时使用默认导入： 123import myDefault, * as myModule from &quot;my-module&quot;; // myModule 做为命名空间使用//或import myDefault, {foo, bar} from &quot;my-module&quot;; // 指定成员导入 ES6中的 Module#概述#在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 12345678// CommonJS模块let { stat, exists, readfile } = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12// ES6模块import { stat, exists, readFile } from 'fs'; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 自动严格模式#ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 export 注意点#export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面代码输出变量foo，值为bar，500 毫秒之后变成baz。 import 注意点#提升#import命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import { foo } from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 表达式和变量#由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12345678910111213// 报错import { 'f' + 'oo' } from 'my_module';// 报错let module = 'my_module';import { foo } from module;// 报错if (x === 1) { import { foo } from 'module1';} else { import { foo } from 'module2';} 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 只加载，不执行#import语句会执行所加载的模块，因此可以有下面的写法。 1import 'lodash'; 上面代码仅仅执行lodash模块，但是不输入任何值。 单例模式#如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 12import 'lodash';import 'lodash'; 上面代码加载了两次lodash，但是只会执行一次。 12345import { foo } from 'my_module';import { bar } from 'my_module';// 等同于import { foo, bar } from 'my_module'; 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module模块。也就是说，import语句是 Singleton 模式。 与CommonJS/require混用时注意点#目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。 123require('core-js/modules/es6.symbol');require('core-js/modules/es6.promise');import React from 'React'; 整体加载#除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 1234567891011121314// circle.jsexport function area(radius) { return Math.PI * radius * radius;}export function circumference(radius) { return 2 * Math.PI * radius;}//main.jsimport * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); export default#12345678910111213// 第一组export default function crc32() { // 输出 // ...}import crc32 from 'crc32'; // 输入// 第二组export function crc32() { // 输出 // ...};import {crc32} from 'crc32'; // 输入 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 1234567891011121314151617181920212223242526272829// modules.jsfunction add(x, y) { return x * y;}export {add as default};// 等同于// export default add;// app.jsimport { default as foo } from 'modules';// 等同于// import foo from 'modules';// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1;// 正确export default 42;// 报错export 42; 上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。同样地，因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。 12345678910111213import _, { each, forEach } from 'lodash';//对应上面代码的export语句如下。export default function (obj) { // ···}export function each(obj, iterator, context) { // ···}export { each as forEach }; export 符合 import#1234567export { foo, bar } from 'my_module';// 可以简单理解为import { foo, bar } from 'my_module';export { foo, bar };export * from 'my_module'; 模块的集成#1234567// circleplus.jsexport * from 'circle'; //注意这里是exportexport var e = 2.71828182846;export default function(x) { return Math.exp(x);} 上面代码中的export *，表示输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 跨模块常量#1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import {A, B} from './constants';console.log(A); // 1console.log(B); // 3 回到es6 Module的初衷,当常量module.js文件非常大时，使用{}指明需要引用的内容，可以大大减少内存使用。 参考文档#123阮一峰教程","link":"/2021/02/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BCommonJs-AMD-CMD-UMD/"},{"title":"前端基础之JS基本","text":"很多时候都会想不起或者忽略这些基础概念。有空的时候还是得老老实实看一遍记一遍。 切勿眼高手低~ 组成 原始值和引用值 Undefined Null Boolean Number String 类型转换 转换成字符串 转换成数值 parseInt parseFloat 强制类型转换 引用类型 Object Boolean 对象 Number 对象 toFixed() 方法 toExponential() 方法 toPrecision() 方法 =&gt; 取N位有效数 String 对象 length charAt() 和 charCodeAt() 方法 es6 concat() 方法 indexOf() 和 lastIndexOf() 方法 localeCompare() 方法 slice() 和 substring() toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase() 提示 instanceof 运算符 等性运算符 等号(==)与非等号(!==) 全等号与非全等号 Function length属性 Function 对象 闭包 简单的闭包 复杂的闭包 对象类型 本地对象 内部对象 宿主对象 继承 对象冒充 对象冒充可以实现多重继承 call() apply() 原型链 混合 组成#JavaScript 由以下 3 个不同部分组成的： 核心（ECMAScript）: 描述js的语法和基本对象 文档对象模型（DOM）: 处理网页内容的方法和接口 浏览器对象模型（BOM）: 与浏览器进行交互的方法和接口 DOMDOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物 BOMIE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的标准。 BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括： 弹出新的浏览器窗口 移动、关闭浏览器窗口以及调整窗口大小 提供 Web 浏览器详细信息的定位对象 提供用户屏幕分辨率详细信息的屏幕对象 对 cookie 的支持 IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象 由于没有相关的 BOM 标准，每种浏览器都有自己的 BOM 实现。有一些事实上的标准，如具有一个窗口对象和一个导航对象，不过每种浏览器可以为这些对象或其他对象定义自己的属性和方法。 原始值和引用值#在 ECMAScript 中，变量可以存在两种类型的值，即原始值和引用值。 原始值存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。引用值存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的原始类型之一，即 Undefined、Null、Boolean、Number 和 String 型。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。 在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript 打破了这一传统。 如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 原始类型ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String。ECMA-262 把术语类型（type）定义为值的一个集合，每种原始类型定义了它包含的值的范围及其字面量表示形式。 ECMAScript 提供了 typeof 运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。 1234var sTemp = &quot;test string&quot;;alert (typeof sTemp); //输出 &quot;string&quot;alert (typeof 86); //输出 &quot;number&quot;console.log(typeof 1 == 'number') //true 对变量或值调用 typeof 运算符将返回下列值之一： undefined - 如果变量是 Undefined 类型的 boolean - 如果变量是 Boolean 类型的 number - 如果变量是 Number 类型的 string - 如果变量是 String 类型的 object - 如果变量是一种引用类型或 Null 类型的 NOTE注释：为什么 typeof 运算符对于 null 值会返回 &quot;Object&quot;。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。 Undefined# 当声明的变量未初始化时，该变量的默认值是 undefined。 当函数无明确返回值时，返回的也是值 “undefined”123456789var oTemp;alert(typeof oTemp); //输出 &quot;undefined&quot;alert(typeof oTemp2); //输出 &quot;undefined&quot;function testFunc() {}alert(testFunc() == undefined); //输出 &quot;true&quot; 前面的代码对两个变量输出的都是 “undefined”，即使只有变量 oTemp2 从未被声明过。如果对 oTemp2 使用除 typeof 之外的其他运算符的话，会引起错误，因为其他运算符只能用于已声明的变量上。 Null#另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。 尽管这两个值相等，但它们的含义不同: undefined 是声明了变量但未对其初始化时赋予该变量的值， null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。1alert(null == undefined); //输出 &quot;true&quot; Boolean#Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。 即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的。 12var bFound = true;var bLost = false; Number#ECMA-262 中定义的最特殊的类型是 Number 类型。这种类型既可以表示32 位的整数，还可以表示64 位的浮点数。 直接输入的（而不是从另一个变量访问的）任何数字都被看做 Number 类型的字面量。 八进制数和十六进制数 整数也可以被表示为八进制（以 8 为底）或十六进制（以 16 为底）的字面量。八进制字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7） 十六进制的字面量，首位数字必须为 0，后面接字母 x，然后是任意的十六进制数字（0 到 9 和 A 到 F）。这些字母可以是大写的，也可以是小写的 浮点数要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量对于浮点字面量的有趣之处在于，用它进行计算前，真正存储的是字符串。 科学计数法对于非常大或非常小的数，可以用科学计数法表示浮点数，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数 特殊的 Number 值 Number.MAX_VALUE 和 Number.MIN_VALUE Number.POSITIVE_INFINITY 和 Number.NEGATIVE_INFINITY Infinity NaN 当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 Number.MIN_VALUE 的计算也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。 事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。Number.POSITIVE_INFINITY 的值为 Infinity。Number.NEGATIVE_INFINITY 的值为 -Infinity。 由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用 isFinite() 方法，以确保该数不是无穷大 NaN 是个奇怪的特殊值。一般说来，这种情况发生在类型（String、Boolean 等）转换失败时。例如，要把单词 blue 转换成数值就会失败，因为没有与之等价的数值。与无穷大一样，NaN 也不能用于算术计算。NaN 的另一个奇特之处在于，它与自身不相等，这意味着下面的代码将返回 false 1234alert(NaN == NaN); //输出 &quot;false&quot;//不推荐使用 NaN 值本身。函数 isNaN() 会做得相当好：alert(isNaN(&quot;blue&quot;)); //输出 &quot;true&quot;alert(isNaN(&quot;666&quot;)); //输出 &quot;false&quot; String#String 类型的独特之处在于，它是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种国际字符集，本教程后面将讨论它）。 字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1： 字符串字面量是由双引号（”）或单引号（’）声明的。而 Java 则是用双引号声明字符串，用单引号声明字符。但是由于 ECMAScript 没有字符类型，所以可使用这两种表示法中的任何一种 类型转换#转换成字符串#Boolean 值、数字和字符串的原始值的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。Number 类型的 toString() 方法比较特殊，它有两种模式，即默认模式和基模式。采用默认模式，toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）在默认模式中，无论最初采用什么表示法声明数字，Number 类型的 toString() 方法返回的都是数字的十进制表示。因此，以八进制或十六进制字面量形式声明的数字输出的都是十进制形式的.采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。 1234567891011121314var sColor = &quot;red&quot;;alert(sColor.length); //输出 &quot;3&quot;var bFound = false;alert(bFound.toString()); //输出 &quot;false&quot;//默认模式var iNum1 = 10;var iNum2 = 10.0;alert(iNum1.toString()); //输出 &quot;10&quot;alert(iNum2.toString()); //输出 &quot;10&quot;//基模式var iNum = 10;alert(iNum.toString(2)); //输出 &quot;1010&quot;alert(iNum.toString(8)); //输出 &quot;12&quot;alert(iNum.toString(16)); //输出 &quot;A&quot; 转换成数值# parseInt parseFloat 前者把值转换成整数，后者把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。 parseInt#1234var iNum1 = parseInt(&quot;12345red&quot;); //返回 12345var iNum1 = parseInt(&quot;0xA&quot;); //返回 10var iNum1 = parseInt(&quot;56.9&quot;); //返回 56var iNum1 = parseInt(&quot;red&quot;); //返回 NaN parseInt() 方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。 12345678var iNum1 = parseInt(&quot;AF&quot;, 16); //返回 175var iNum1 = parseInt(&quot;10&quot;, 2); //返回 2var iNum2 = parseInt(&quot;10&quot;, 8); //返回 8var iNum3 = parseInt(&quot;10&quot;, 10); //返回 10//如果十进制数包含前导 0，那么最好采用基数 10，这样才不会意外地得到八进制的值var iNum1 = parseInt(&quot;010&quot;); //返回 8var iNum2 = parseInt(&quot;010&quot;, 8); //返回 8var iNum3 = parseInt(&quot;010&quot;, 10); //返回 10 parseFloat#parseFloat() 方法与 parseInt() 方法的处理方式相似，从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数。 不过，对于这个方法来说，第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。parseFloat() 会把这个小数点之前的字符转换成数字。这意味着字符串 &quot;11.22.33&quot; 将被解析成 11.22。 使用 parseFloat() 方法的另一不同之处在于，字符串必须以十进制形式表示浮点数，而不是用八进制或十六进制。该方法会忽略前导 0，所以八进制数 0102 将被解析为 102。对于十六进制数 0xA，该方法将返回 NaN，因为在浮点数中，x 不是有效字符。（注释：经测试，具体的浏览器实现会返回 0，而不是 NaN。） 此外，parseFloat() 方法也没有基模式。 12345678var fNum1 = parseFloat(&quot;12345red&quot;); //返回 12345var fNum2 = parseFloat(&quot;0xA&quot;); //返回 NaNvar fNum3 = parseFloat(&quot;11.2&quot;); //返回 11.2var fNum4 = parseFloat(&quot;11.22.33&quot;); //返回 11.22var fNum5 = parseFloat(&quot;0102&quot;); //返回 102var fNum6 = parseFloat(&quot;red&quot;); //返回 NaNvar fNum7 = parseFloat(&quot;abc.123&quot;); //返回 NaNvar fNum7 = parseFloat(&quot;.123abc&quot;); //返回 0.123 强制类型转换#ECMAScript 中可用的 3 种强制类型转换如下： Boolean(value) - 把给定的值转换成 Boolean 型； Number(value) - 把给定的值转换成数字（可以是整数或浮点数）； String(value) - 把给定的值转换成字符串；用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。 Boolean() 函数当要转换的值是至少有一个字符的字符串、非 0 数字或对象时，Boolean() 函数将返回 true。如果该值是空字符串、数字 0、undefined 或 null，它将返回 false。 123456var b1 = Boolean(&quot;&quot;); //false - 空字符串var b2 = Boolean(&quot;hello&quot;); //true - 非空字符串var b1 = Boolean(50); //true - 非零数字var b1 = Boolean(null); //false - nullvar b1 = Boolean(0); //false - 零var b1 = Boolean(new object()); //true - 对象 Number() 函数Number() 函数的强制类型转换与 parseInt() 和 parseFloat() 方法的处理方式相似，只是它转换的是整个值，而不是部分值。 还记得吗，parseInt() 和 parseFloat() 方法只转换第一个无效字符之前的字符串，因此 “1.2.3” 将分别被转换为 “1” 和 “1.2”。 用 Number() 进行强制类型转换，&quot;1.2.3&quot; 将返回 NaN，因为整个字符串值不能转换成数字。如果字符串值能被完整地转换，Number() 将判断是调用 parseInt() 方法还是 parseFloat() 方法。 123456789Number(false) // 0Number(true) // 1Number(undefined) // NaNNumber(null) // 0Number(&quot;1.2&quot;) // 1.2Number(&quot;12&quot;) // 12Number(&quot;1.2.3&quot;) // NaNNumber(new object()) // NaNNumber(50) // 50 String() 函数最后一种强制类型转换方法 String() 是最简单的，因为它可把任何值转换成字符串。 要执行这种强制类型转换，只需要调用作为参数传递进来的值的 toString() 方法，即把 12 转换成 “12”，把 true 转换成 “true”，把 false 转换成 “false”，以此类推。 强制转换成字符串和调用 toString() 方法的唯一不同之处在于，对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误： 123var s1 = String(null); //&quot;null&quot;var oNull = null;var s2 = oNull.toString(); //会引发错误 引用类型#Object#123let obj = new Object() //同let obj = new Object //为了避免混淆，尽量加上括号 Object 对象具有下列属性： constructor对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。 Prototype对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。 Object 对象还具有下列方法： hasOwnProperty(property)判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，o.hasOwnProperty(“name”)） IsPrototypeOf(object)判断该对象是否为另一个对象的原型。 PropertyIsEnumerable()判断给定的属性是否可以用 for…in 语句进行枚举。 ToString()返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。 ValueOf()返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。 注释：上面列出的每种属性和方法都会被其他对象覆盖。 Boolean 对象#Boolean 对象是 Boolean 原始类型的引用类型。 要创建 Boolean 对象，只需要传递 Boolean 值作为参数： 1var oBooleanObject = new Boolean(true); Number 对象#正如你可能想到的，Number 对象是 Number 原始类型的引用类型。要创建 Number 对象，采用下列代码： 1var oNumberObject = new Number(68); 您应该已认出本章前面小节中讨论特殊值（如 Number.MAX_VALUE）时提到的 Number 对象。所有特殊值都是 Number 对象的静态属性。 要得到数字对象的 Number 原始值，只需要使用 valueOf() 方法： 1var iNumber = oNumberObject.valueOf(); toFixed() 方法#toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toFixed(2)); //输出 &quot;68.00&quot; toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误 toExponential() 方法#与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。 与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toExponential(1)); //输出 &quot;6.8e+1&quot; 这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x10¹。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。 toPrecision() 方法 =&gt; 取N位有效数#toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如， 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(1)); //输出 &quot;7e+1&quot; 这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了： 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(2)); //输出 &quot;68&quot; 当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？ 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(3)); //输出 &quot;68.0&quot; 在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。 toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数。 提示：与 Boolean 对象相似，Number 对象也很重要，不过应该少用这种对象，以避免潜在的问题。只要可能，都使用数字的原始表示法。 String 对象#String 对象是 String 原始类型的对象表示法，它是以下方式创建的： 1var oStringObject = new String(&quot;hello world&quot;); length#String 对象具有属性 length，它是字符串中的字符个数： 123var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.length); //输出 &quot;11&quot;alert('龍'.length) // 1 这个例子输出的是 “11”，即 “hello world” 中的字符个数。注意，即使字符串包含双字节的字符（与 ASCII 字符相对，ASCII 字符只占用一个字节），每个字符也只算一个字符。 charAt() 和 charCodeAt() 方法#首先，两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。 charAt() 方法返回的是包含指定位置处的字符的字符串： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charAt(1)); //输出 &quot;e&quot; 在字符串 “hello world” 中，位置 1 处的字符是 “e”。在“ECMAScript 原始类型”这一节中我们讲过，第一个字符的位置是 0，第二个字符的位置是 1，依此类推。因此，调用 charAt(1) 返回的是 “e”。 如果想得到的不是字符，而是字符代码，那么可以调用 charCodeAt() 方法： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charCodeAt(1)); //输出 &quot;101&quot; 这个例子输出 “101”，即小写字母 “e” 的字符代码。 es6#es6中字符串追加了unicode的支持遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 123456789101112let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) { console.log(text[i]);}// &quot; &quot;// &quot; &quot;for (let i of text) { console.log(i);}// &quot;𠮷&quot; concat() 方法#用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，保持原始的 String 对象不变： 1234var oStringObject = new String(&quot;hello &quot;);var sResult = oStringObject.concat(&quot;world&quot;);alert(sResult); //输出 &quot;hello world&quot;alert(oStringObject); //输出 &quot;hello &quot; indexOf() 和 lastIndexOf() 方法#1234var oStringObject = new String(&quot;hello world!&quot;);alert(oStringObject.indexOf(&quot;o&quot;)); 输出 &quot;4&quot;alert(oStringObject.lastIndexOf(&quot;o&quot;)); 输出 &quot;7&quot;alert(oStringObject.lastIndexOf(&quot;orl&quot;)); 输出 &quot;7&quot; localeCompare() 方法#下一个方法是 localeCompare()，对字符串进行排序。该方法有一个参数 - 要进行比较的字符串，返回的是下列三个值之一： 如果 String 对象按照字母顺序排在参数中的字符串之前，返回负数。 如果 String 对象等于参数中的字符串，返回 0 如果 String 对象按照字母顺序排在参数中的字符串之后，返回正数。 注释：如果返回负数，那么最常见的是 -1，不过真正返回的是由实现决定的。如果返回正数，那么同样的，最常见的是 1，不过真正返回的是由实现决定的。localeCompare() 方法的独特之处在于，实现所处的区域（locale，兼指国家/地区和语言）确切说明了这种方法运行的方式。在美国，英语是 ECMAScript 实现的标准语言，localeCompare() 是区分大小写的，大写字母在字母顺序上排在小写字母之后。不过，在其他区域，情况可能并非如此。示例如下： 1234var oStringObject = new String(&quot;yellow&quot;);alert(oStringObject.localeCompare(&quot;brick&quot;)); //输出 &quot;1&quot;alert(oStringObject.localeCompare(&quot;yellow&quot;)); //输出 &quot;0&quot;alert(oStringObject.localeCompare(&quot;zoo&quot;)); //输出 &quot;-1&quot; slice() 和 substring()#ECMAScript 提供了两种方法从子串创建字符串值，即 slice() 和 substring()。这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。如果省略第二个参数，终止位就默认为字符串的长度。 与 concat() 方法一样，slice() 和 substring() 方法都不改变 String 对象自身的值。它们只返回原始的 String 值，保持 String 对象不变。 12345var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.slice(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.substring(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.slice(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot;alert(oStringObject.substring(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot; 在这个例子中，slice() 和 substring() 的用法相同，返回值也一样。当只有参数 3 时，两个方法返回的都是 “lo world”，因为 “hello” 中的第二个 “l” 位于位置 3 上。当有两个参数 “3” 和 “7” 时，两个方法返回的值都是 “lo w”（”world” 中的字母 “o” 位于位置 7 上，所以它不包括在结果中）。 为什么有两个功能完全相同的方法呢？事实上，这两个方法并不完全相同，不过只在参数为负数时，它们处理参数的方式才稍有不同。 对于负数参数，slice() 方法会用字符串的长度加上参数，substring() 方法则将其作为 0 处理（也就是说将忽略它）。例如： 12345var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.slice(&quot;-3&quot;)); //输出 &quot;rld&quot;alert(oStringObject.substring(&quot;-3&quot;)); //输出 &quot;hello world&quot;alert(oStringObject.slice(&quot;3, -4&quot;)); //输出 &quot;lo w&quot;alert(oStringObject.substring(&quot;3, -4&quot;)); //输出 &quot;hel&quot; 这样即可看出 slice() 和 substring() 方法的主要不同。 当只有参数 -3 时，slice() 返回 “rld”，substring() 则返回 “hello world”。这是因为对于字符串 “hello world”，slice(“-3”) 将被转换成 slice(“8”)，而 substring(“-3”) 将被转换成 substring(“0”)。 同样，使用参数 3 和 -4 时，差别也很明显。slice() 将被转换成 slice(3, 7)，与前面的例子相同，返回 “lo w”。而 substring() 方法则将两个参数解释为 substring(3, 0)，实际上即 substring(0, 3)，因为 substring() 总把较小的数字作为起始位，较大的数字作为终止位。因此，substring(“3, -4”) 返回的是 “hel”。这里的最后一行代码用来说明如何使用这些方法。 toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()#最后一套要讨论的方法涉及大小写转换。有 4 种方法用于执行大小写转换，即 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 一般来说，如果不知道在以哪种编码运行一种语言，则使用区域特定的方法比较安全。 提示#记住，String 对象的所有属性和方法都可应用于 String 原始值上，因为它们是伪对象。 instanceof 运算符#在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject instanceof String); //输出 &quot;true&quot; 这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是 “true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。 等性运算符#等号(==)与非等号(!==)#执行类型转换的规则如下： 如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 在比较时，该运算符还遵守下列规则： 值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 1234567891011null == undefined //true&quot;NaN&quot; == NaN //false5 == NaN //falseNaN == NaN //falseNaN != NaN //truefalse == 0 //truetrue == 1 //truetrue == 2 //falseundefined == 0 //falsenull == 0 //false&quot;5&quot; == 5 //true 全等号与非全等号#这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 12345var sNum = &quot;66&quot;;var iNum = 66;alert(sNum == iNum); //输出 &quot;true&quot;alert(sNum === iNum); //输出 &quot;false&quot;alert(sNum !== iNum); //输出 &quot;true&quot; Function#length属性#ECMAScript 定义的属性 length 声明了函数期望的参数个数。例如： 12345678910function doAdd(iNum) { alert(iNum + 10);}function sayHi() { alert(&quot;Hi&quot;);}alert(doAdd.length); //输出 &quot;1&quot;alert(sayHi.length); //输出 &quot;0&quot; Function 对象#有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。例如： 12345function doAdd(iNum) { alert(iNum + 10);}document.write(doAdd.toString()); 闭包#闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。 简单的闭包#1234567var sMessage = &quot;hello world&quot;;function sayHelloWorld() { alert(sMessage);}sayHelloWorld(); 在上面这段代码中，脚本被载入内存后，并没有为函数 sayHelloWorld() 计算变量 sMessage 的值。该函数捕获 sMessage 的值只是为了以后的使用，也就是说，解释程序知道在调用该函数时要检查 sMessage 的值。sMessage 将在函数调用 sayHelloWorld() 时（最后一行）被赋值，显示消息 “hello world”。 复杂的闭包#12345678var iBaseNum = 10;function addNum(iNum1, iNum2) { function doAdd() { return iNum1 + iNum2 + iBaseNum; } return doAdd();} 这里，函数 addNum() 包括函数 doAdd() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 iNum1 和 iNum2 以及全局变量 iBaseNum 的值。 addNum() 的最后一步调用了 doAdd()，把两个参数和全局变量相加，并返回它们的和。 这里要掌握的重要概念是，doAdd() 函数根本不接受参数，它使用的值是从执行环境中获取的。 对象类型#本地对象# Object Function Array String Boolean Number Date RegExp Error EvalError RangeError ReferenceError SyntaxError TypeError URIError 内部对象#即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。 宿主对象#所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。 所有 BOM 和 DOM 对象都是宿主对象。 继承#要用 ECMAScript 实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可作为基类。出于安全原因，本地类和宿主类不能作为基类，这样可以防止公用访问编译过的浏览器级的代码，因为这些代码可以被用于恶意攻击。 对象冒充#构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 ClassA 构造函数成为 ClassB 的方法，然后调用它。ClassB 就会收到 ClassA 的构造函数中定义的属性和方法。例如，用下面的方式定义 ClassA 和 ClassB： 123456789101112function ClassA(sColor) { this.color = sColor; this.sayColor = function () { alert(this.color); };}function ClassB(sColor) { this.newMethod = ClassA; this.newMethod(sColor); delete this.newMethod;} 在这段代码中，为 ClassA 赋予了方法 newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是 ClassB 构造函数的参数 sColor。最后一行代码删除了对 ClassA 的引用，这样以后就不能再调用它。 所有新属性和新方法都必须在删除了新方法的代码行后定义。否则，可能会覆盖超类的相关属性和方法： 12345678910111213141516function ClassB(sColor, sName) { this.newMethod = ClassA; this.newMethod(sColor); delete this.newMethod; this.name = sName; this.sayName = function () { alert(this.name); };}var objA = new ClassA(&quot;blue&quot;);var objB = new ClassB(&quot;red&quot;, &quot;John&quot;);objA.sayColor(); //输出 &quot;blue&quot;objB.sayColor(); //输出 &quot;red&quot;objB.sayName(); //输出 &quot;John&quot; 对象冒充可以实现多重继承#123456789function ClassZ() { this.newMethod = ClassX; this.newMethod(); delete this.newMethod; this.newMethod = ClassY; this.newMethod(); delete this.newMethod;} 这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法，ClassY 具有高优先级。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。 由于这种继承方法的流行，ECMAScript 的第三版为 Function 对象加入了两个方法，即 call() 和 apply()。 call()#call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如： 12345678function sayColor(sPrefix,sSuffix) { alert(sPrefix + this.color + sSuffix);};var obj = new Object();obj.color = &quot;blue&quot;;sayColor.call(obj, &quot;The color is &quot;, &quot;a very nice color indeed.&quot;); 在这个例子中，函数 sayColor() 在对象外定义，即使它不属于任何对象，也可以引用关键字 this。对象 obj 的 color 属性等于 blue。调用 call() 方法时，第一个参数是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个和第三个参数是字符串。它们与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息 “The color is blue, a very nice color indeed.” 将被显示出来。 要与继承机制的对象冒充方法一起使用该方法，只需将前三行的赋值、调用和删除代码替换即可： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.call(this, sColor); this.name = sName; this.sayName = function () { alert(this.name); };} 这里，我们需要让 ClassA 中的关键字 this 等于新创建的 ClassB 对象，因此 this 是第一个参数。第二个参数 sColor 对两个类来说都是唯一的参数。 apply()#apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如： 12345678function sayColor(sPrefix,sSuffix) { alert(sPrefix + this.color + sSuffix);};var obj = new Object();obj.color = &quot;blue&quot;;sayColor.apply(obj, new Array(&quot;The color is &quot;, &quot;a very nice color indeed.&quot;)); 这个例子与前面的例子相同，只是现在调用的是 apply() 方法。调用 apply() 方法时，第一个参数仍是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个参数是由两个字符串构成的数组，与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息仍是 “The color is blue, a very nice color indeed.”，将被显示出来。 该方法也用于替换前三行的赋值、调用和删除新方法的代码： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.apply(this, new Array(sColor)); this.name = sName; this.sayName = function () { alert(this.name); };} 同样的，第一个参数仍是 this，第二个参数是只有一个值 color 的数组。可以把 ClassB 的整个 arguments 对象作为第二个参数传递给 apply() 方法： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.apply(this, arguments); this.name = sName; this.sayName = function () { alert(this.name); };} 当然，只有超类中的参数顺序与子类中的参数顺序完全一致时才可以传递参数对象。如果不是，就必须创建一个单独的数组，按照正确的顺序放置参数。此外，还可使用 call() 方法。 原型链#prototype 对象是个模板，要实例化的对象都以这个模板为基础。总而言之，prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。 123456789101112131415function ClassA() {}ClassA.prototype.color = &quot;blue&quot;;ClassA.prototype.sayColor = function () { alert(this.color);};function ClassB() {}ClassB.prototype = new ClassA(); //mark /*这里，把 ClassB 的 prototype 属性设置成 ClassA 的实例。这很有意思，因为想要 ClassA 的所有属性和方法，但又不想逐个将它们 ClassB 的 prototype 属性。还有比把 ClassA 的实例赋予 prototype 属性更好的方法吗？*/ 注意： 调用 ClassA 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。 子类的所有属性和方法都必须出现在 prototype 属性被赋值后，因为在它之前赋值的所有方法都会被删除。为什么？因为 prototype 属性被替换成了新对象，添加了新方法的原始对象将被销毁。所以，为 ClassB 类添加 name 属性和 sayName() 方法的代码如下：123456789function ClassB() {}ClassB.prototype = new ClassA();ClassB.prototype.name = &quot;&quot;;ClassB.prototype.sayName = function () { alert(this.name);}; 混合#对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。开发者如何选择呢？答案很简单，两者都用。创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制，用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法.12345678910111213141516171819202122232425function ClassA(sColor) { this.color = sColor;}ClassA.prototype.sayColor = function () { alert(this.color);};function ClassB(sColor, sName) { ClassA.call(this, sColor); //对象冒用 this.name = sName; //构造函数定义属性}ClassB.prototype = new ClassA(); //原型链继承//继承后定义新的方法ClassB.prototype.sayName = function () { alert(this.name);};var objA = new ClassA(&quot;blue&quot;);var objB = new ClassB(&quot;red&quot;, &quot;John&quot;);objA.sayColor(); //输出 &quot;blue&quot;objB.sayColor(); //输出 &quot;red&quot;objB.sayName(); //输出 &quot;John&quot;","link":"/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"RN","slug":"RN","link":"/tags/RN/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"sentry","slug":"sentry","link":"/tags/sentry/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"fabric.js","slug":"fabric-js","link":"/tags/fabric-js/"}],"categories":[{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"建站","slug":"建站","link":"/categories/%E5%BB%BA%E7%AB%99/"},{"name":"APP","slug":"APP","link":"/categories/APP/"},{"name":"运维","slug":"运维","link":"/categories/%E8%BF%90%E7%BB%B4/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"Midway","slug":"Midway","link":"/categories/Midway/"},{"name":"前端基础","slug":"前端基础","link":"/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"前端进阶","slug":"前端进阶","link":"/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"canvas","slug":"canvas","link":"/categories/canvas/"}]}