{"pages":[{"title":"CV","text":"Thetiso 教育背景#技术栈#项目经验#","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start#Create a new post#1$ hexo new &quot;My New Post&quot; More info: Writing Run server#1$ hexo server More info: Server Generate static files#1$ hexo generate More info: Generating Deploy to remote sites#1$ hexo deploy More info: Deployment","link":"/2020/10/30/hello-world/"},{"title":"build Blog-site by Hexo","text":"记录使用hexo搭建github博客的过程(mac) 准备# node npm github账号 START# 全局安装hexo12$ npm i hexo -g$ hexo init Blog 在此site选择hexo的主题，默认主题landscape。很多主题都比较陈旧，坚持维护的不多，我选择的是icarus. 安装icarus123//Blog根目录$ npm install hexo-theme-icarus$ hexo config theme icarus 启动服务12345$ npm i$ hexo s//实际运行可能会报错并提示有部分组件未安装，按照提示安装即可//浏览器地址`localhost:4000`预览//若端口占用，可使用`lsof -i:4000`查看进程，配合`kill -9 ${pid}`指令清除进程 写作#创建分类#12//Blog根目录$ hexo n page categories 打开生成的index.md文件，修改如下 12345---title: categoriesdate: 2020-10-30 10:42:43type: &quot;categories&quot;--- 而后在任意文章顶部标记新的分类名称即可 123456---title: Hexo建站date: 2020-10-30 10:41:03categories:- 建站--- 创建标签#与创建分类同理 12//Blog根目录$ hexo n page tags 打开生成的index.md文件，修改如下 12345---title: tagsdate: 2020-10-30 10:42:43type: &quot;tags&quot;--- 而后在任意文章顶部标记新的分类名称即可 123456---title: Hexo建站date: 2020-10-30 10:41:03tags:- hexo--- 引用图片#在配置文件中允许使用资源文件 1post_aeest_folder: true 在文章中引用的方式参考链接注意: 上述配置对已经创建的文章不会生效，需要重新hexo n XXX才会在_post文件夹下创建同名的资源文件夹，直接将要用的图片丢进去就OK啦 1{% asset_img avatar.jpg %} 如下图 部署#hexo官方提供了配合Travis CI的github pages部署教程， 但是流程实在太长，对新手不友好，推荐使用懒人一键部署 1$ npm install hexo-deployer-git --save 修改_config.yml配置文件,注意同名文件可能有好几个，改的是本目录下的文件 12345deploy: type: 'git' repo: 'https://github.com/xxx/xxx.github.io' branch: master message: 'init' 一键部署 1$ hexo clean &amp;&amp; hexo deploy 其他#markdown语法#折叠#12345&lt;details&gt;&lt;summary&gt;Title&lt;/summary&gt;content!!!&lt;/details&gt; 折叠示例如下 Title content!!! 标注#这是要标注的地方^脚注1，注脚后的冒号请注意，它也是一部分 1234这是要标注的地方[^脚注1]。[^脚注1]: 巴拉巴拉.. 配置主题icarus#bash12$ npm install hexo-theme-icarus$ hexo config theme icarus 如果需要更加个性化定制/修改css等，就需要使用git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus的方式直接导入源码。当然直接下载源码扔到对应文件夹也是OK的，记得去掉git相关文件就行。 开启busuanzi访问统计#_config.icarus.yml &gt; plugins &gt; busuanzi: true即可，记得重新运行hexo,可以在审查元素中查看是否拉取busuanzi.js即可。更加具体的解释和配置可以看这个文章 链接","link":"/2020/10/30/hexo-site/"},{"title":"nginx静态网站优化","text":"本文初略介绍针对静态网站的nginx优化 参考文章一参考文章一 设置nginx配置文件#sh123456789101112131415161718192021server { listen 80; server_name xxx.com gzip on; #开启或关闭gzip on off gzip_static on; gzip_disable &quot;msie6&quot;; #不使用gzip IE6 gzip_min_length 1024; #gzip压缩最小文件大小，超出进行压缩（自行调节） gzip_buffers 4 16k; #buffer 不用修改 gzip_comp_level 8; #压缩级别:1-10，数字越大压缩的越好，时间也越长 gzip_types application/javascript text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; location / { try_files $uri $uri/ /index.html; root /your/site/path/from/root; index index.html; expires 24h; #静态文件缓存时间 }} 请务必核对gzip_types, 本人之前一般js文件是text/javascript格式，导致页面上加载js时，速度极其缓慢 gzip_min_length可以适当设置的小一点 expires 可以大幅度加快文件的读取速度，当然弊端就是遇到更新会触发缓存，自行斟酌。 try_files 是针对vue spa静态站点的设置，为了使浏览器输入具体url时能直达页面，而不是只能看到首页 PS#谨防 HSTS#参考文章 HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。服务器开启HSTS的方法是，当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议响应头中包含Strict-Transport-Security字段。非加密传输时设置的HSTS字段无效。 比如，https://www.liberalman.cn 的响应头含有Strict-Transport-Security: max-age=31536000; includeSubDomains。这意味着两点：在接下来的一年（即31536000秒）中，浏览器只要向xxx或其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如，用户点击超链接或在地址栏输入 http://www.liberalman.cn/ ，浏览器应当自动将 http 转写成 https，然后直接向 https://www.liberalman.cn/ 发送请求。 在接下来的一年中，如果 www.liberalman.cn 服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。 服务器端配置HSTS，减少302跳转，其实HSTS的最大作用是防止302 HTTP劫持。HSTS的缺点是浏览器支持率不高，另外配置HSTS后HTTPS很难实时降级成HTTP。同时，也建议启用SPDY来提高性能，不累述。","link":"/2020/12/10/nginx%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96/"},{"title":"RN项目笔记(基础篇)","text":"本文主要记录在写rn项目过程中的一些要点。 …尴尬，其中使用UI框架为ant-d, 但是其listview在上拉加载的时候无法触发fetch, github上维护看着也不积极。已准备弃用 1. 基础样式 1.1 常用属性 2. 使用要点 2.1 设置本文自动省略 2.2 对文本设置圆角 2.3 文本元素长度auto,不跟随父元素(不超过父元素长度时) 2.4 为Text/View添加点击事件 3. 杂记(开发中遇到的问题) 1. 如何使用熟悉的js中class来设置样式 2. icon框架 react-native-vector-icons ant-ui有多个版本,请务必仔细核对自己的版本是否正确。本文对应的ui框架网站为官网、文档 2020.12.11 目前是混合使用ant和elements框架 1. 基础样式#参考文章 js12345678910111213141516171819202122232425export default class App extends Component&lt;Props&gt; { render() { return ( &lt;View style={styles.container}&gt; &lt;Text style={{color: 'red'}}&gt;I Love React Native!&lt;/Text&gt; &lt;Text style={[styles.fs14, styles.red]}&gt;two styles in array!&lt;/Text&gt; &lt;/View&gt; ); }, }const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', }, fs14: { fontSize: 14 }, red: { color: 'red' }}); 设定组件/子元素的样式有两种方式： 直接行内设置 通过StyleSheet 需要注意的是， 通过StyleSheet设置的时候，只有一对大括号，而行内需要两对; 当一个元素的样式被分拆成多个时，需要用数组形式 1.1 常用属性#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960width //宽height //高backgroundColoropacity //透明度//边框圆角设置borderTopLeftRadius //左上角圆角borderTopRightRadius //右上角的圆角borderBottomLeftRadius //左下角的圆角borderBottomRightRadius //右下角的圆角borderRadius //所有角的圆角//边框宽度borderLeftWidth //左边边框宽度borderRightWidth //右边边框宽度borderTopWidth //顶部边框宽度borderBottomWidth //底部边框宽度borderWidth //所有边框宽度//边框颜色borderColor //边框颜色marginBottom //距下外边距marginLeft //距左外边距marginRight //距右外边距marginTop //距上外边距marginVertical //垂直外边距(也就是距上,距下边距)marginHorizontal //水平外边距(距左,距右边距)margin //所有边距paddingBottom //距下内边距paddingLeft //距左内边距paddingRight //距右内边距paddingTop //距上内边距paddingVertical//垂直内边距paddingHorizontal //水平内边距padding //所有内边距//图像变换ImagescaleX //水平方向缩放scaleY //垂直方向缩放rotation //旋转translateX //水平方向平移translateY //水平方向平移resizemode //拉伸图片 'cover' ,'strech','contain'//文本Textcolor //文字颜色textAlign //对其方式 ('left','right','auto','center','justify')fontSize //字体大小fontStyle //字体风格 正常:'normal', 斜体:'italic'fontWeight //字体粗细 加粗:'bold', '100', '200' letterSpacing //字符间距lineHeight //行间距textDecorationLine //字体装饰线 下划线:'underline', 删除线:'line-through',下划线删除线:'underline line-through'textDecorationStyle //字体装饰线风格 单线:'solid' 双线:'double' 虚线:'dotted','dashed'textDecorationColor //字体装饰线颜色 2. 使用要点#2.1 设置本文自动省略#Text在设置了文本之后会在到达width的位置自动截断，如果需要设置以省略号...结尾的话需要在行内设置参数 1&lt;Text numberOfLines={1}&gt;我是文本&lt;/Text&gt; 2.2 对文本设置圆角#ios下无法通过给Text设置Radius来设置圆角，需要通过外部加一层View元素设置圆角 12345&lt;View style={{borderRadius: 2}}&gt; &lt;Text style={{height: 20, backgroundColor: '#0c3', color: '#fff'}}&gt; 本文 &lt;/Text&gt;&lt;/View&gt; 2.3 文本元素长度auto,不跟随父元素(不超过父元素长度时)#js1234&lt;View style={{width: 200, flexDirection: 'column'}}&gt; &lt;View style={{width: 100}}&gt;&lt;/View&gt; &lt;Text style={{backgroundColor: 'red'}}&gt;这是文本&lt;/Text&gt;&lt;/View&gt; 上述代码中，从背景色可以发现text元素始终长度和父元素保持一致。此时，如果需要设置Text的长度根据文本来动态变化，则可以通过position来处理.修改后的代码如下： 12345678&lt;View style={{width: 200, flexDirection: 'column'}}&gt; &lt;View style={{width: 100}}&gt;&lt;/View&gt; &lt;View&gt; &lt;View style={{position: 'absolute', borderRadius: 5}}&gt; &lt;Text style={{backgroundColor: 'red'}}&gt;这是文本&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt;&lt;/View&gt; 2.4 为Text/View添加点击事件#12345678import {TouchableHighlight} from 'react-native';... &lt;TouchableHighlight onPress={this.submit}&gt; &lt;View&gt; &lt;Text&gt;文本 &lt;/View&gt;&lt;/TouchableHighlight&gt; 需要注意的是，TouchableHighlight的子元素只能是一个。 3. 杂记(开发中遇到的问题)#1. 如何使用熟悉的js中class来设置样式#2. icon框架 react-native-vector-icons#123yarn add react-native-vector-iconscd iospod install 如果遇到Unrecognized font family 'Material Icons'报错，则需要修改info.plist 123456789101112131415161718&lt;key&gt;UIAppFonts&lt;/key&gt;&lt;array&gt;&lt;string&gt;AntDesign.ttf&lt;/string&gt;&lt;string&gt;Entypo.ttf&lt;/string&gt;&lt;string&gt;EvilIcons.ttf&lt;/string&gt;&lt;string&gt;Feather.ttf&lt;/string&gt;&lt;string&gt;FontAwesome.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Brands.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Regular.ttf&lt;/string&gt;&lt;string&gt;FontAwesome5_Solid.ttf&lt;/string&gt;&lt;string&gt;Foundation.ttf&lt;/string&gt;&lt;string&gt;Ionicons.ttf&lt;/string&gt;&lt;string&gt;MaterialIcons.ttf&lt;/string&gt;&lt;string&gt;MaterialCommunityIcons.ttf&lt;/string&gt;&lt;string&gt;SimpleLineIcons.ttf&lt;/string&gt;&lt;string&gt;Octicons.ttf&lt;/string&gt;&lt;string&gt;Zocial.ttf&lt;/string&gt;&lt;/array&gt; 参考文章icon列表从上面的报错也可以知道此框架默认的Icon类别为Material,列表一览列表中的icon名称如果包含下划线，请记得改为短横：_ 改为 -, 貌似是某个版本改过命名规则。","link":"/2020/12/01/rn-ant-ui/"},{"title":"React Native APP开发(1)","text":"采用RN开发APP准备篇 准备工作# RN的准备工作请参考官方教程 UI框架选择的是蚂蚁那套Ant-UI MARK# 度娘能找到的rn教程很多不注明版本号，盲目使用其中的解决方案容易导致项目长跪不起，所以再不确定其版本号的情况下，请尽量使用最新的解决方案 ant-ui分别有对应react和rn的两套版本,请注意区分 引用ant-ui需要在xcode中引用对应的tff文件，否则会出现字体找不到的报错 启动#启动前请先打开xcode确保command tool是最新的 123$ npx react-native init AwesomeProject$ cd AwesomeProject$ yarn react-native run-ios 首次启动比较慢，根据电脑配置几分钟到十几分钟不等 核心组件#react-redux#参考vue的vuex, rn也有对应的状态管理，基本教程请参考此链接 axios#基本用法参照vue内的用法，不再赘述。 react-native-router-flux#对应vue-router, rn的路由管理参考链接, 不是很好理解，需要实际上手 页面传参#参考链接 NEXT 基础篇","link":"/2020/10/30/rn-app-step1/"},{"title":"React Native APP开发(3)","text":"采用RN开发APP进阶篇 常用框架 减少样板代码 简化action creator 1234567891011121314151617function makeActionCreator(type, ...argNames) { return function(...args) { let action = { type } argNames.forEach((arg, index) =&gt; { action[argNames[index]] = args[index] }) return action }}const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'export const addTodo = makeActionCreator(ADD_TODO, 'todo')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') 异步action creator + middleware 第三方授权登录 1. 微信授权 一些注意点 1. safeAreaView只对ios有效 2. setSate webview 保存图片、视频等 相册选择图片/视频、拍照等 safearea兼容 常用框架#参考链接 减少样板代码#简化action creator#1234567891011121314151617function makeActionCreator(type, ...argNames) { return function(...args) { let action = { type } argNames.forEach((arg, index) =&gt; { action[argNames[index]] = args[index] }) return action }}const ADD_TODO = 'ADD_TODO'const EDIT_TODO = 'EDIT_TODO'const REMOVE_TODO = 'REMOVE_TODO'export const addTodo = makeActionCreator(ADD_TODO, 'todo')export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'todo')export const removeTodo = makeActionCreator(REMOVE_TODO, 'id') 异步action creator + middleware#继上一篇的异步action， 当我们需要获取用户信息、评论列表、产品列表时，一种方案是抽象一个公共的request来处理各个请求，但是这样做共用了request.state, 无法应对单个请求异常超时的情况。这时候可以考虑换个思路抽象，使用thunk提供的中间件功能。 123456789101112export function loadPosts(userId) { return { // 要在之前和之后发送的 action types types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'], // 检查缓存 (可选): shouldCallAPI: (state) =&gt; !state.users[userId], // 进行取： callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`), // 在 actions 的开始和结束注入的参数 payload: { userId } };} 搭配中间件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function callAPIMiddleware({ dispatch, getState }) { return next =&gt; action =&gt; { const { types, callAPI, shouldCallAPI = () =&gt; true, payload = {} } = action if (!types) { // Normal action: pass it on return next(action) } if ( !Array.isArray(types) || types.length !== 3 || !types.every(type =&gt; typeof type === 'string') ) { throw new Error('Expected an array of three string types.') } if (typeof callAPI !== 'function') { throw new Error('Expected callAPI to be a function.') } if (!shouldCallAPI(getState())) { return } const [ requestType, successType, failureType ] = types dispatch(Object.assign({}, payload, { type: requestType })) return callAPI().then( response =&gt; dispatch(Object.assign({}, payload, { response, type: successType })), error =&gt; dispatch(Object.assign({}, payload, { error, type: failureType })) ) }} 至此，可以用下面的例子构造拉取评论、追加评论的异步action 1234567891011121314151617181920212223export function loadComments(postId) { return { types: ['LOAD_COMMENTS_REQUEST', 'LOAD_COMMENTS_SUCCESS', 'LOAD_COMMENTS_FAILURE'], shouldCallAPI: (state) =&gt; !state.posts[postId], callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`), payload: { postId } };}export function addComment(postId, message) { return { types: ['ADD_COMMENT_REQUEST', 'ADD_COMMENT_SUCCESS', 'ADD_COMMENT_FAILURE'], callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`, { method: 'post', headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' }, body: JSON.stringify({ message }) }), payload: { postId, message } };} 第三方授权登录#1. 微信授权#参考文章 https://www.cnblogs.com/lude1994/p/10784457.html https://www.npmjs.com/package/react-native-wechat https://www.jianshu.com/p/b1a081165fba 一些注意点#1. safeAreaView只对ios有效#2. setSate#js1234567891011this.setState({ name: 'abc',})console.log(this.state.name) // 输出并不是abc//正确的写法应该是this.setState({ name: 'abc'}, ()=&gt; { console.log(this.state.name) //abc}) webview# 参考文章1参考文章2 失效github 保存图片、视频等# yarn add @react-native-community/camerarollios需要配置info.list NSPhotoLibraryUsageDescription 你懂的安卓需要额外配置权限npm说明 相册选择图片/视频、拍照等# github项目 bash1234567yarn add react-native-image-picker# RN &gt;= 0.60cd ios &amp;&amp; pod install# RN &lt; 0.60react-native link react-native-image-picker safearea兼容# 参考文章","link":"/2020/11/04/rn-app-step3/"},{"title":"rn-elements","text":"本文介绍react-native-elements在rn项目中的使用。 参考文章官方文档","link":"/2020/12/02/rn-elements/"},{"title":"sentry-docker","text":"服务器端使用docker部署sentry服务端。 部署参考文章sentry官方文档 架构#Q：Sentry到底是如何实现实时日志监控报警的呢？A：Sentry是一个C/S架构，我们需要在自己应用中集成Sentry的SDK(支持前后端语言)才能在应用发生错误是将错误信息发送给Sentry服务端。根据语言和框架的不同，我们可以选择自动或自定义设置特殊的错误类型报告给Sentry服务端。Sentry的服务端分为web、cron、worker这几个部分，应用（客户端）发生错误后将错误信息上报给web，web处理后放入消息队列或Redis内存队列，worker从队列中消费数据进行处理，postgresql对数据持久化。 my-sentry：sentry的web服务 sentry-cron：sentry的定时任务，活性检测 sentry-worker：业务处理，数据持久化，报警 综上，想在自建服务器上搭建sentry服务端需要跑多个docker容器，请选购稍微大点的配置。 安装#服务器系统环境: centos: 7+ docker: 1.31.1 12345678910111213141516171819# 获取镜像，可能会比较慢docker pull sentry docker pull redisdocker pull postgres# 启动服务docker run -d --name sentry-redis --restart=always redis ###保证了，异常自动拉起docker run -d --name sentry-postgres -e POSTGRES_PASSWORD=密码 -e POSTGRES_USER=sentry --restart=always postgres# 生成sentry秘钥，记得保存哦~docker run --rm sentry config generate-secret-key# 数据库及账户初始化、需要你设置的账号就是WEB的登录账号和密码，稍微有点慢docker run -it --rm -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry upgrade# 启动WEBdocker run -d -p 9000:9000 --name my-sentry -e SENTRY_SECRET_KEY='秘钥' --link sentry-redis:redis --link sentry-postgres:postgres --restart=always sentry# 启动sentry-cron/work服务docker run -d --name sentry-cron -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry run crondocker run -d --name sentry-worker-1 -e SENTRY_SECRET_KEY='秘钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry run worker# 查看所有容器，是否有某明奇妙挂了的docker ps -a 在http://{ip}:9000上开始探索新大陆吧~ WEB# 好不犹豫就是Installation Instructions走起来，选择vue项目 傻眼了，刚才登录后的那个设置页面写错了地址，导致sentry.init配置项直接出现了ip…=&gt; 用nginx给9000配置一个域名 1npm install @sentry/browser main.js12345678910import Vue from 'vue'import * as Sentry from '@sentry/browser';import * as Integrations from '@sentry/integrations';Sentry.init({ dsn: 'http://8565417f11494c2b9ad05524717464a9@xxxx.yyy.com/1', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: '20210121v1', //版本号 logErrors: true //开发环境下打印错误}); 这个dsn会报错cros.但是可以不用管，不影响使用。=&gt; 找到好的解决办法再来补充 TEST#在首页mounted中随便写个console.log(abc)，运行页面即可。MARK: 如果使用try-catch把上面的log包含的话，sentry并不能捕获到。 稍微改造下引入函数，只在生产环境中使用sentry 1234567process.env.NODE_ENV == 'production' &amp;&amp; Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: '20210121v1', //版本号 logErrors: true //开发环境下打印错误}); 快速定位错误#获取token的参考文章配置参数位置的参考文章-官方文档配置参数答疑vue/cli4+的插件答疑 安装#我使用的是vue/cli 4+， 所以第一篇文章讲的web.config.js没用上，参照了插件答疑的文章进行配置 12#安装cnpm install --save-dev @sentry/webpack-plugin vue.config.js1234567891011121314151617181920212223242526272829303132333435363738const SentryWebpackPlugin = require(&quot;@sentry/webpack-plugin&quot;);//拼接路径function resolve(dir) { return path.join(__dirname, dir)}module.exports = { // ...其他配置 chainWebpack: config =&gt; { // ...其他插件 config .plugin('@sentry/webpack-plugin') .use( new SentryWebpackPlugin({ release:&quot;20210121v9&quot;, authToken: 'xxxxx', project: 'project_name', url: 'http://xxx.yyy.com', org: 'org_name', include: &quot;.&quot;, ignoreFile: &quot;.sentrycliignore&quot;, ignore: [&quot;node_modules&quot;, &quot;webpack.config.js&quot;], // configFile: &quot;sentry.properties&quot;, urlPrefix:&quot;~/js&quot; }) ) },}//plugin配置例子1chainWebpack(config) { config.plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin)}//plugin配置例子2const MyPlugin = require('plugin')config.plugin('plugin').use(new MyPlugin()) 获取配置参数#token# url# project# org# 测试#一开始跑得很流畅，但是后续几个上传sourceMap之后就无法定位错误位置，才明白是urlPrefix配置错误。 1这个 --url-prefix 是你线上访问到js文件的路径，~ 就是你网站的根目录，比如我网站的静态文件是这样 http://192.168.144.163:8080/static/js/xxxx.js，那么按照上面例子填就是正确的，因为我网站根目录就是 http://192.168.144.163:8080，上传成功后可以在 Releases -&gt; Artifacts 中看到刚才上传的文件 我的线上项目访问js是这样的：http://xx.yy.com/js/chunk.xxxx.js =&gt;所以urlPrefix得配置成 ~/js 配置sourseMap前的报错是这样的 配置后的报错定位。请注意右手边的一排小按钮，可以切换 =&gt; 快速定位报错位置 优化#为了成为项目应用，需要在开发环境中屏蔽sentry, 同时将版本号统一管理。 main.js123456process.env.NODE_ENV == 'production' &amp;&amp; Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [new Integrations.Vue({Vue, attachProps: true})], release: process.env.VUE_APP_RELEASE_VERSION, //版本号 logErrors: true //开发环境下打印错误}); vue.config.js12345678910111213141516process.env.NODE_ENV == 'production' &amp;&amp; config .plugin('@sentry/webpack-plugin') .use( new SentryWebpackPlugin({ release: process.env.VUE_APP_RELEASE_VERSION, authToken: 'f38e0c1683e84581be211f4ffce5287d2c776fd78fac4afba4c30ab92a2b9f39', project: 'abc', url: 'http://xxx.yyy.com', org: 'sentry', include: &quot;.&quot;, ignoreFile: &quot;.sentrycliignore&quot;, ignore: [&quot;node_modules&quot;, &quot;webpack.config.js&quot;], // configFile: &quot;sentry.properties&quot;, urlPrefix:&quot;~/js&quot; }) ) Q &amp; A#Q: error pulling image configuration: unknown blob# 查看docker文件 /etc/docker/daemon.json (没有的话 手动创建下), 我之前用的是163的镜像，切换成aliyun的。 打开阿里云容器镜像服务页面, 加加速器地址复制到上述json中。123{ &quot;registry-mirrors&quot;: [&quot;https://7ctk7xl2.mirror.aliyuncs.com&quot;]} 重启docker,记得把其他容器也重新跑起来。一般改了阿里云之后，拉取镜像的速度会起飞。 Q： chrome下的cors问题#我的服务端版本号是9.1.2， vue端是7在safari中上传没问题，报错时只发送一次xxx.yyy.com/api/2/store?xxx=xxxx.但是到了chrome下，出了上述报错外，还额外发了两次xxx.yyy.com/api/2/envelope?xxx=xxxx一开始还以为是客服端的cors配置出了问题，尝试半天未果。然后有怀疑是chorme的问题，还关掉了ad-block等，依旧不能解决。最后在官方github下看到这个issueSeems I can fix it by adding startTransactionOnPageLoad: false in BrowserTracing, closed然并卵！！！ 最终，我把nginx配置设置成这样 123456789101112131415161718server { listen 80; server_name xxx.yyy.com; proxy_set_header Connection ''; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Request-Id $request_id; proxy_read_timeout 30s; proxy_send_timeout 5s; location / { proxy_pass http://sentryServer; }} main.js123456789101112Sentry.init({ dsn: 'http://ba781ed498904482a764cba65c5b1eaf@xxx.yyy.com/2', integrations: [ new Integrations.Vue({Vue, attachProps: true}), new TracingIntegrations.BrowserTracing({ startTransactionOnPageLoad: false, }), ], release: process.env.VUE_APP_RELEASE_VERSION, //版本号 logErrors: true, //开发环境下打印错误 // _experiments: { useEnvelope: true },}); sentry服务端设置： projects -&gt; your_project -&gt; setting -&gt; general settings -&gt; domain 改为* stroe请求正常发送，envelope依旧不消停。 sad~ 知道原因的小伙伴请速速留言！！！","link":"/2021/01/21/sentry-docker/"},{"title":"vue-step-by-step","text":"vue教程(在实际项目中的基本使用) Step 1 起步 编辑器 VS Code cnpm 运行项目 项目结构 Step 2 组件的生命周期 页面 vue-router 全局钩子 路由钩子 组件钩子 vuex - store Step 3 思考 More keepActive的存在意义 为什么router-link时使用name vue-bus 全局通知 Step 4 优化加载 混入 自定义指令 客户端数据库 loki.js 服务端渲染 Nuxt 国际化 i18n 规范总结 Step 1#起步#vue有大版本区别，建议使用最新版。@vue/cli对于vue就像是spring-boot-starter对于spring-boot一样。 sh1234567## 全局安装cli工具，以后开发都会用到，所以建议全局安装npm install -g @vue/clicd someDir ..## 创建项目vue create step-by-step# ORvue ui vue create之后默认选择就行ESLint一开始会有所不适应，可以先放放。至此,创建一个叫做step-by-step项目。 编辑器 VS Code#和所有前端项目一样，可以直接使用idea/eclipse/sublime等工具来编写vue项目，在此推荐vscode cnpm#cnpm是国内采用淘宝镜像的组件工具，相比npm，获取依赖速度大大加快。以后项目中都会用到，建议全局安装。 12npm install cnpm -gnpm install cnpm -g --registry=https://registry.npm.taobao.org 运行项目#12345cd step-by-step#获取依赖cnpm i #测试运行npm run serve 不出意外将在命令窗口看到如下输出语句 12345DONE Compiled successfully in 1901ms 2:16:44 PMApp running at:- Local: http://localhost:8080/ - Network: http://192.168.3.32:8080/Note that the development build is not optimized. 项目结构#初始的项目距离开发需求还很远，先对项目结构做一下补充。 12345678910111213141516+ public+ src + assets - css //需要自己创建 - images //需要自己创建 + components + layouts //需要自己创建 + pages //需要自己创建 + configs //需要自己创建 + apis //需要自己创建 + utils //需要自己创建 - App.vue - main.js- vue.config.js //需要自己创建- babel.config.js- package.json 一个呈现在浏览器上的页面需要符合这样的层级结构：app &gt; layout &gt; page &gt; component。当我们项目需要不同的框架布局时，就可以定义不同的layout。举例子：正常浏览器访问查询列表的时候，我们需要header和footer，但是当我们的页面被别的项目用iframe引用时，就需要全局调整header和footer Step 2#组件的生命周期#改造初始后的项目，使其符合上一节所说的层级结构。阅读下面内容前，请先查看DEMO-S1从console中我们能看到打印结果为 1234567891011before layout createlayout createdbefore header createheader createdbefore content createcontent createdbefore footer createfooter createdheader mountedcontent mountedfooter mounted 由此，当我们在项目中加载数据的时候就需要注意了，layout/page/compontent各个阶段加载数据的先后顺序。父组件先create -&gt; 子组件 create -&gt; 子组件mounted -&gt; 父组件mounted 页面#阅读下面内容前，请先查看DEMO-S2了解了组件加载的先后顺序，我们尝试写一个符合规范的页面.为此我们需要新增依赖。 sh12cnpm i vue-router axios vuex --save# 记得重新npm run serve vue-router#基本用法: 123456789101112131415161718import Vue from 'vue';import VueRouter from 'vue-router';Vue.use(VueRouter);const router = new VueRouter({ mode: 'history', routes: [ { path: '/', //懒加载 component: () =&gt; import('../pages/index.vue') //or component: IndexPage } ]});export default router router-view 在src/components/common/content中包含这个标签，可以理解为根据配置的router来匹配组件。参考文档 router 与 钩子 全局钩子: beforeEach与afterEach的使用，配合store来查询用户权限、追加日志等 路由独享: 组件钩子: 全局钩子# to:router即将进入的路由对象 from:当前导航即将离开的路由 next:Function,进行管道中的一个钩子，如果执行完了，则导航的状态就是 confirmed （确认的）；否则为false，终止导航。 1234567891011121314151617181920212223router.beforeEach((to, from, next) =&gt; { console.log(store.state.token) const route = ['index', 'list']; let isLogin = store.state.token; // 是否登录 // 未登录状态；当路由到route指定页时，跳转至login if (route.indexOf(to.name) &gt;= 0) { if (isLogin == null) { router.push({ path: '/login', }); } } // 已登录状态；当路由到login时，跳转至home console.log(to.name) localStorage.setItem('routerName', to.name) if (to.name === 'login') { if (isLogin != null) { router.push({ path: '/HomeMain', });; } } next();});router.afterEach((to, from) =&gt; { console.log(to.fullPath, to.path, location.href)}); 路由钩子#12345678910111213const router = new VueRouter({ mode: 'history', routes: [ { path: '/dashboard', //懒加载 component: resolve =&gt; require(['../components/page/Dashboard.vue'], resolve) meta: { title: '系统首页' }, beforeEnter: (to, from, next) =&gt; { }, beforeLeave: (to, from, next) =&gt; { }, } ]}); 组件钩子#12345678910111213141516171819&lt;template&gt; &lt;div&gt;...&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data: ()=&gt; ({}), beforeRouteLeave(to, from, next) { next() }, beforeRouteEnter(to, from, next) { next() }, beforeRouteUpdate(to, from, next) { next() }, computed: {}, method: {}}&lt;/script&gt; vuex - store#官方文档 state:驱动应用的数据源； view: 以声明方式将 state 映射到视图； actions: 响应在 view 上的用户输入导致的状态变化。 mutation: 原函数改变state的数据 action: 异步请求 -&gt; 有必要的话可以在返回前调用mutation12this.$store.commit('clearUsrInfo') //mutationthis.$store.dispatch('getProductList') //action Step 3#思考#对于SPA项目，各种数据请求/处理应该在哪个位置发生？带着以下问题查看DEMO-S3 有登录用户吗？ 存在本地化的授权token 校验token是否有效 用户的基本信息什么时候更新，保存在哪？那些数据虽然需要，但不需要本地化? 只存token,其他数据在必要的时候远程更新 当前用户有权查看当前页面信息吗？ 查store校验 调用远程接口由后台判断 -&gt; nuxt 用户的浏览行为在哪里发出？逐个页面发送日志，还是统一发送？ 借用钩子(全局钩子/路由钩子) 不同级别的用户对应不同的界面/菜单，我应该在哪个层进行识别才能避免用户看到不该看的信息？ 根据数据敏感程度自行斟酌：低敏感度、高敏感度 api统一管理的意义何在？是否需要全部使用action 可以适当偷懒，直接调用axios 统一管理：解耦合 More#阅读以下以下代码时，请先查看DEMO-S4 keepActive的存在意义#router.js12345678910111213const router = new Router({ ... routes: [ { name: 'test', path: '/test', component: ()=&gt; import('@/pages/test/index'), meta: { keepAlive: true } } ] }) compontents/xx.js1234&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 为什么router-link时使用name#当我们需要修改某个页面的路径的时候，不必逐个页面修改，只需要在router.js中修改path即可。 vue-bus 全局通知#1cnpm i --save vue-bus 123456789101112import VueBus from 'vue-bus'Vue.use(VueBus)this.$bus.on('some-action', actionHandle)this.$bus.once('some-action-happen-once', actionHandle)this.$bus.emit('some-action', paylod)actionHanlle: function(paylod) {} Step 4#优化加载#阅读以下代码请先查看DEMO-S5 外部引用 loki.js为例 在public/index.html中顶部引用外部script 在vue.config.js中配置映射关系 按需引用 element-ui为例123456789101112131415161718192021222324252627/* 第一步cnpm i --save babel-preset-envcnpm i --dev babel-plugin-component*///第二步修改.babel.config.jsmodule.exports = { presets: [ '@vue/cli-plugin-babel/preset', ], plugins: [ // element官方教程 [ &quot;component&quot;, { libraryName: &quot;element-ui&quot;, styleLibraryName: &quot;theme-chalk&quot; } ] ]}//第三部在main.js中import { Button } from 'element-ui';Vue.use(Button);//第四部实际组件中&lt;el-button @click=&quot;addTodo&quot;&gt;Vue-Bus&lt;/el-button&gt; 包分析package.json123456// cnpm i -D webpack-bundle-analyzer// 追加指令 &quot;scripts&quot;: { ... &quot;analyz&quot;: &quot;npm run build --analyze&quot; }, vue.config.js123456789101112131415161718const path = require('path');//拼接路径function resolve(dir) { return path.join(__dirname, dir)}module.exports = { ... chainWebpack: config =&gt; { config .plugin('webpack-bundle-analyzer') .use(require('webpack-bundle-analyzer').BundleAnalyzerPlugin) config.resolve.alias .set('@', resolve('src')) .set('#', resolve('public')) },} gzip nginx配置缓存和压缩 webpack压缩设置 混入#阅读以下代码请先查看DEMO-S5对于需要鉴权的页面，都会包含用户的基本信息，怎么才能避免每个组件都复制黏贴呢？ -&gt; 全局混入demo中我们点击/mine页面中的按钮可以直接修改header中的显示。 main.js1234567891011Vue.mixin({ created: function () {}, //混入对象的钩子将在组件自身钩子之前调用 computed: { ...mapState({ citySN: state =&gt; state.citySN }), ...mapGetters({ authBJS: 'fromBJS', }) },}) 其他还有组件混入等，可以查看官方文档。需要注意各种混入方式中遇到名称冲突时的规则。 自定义指令#在手机端页面上常常会有这样的需求：页面/组件打开(show)时自动focus输入框 -&gt; 自定义指令focus官方文档我们修改之前根据三字码查询机场名称的代码（/loki页面） 123456789directives: { focus: { // 指令的定义 inserted: function (el) { let ipt = el.hasChildNodes() ? el.querySelector('input') : el ipt.focus() } }}, 客户端数据库 loki.js#Github关键是看下examples。结合localStorage避免页面多次加载json。 服务端渲染 Nuxt#准备额外开文章说，暂且略过。 国际化 i18n#官方文档 规范总结# 保证项目文档结构 vue页面/组件内尽可能少使用axios请求，统一到apis/xxx.js目录下 梳理store.state内容,灵活使用getters localStorage.item中只存储必要信息，切勿将state全部存在localStorage中(若后期增减/修改字段会需要额外维护) 利用router钩子进行鉴权，避免暴露敏感页面 抽象request.js，为所有api使用，保证数据处理的一致性(主要是错误编码、报错信息的一致) 灵活使用router-view组件，减少页面渲染 组件间(非父子关系)时，使用vue-bus,切勿使用localStorage 使用混入，减少组件的重复代码 外部引用、按需引用、代码压缩等优化加载。","link":"/2021/01/08/vue-step-by-step/"},{"title":"前端基础之Blob、ArrayBuffer","text":"ArrayBuffer 对象与 Blob 对象常见于文件上传操作处理（如处理图片上传预览等问题）。 ArrayBuffer 对象#ArrayBuffer 对象是 ES6 才纳入正式 ECMAScript 规范，是 JavaScript 操作二进制数据的一个接口。ArrayBuffer 对象是以数组的语法处理二进制数据，也称二进制数组。介绍 ArrayBuffer 对象还需介绍 TypedArray 视图和 DataView 视图，本文不具体介绍，详细可以查看阮一峰老师《ECMAScript 6 入门 ArrayBuffer》 章节。 1. 概念介绍#ArrayBuffer 对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图）来读写，视图的作用是以指定格式解读二进制数据。关于 TypedArray 视图和 DataView 视图 ，可以查看阮一峰老师《ECMAScript 6 入门 ArrayBuffer》 章节的介绍。 2. 对象使用#浏览器原生提供 ArrayBuffer() 构造函数，用来生成实例。 参数： 整数，表示二进制数据占用的字节长度。 返回值: 一个指定大小的 ArrayBuffer 对象，其内容被初始化为 0。1const buffer = new ArrayBuffer(32); 上面代码表示实例对象 buffer 占用 32 个字节。 3. 实例属性和方法#ArrayBuffer 对象有实例属性 byteLength ，表示当前实例占用的内存字节长度（单位字节），一单创建就不可变更（只读）： 12const buffer = new ArrayBuffer(32);buffer.byteLength; // 32 4. slice()#slice()用来复制一部分内存。 参数如下： start，整数类型，表示开始复制的位置。默认从 0 开始。 end，整数类型，表示结束复制的位置（不包括结束的位置）。如果省略，则表示复制到结束。12const buffer = new ArrayBuffer(32);const buffer2 = buffer.slice(0); Blob 对象#1. 概念介绍#Blob 全称：Binary Large Object （二进制大型对象）。Blob 对象表示一个二进制文件的数据内容，通常用来读写文件，比如一个图片文件的内容就可以通过 Blob 对象读写。 与 ArrayBuffer 区别： Blob 用于操作二进制文件 ArrayBuffer 用于操作内存 2. 对象使用#浏览器原生提供 Blob() 构造函数，用来生成实例。 Blob 的内容由参数数组中给出的值的串联组成。 1const leoBlob = new Blob(array [, options]); array，必填，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；成员可以是一个由 ArrayBuffer , ArrayBufferView , Blob , DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。 options，可选，是一个配置对象，这里介绍常用的属性 type，表示数据的 MIME 类型，默认空字符串； options 目前可能有两个属性： type 和 endings。 endings 用于指定包含行结束符 \\n 的字符串如何被写入，默认值 transparent。它只有这两个值：native （代表行结束符会被更改为适合宿主操作系统文件系统的换行符）和 transparent （代表会保持blob中保存的结束符不变）。 12const leoHtmlFragment = ['&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey leo！&lt;/b&gt;&lt;/a&gt;']; // 一个包含 DOMString 的数组const leoBlob = new Blob(leoHtmlFragment, {type : 'text/html'}); // 得到 blob 该代码中，实例对象 leoBlob 包含的是字符串。生成实例时，指定数据类型为 text/html。 还可以使用 Blob 保存 JSON 数据： 12const obj = { hello: 'leo' };const blob = new Blob([ JSON.stringify(obj) ], {type : 'application/json'}); 3. 实例属性和方法#Blob 具有两个实例属性： size：文件的大小，单位为字节。 type：文件的 MIME 类型。如果类型无法确定，则返回空字符串。12345const leoHtmlFragment = ['&lt;a id=&quot;a&quot;&gt;&lt;b id=&quot;b&quot;&gt;hey leo！&lt;/b&gt;&lt;/a&gt;']; // 一个包含 DOMString 的数组const leoBlob = new Blob(leoHtmlFragment, {type : 'text/html'}); // 得到 blobleoBlob.size; // 38leoBlob.type; // &quot;text/html&quot; Blob 实例方法： slice：方法用于创建一个包含源 Blob 的指定字节范围内的数据的新 Blob 对象。 start，可选，起始的字节位置，默认 0； end，可选，结束的字节位置，默认 size 属性的值，不包含该位置； contentType，可选，新实例的数据类型（默认为空字符串）；1const newBlob = oldBlob.slice([start [, end [, contentType]]]) 4. 实际案例#获取文件信息#文件选择器 &lt;input type=&quot;file&quot;&gt; 用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的 value 属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。文件选择器返回一个 FileList 对象，该对象是个类数组对象，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了 name 和 lastModifiedDate 属性。也包括拖放 API 的 dataTransfer.files 返回的也是一个 FileList 对象，成员也是 File 实例对象。1234567891011121314// HTML 代码如下// &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&gt;function fileinfo(files) { for (let i = 0; i &lt; files.length; i++) { let f = files[i]; console.log( f.name, // 文件名，不含路径 f.size, // 文件大小，Blob 实例属性 f.type, // 文件类型，Blob 实例属性 f.lastModifiedDate // 文件的最后修改时间 ); }} 下载文件#在 AJAX 请求中，指定 responseType 属性为 blob ，皆可以下下载一个 Blob 对象。123456789function getBlob(url, callback) { const xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.responseType = 'blob'; xhr.onload = function () { callback(xhr.response); } xhr.send(null);} 然后，xhr.response 拿到的就是一个 Blob 对象。 生成 URL#浏览器允许使用 URL.createObjectURL() 方法，针对 Blob 对象生成一个临时URL，以便于某些 API 使用。 如作为图片预览的 URL。 这个 URL 以 blob:// 开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与 data://URL（URL 包含实际数据）和 file://URL（本地文件系统里面的文件）都不一样。 1234567891011121314151617const droptarget = document.getElementById('droptarget');droptarget.ondrop = function (e) { const files = e.dataTransfer.files; for (let i = 0; i &lt; files.length; i++) { let type = files[i].type; if (type.substring(0,6) !== 'image/') continue; let img = document.createElement('img'); img.src = URL.createObjectURL(files[i]); img.onload = function () { this.width = 100; document.body.appendChild(this); URL.revokeObjectURL(this.src); } }} 代码中，通过为拖放的图片文件生成一个 URL，作为预览的缩略图。 浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。 读取文件#取得 Blob 对象以后，可以通过 FileReader 对象，读取 Blob 对象的内容，即文件内容。 FileReader 对象提供四个方法。将 Blob 对象作为参数传入，然后以指定的格式返回。 FileReader.readAsText()：返回文本，需要指定文本编码，默认为 UTF-8。 FileReader.readAsArrayBuffer()：返回 ArrayBuffer 对象。 FileReader.readAsDataURL()：返回 Data URL。 FileReader.readAsBinaryString()：返回原始的二进制字符串。下面是 FileReader.readAsText() 方法的例子，用来读取文本文件：12345678910111213141516// HTML 代码如下// &lt;input type='file' onchange='readfile(this.files[0])'&gt;&lt;/input&gt;// &lt;pre id='output'&gt;&lt;/pre&gt;function readfile(f) { let reader = new FileReader(); reader.readAsText(f); reader.onload = function () { let text = reader.result; let out = document.getElementById('output'); out.innerHTML = ''; out.appendChild(document.createTextNode(text)); } reader.onerror = function(e) { console.log('Error', e); };} 下面是 FileReader.readAsArrayBuffer() 方法的例子，用于读取二进制文件：1234567891011121314151617181920212223// HTML 代码如下// &lt;input type=&quot;file&quot; onchange=&quot;typefile(this.files[0])&quot;&gt;&lt;/input&gt;function typefile(file) { // 文件开头的四个字节，生成一个 Blob 对象 let slice = file.slice(0, 4); let reader = new FileReader(); // 读取这四个字节 reader.readAsArrayBuffer(slice); reader.onload = function (e) { let buffer = reader.result; // 将这四个字节的内容，视作一个32位整数 let view = new DataView(buffer); let magic = view.getUint32(0, false); // 根据文件的前四个字节，判断它的类型 switch(magic) { case 0x89504E47: file.verified_type = 'image/png'; break; case 0x47494638: file.verified_type = 'image/gif'; break; case 0x25504446: file.verified_type = 'application/pdf'; break; case 0x504b0304: file.verified_type = 'application/zip'; break; } console.log(file.name, file.verified_type); };}","link":"/2021/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BBlob/"},{"title":"前端基础之WebSocket","text":"WebSocket 是一种网络通信协议，很多高级功能都需要它 why#初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 特点： 建立在 TCP 协议之上，服务器端的实现比较容易。 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 数据格式比较轻量，性能开销小，通信高效。 可以发送文本，也可以发送二进制数据。 没有同源限制，客户端可以与任意服务器通信。 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 示例#123456789101112131415var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);ws.onopen = function(evt) { console.log(&quot;Connection open ...&quot;); ws.send(&quot;Hello WebSockets!&quot;);};ws.onmessage = function(evt) { console.log( &quot;Received Message: &quot; + evt.data); ws.close();};ws.onclose = function(evt) { console.log(&quot;Connection closed.&quot;);}; API#WebSocket 构造函数#WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。 1var ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 实例对象的所有属性和方法清单，参见这里。 webSocket.readyState#readyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。下面是一个示例。1234567891011121314151617switch (ws.readyState) { case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;} webSocket.onopen#实例对象的onopen属性，用于指定连接成功后的回调函数。123ws.onopen = function () { ws.send('Hello Server!');} 如果要指定多个回调函数，可以使用addEventListener方法。123ws.addEventListener('open', function (event) { ws.send('Hello Server!');}); webSocket.onclose#实例对象的onclose属性，用于指定连接关闭后的回调函数。12345678910111213ws.onclose = function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event};ws.addEventListener(&quot;close&quot;, function(event) { var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event}); webSocket.onmessage#实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。123456789ws.onmessage = function(event) { var data = event.data; // 处理数据};ws.addEventListener(&quot;message&quot;, function(event) { var data = event.data; // 处理数据}); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。12345678910ws.onmessage = function(event){ if(typeof event.data === String) { console.log(&quot;Received data string&quot;); } if(event.data instanceof ArrayBuffer){ var buffer = event.data; console.log(&quot;Received arraybuffer&quot;); }} 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。1234567891011// 收到的是 blob 数据ws.binaryType = &quot;blob&quot;;ws.onmessage = function(e) { console.log(e.data.size);};// 收到的是 ArrayBuffer 数据ws.binaryType = &quot;arraybuffer&quot;;ws.onmessage = function(e) { console.log(e.data.byteLength);}; webSocket.send()#实例对象的send()方法用于向服务器发送数据。1234567891011121314ws.send('your message');//发送 Blob 对象的例子。var file = document .querySelector('input[type=&quot;file&quot;]') .files[0];ws.send(file);//发送 ArrayBuffer 对象的例子。// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) { binary[i] = img.data[i];}ws.send(binary.buffer); webSocket.bufferedAmount#实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。1234567var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) { // 发送完毕} else { // 发送还没结束} webSocket.onerror#实例对象的onerror属性，用于指定报错时的回调函数。1234567socket.onerror = function(event) { // handle error event};socket.addEventListener(&quot;error&quot;, function(event) { // handle error event}); 服务端#搭建#12brew install nodenpm install ws server.js123456789101112131415let WebSocketServer = require('ws').Server, wss = new WebSocketServer({ port: 8181 });//服务端口8181wss.on('connection', function (ws) { console.log('服务端：客户端已连接'); ws.on('message', function (event) { //打印客户端监听的消息 console.log(event); let data = JSON.parse(event) if(data &amp;&amp; data.msg) { ws.send(data.name + ', 你好, 消息已收到') } else { ws.send('你说了啥?') } });}); 1node server.js client.html12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;body&gt; &lt;form role=&quot;form&quot; id=&quot;chat_form&quot; onsubmit=&quot;sendMessage(); return false;&quot; style=&quot;margin-top:100px;&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input class=&quot;form-control&quot; type=&quot;text&quot; name=&quot;message&quot; id=&quot;message&quot; value=&quot;&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;button&quot; id=&quot;send&quot; class=&quot;btn btn-primary&quot; onclick=&quot;sendMessage();&quot;&gt; 发送 &lt;/button&gt; &lt;/form&gt; &lt;script&gt; let ws = new WebSocket(&quot;ws://localhost:8181&quot;); ws.onopen = function (e) { //成功连接服务器回调 console.log('客户端（client）：与服务器的连接已打开') let msg = { time: new Date().toDateString(), id: 1, name: 'matthew', msg: '你好' } ws.send(JSON.stringify(msg)) } ws.onmessage = function(e) { console.log(e.data) } function sendMessage() { let msg = { time: new Date().toDateString(), id: 1, name: 'matthew', msg: document.getElementById('message').value } ws.send(JSON.stringify(msg)); } &lt;/script&gt;&lt;/body&gt; 运行#12node server.js # 不要关闭命令窗口 将html文件在浏览器中打开，查看console","link":"/2021/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BWebSocket/"},{"title":"前端基础之Worker","text":"Web Worker是HTML5中提出的概念，用来处理独立于主线程处理高费时的任务，从而不会阻塞主线程。目前绝大部分浏览器都支持Web Worker功能。 基本使用 创建 通信： 收发消息 worker加载脚本 错误处理 关闭 Worker 数据通信 同页面的 Web Worker Worker 新建 Worker API 示例 Web Worker的使用一般是指定一个脚本的URI来执行worker线程，通过postMessage方法和onmessage事件处理函数来进行数据传递。同时，如果Worker线程与主线程频繁的通信，仍然可能影响页面的性能。对于复杂的计算处理来说，只执行一次的话，也没有必要使得Worker线程一直存在. Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。 Web Worker 有以下几个使用注意点。 同源限制 分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 DOM 限制 Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。 通信联系 Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 脚本限制 Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。 文件限制 Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。但可以使用Blob。 基本使用#创建#main.js12345678910const code = [ `self.fn = ${f.toString()};`, 'self.onmessage = (e) =&gt; {', ' const r = self.fn(e.data);', ' self.postMessage(r);', '}'];const blob = new Blob(code, { type: 'text/javascript' });const url = URL.createObjectURL(blob);const worker = new Worker(url); Worker()构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。 通信： 收发消息#主线程调用worker.postMessage()方法，向 Worker 发消息。 main.js123worker.postMessage('Hello World');worker.postMessage({method: 'echo', args: ['Work']});worker.postMessage()方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。 接着，主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。 worker.js123456789worker.onmessage = function (event) { console.log('Received message ' + event.data); doSomething();}function doSomething() { // 执行任务 worker.postMessage('Work done!');} 上面代码中，事件对象的data属性可以获取 Worker 发来的数据。 Worker 完成任务以后，主线程就可以把它关掉。 main.js1worker.terminate(); Worker 线程内部需要有一个监听函数，监听message事件。 worker.js123self.addEventListener('message', function (e) { self.postMessage('You said: ' + e.data);}, false); 上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。 worker.js123456789// 写法一this.addEventListener('message', function (e) { this.postMessage('You said: ' + e.data);}, false);// 写法二addEventListener('message', function (e) { postMessage('You said: ' + e.data);}, false); 除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。 根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。 worker.js1234567891011121314self.addEventListener('message', function (e) { var data = e.data; switch (data.cmd) { case 'start': self.postMessage('WORKER STARTED: ' + data.msg); break; case 'stop': self.postMessage('WORKER STOPPED: ' + data.msg); self.close(); // Terminates the worker. break; default: self.postMessage('Unknown command: ' + data.msg); };}, false); 上面代码中，self.close()用于在 Worker 内部关闭自身。 worker加载脚本#Worker 内部如果要加载其他脚本，有一个专门的方法importScripts()。 worker.js123importScripts('script1.js');//该方法可以同时加载多个脚本。importScripts('script1.js', 'script2.js'); 错误处理#主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件。 main.js123456789worker.onerror(function (event) { console.log([ 'ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message ].join(''));});// 或者worker.addEventListener('error', function (event) { // ...}); Worker 内部也可以监听error事件。 关闭 Worker#使用完毕，为了节省系统资源，必须关闭 Worker。 12345// 主线程worker.terminate();// Worker 线程self.close(); 数据通信#主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。 12345678910111213// 主线程var uInt8Array = new Uint8Array(new ArrayBuffer(10));for (var i = 0; i &lt; uInt8Array.length; ++i) { uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]}worker.postMessage(uInt8Array);// Worker 线程self.onmessage = function (e) { var uInt8Array = e.data; postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString()); postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);}; 但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。 如果要直接转移数据的控制权，就要使用下面的写法。 main.js123456// Transferable Objects 格式worker.postMessage(arrayBuffer, [arrayBuffer]);// 例子var ab = new ArrayBuffer(1);worker.postMessage(ab, [ab]); 同页面的 Web Worker#通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。 123456789&lt;!DOCTYPE html&gt; &lt;body&gt; &lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt; addEventListener('message', function () { postMessage('some message'); }, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上面是一段嵌入网页的脚本，注意必须指定&lt;script&gt;标签的type属性是一个浏览器不认识的值，上例是app/worker。 然后，读取这一段嵌入页面的脚本，用 Worker 来处理。 main.js1234567var blob = new Blob([document.querySelector('#worker').textContent]);var url = window.URL.createObjectURL(blob);var worker = new Worker(url);worker.onmessage = function (e) { // e.data === 'some message'}; 上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。 Worker 新建 Worker#Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持。 略 API#浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。 1var myWorker = new Worker(jsUrl, options); Worker()构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。 12345// 主线程var myWorker = new Worker('worker.js', { name : 'myWorker' });// Worker 线程self.name // myWorker Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下: Worker.onerror：指定 error 事件的监听函数。 Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。 Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。 Worker.postMessage()：向 Worker 线程发送消息。 Worker.terminate()：立即终止 Worker 线程。 Web Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。 Worker 线程有一些自己的全局属性和方法: self.name： Worker 的名字。该属性只读，由构造函数指定。 self.onmessage：指定message事件的监听函数。 self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。 self.close()：关闭 Worker 线程。 self.postMessage()：向产生这个 Worker 线程发送消息。 self.importScripts()：加载 JS 脚本。 示例#1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;script id=&quot;worker&quot; type=&quot;app/worker&quot;&gt; addEventListener('message', function (e) { postMessage('worker recieved message: ' + e.data.content); }, false); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var blob = new Blob([document.querySelector('#worker').textContent]); var url = window.URL.createObjectURL(blob); var worker = new Worker(url); worker.postMessage({ fromMain: true, content: 'I am from Main thread!' }) worker.onmessage = function(e){ console.log(e.data) worker.terminate() } &lt;/script&gt;&lt;/body&gt;","link":"/2021/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BWorker/"},{"title":"前端基础之bind、call、apply","text":"在上一篇文章简单介绍bind/call/apply之后，详细介绍下这三位js重量级选手 加深理解 call、apply apply - call 区别 使用示例 面试实例 bind 使用实例1：预定义参数 使用实例2： 与setTimeout/setinterval一起使用 使用实例3：作为构造函数 使用实例4： 捷径 自己来构造bind方法：bind并不是在所有浏览器中都支持(低版本浏览器不支持) mark: 多次bind无效，只有第一次bind是生效的 call/apply/bind 重写bind、call、apply、new 加深理解# apply/call/bind是Function自带的方法 改变Function中的this指向 -&gt; 移花接木 call、apply#1234567891011121314151617181920212223function fruits() { console.log('this from spell:', this) // fruits}fruits.prototype = { color: 'red', say: function() { console.log('this from say:', this) //指向fruits console.log('my color is ' + this.color) }, tell: () =&gt; { console.log('this from tell:', this) // 指向Windows }}let apple = new fruits //立即执行 function内的代码apple.say()apple.tell()//console.log//this from spell: fruits {}//this from say: fruits {}//my color is red//this from tell: Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} 此时如果我们构建一个banana = {color:’yellow’}对象，但是不想反复创建say方法，就可以直接使用apply/call来借用apply的方法 1234567891011let banana = { color: 'yellow'}apple.say.call(banana)apple.say.apply(banana)//console.log// this from say: {color: &quot;yellow&quot;} color: &quot;yellow&quot;__proto__: Object// my color is yellow// this from say: {color: &quot;yellow&quot;} color: &quot;yellow&quot;__proto__: Object// my color is yellow 此时say方法内的this指向了banana对象 apply - call 区别#入参方式不同 123456let func = function(arg1, arg2) {}func.call(this, arg1, arg2)func.apply(this, [arg1, arg2]) 使用示例#12345678let array1 = [12, 'foo', '-123', {name: 'Joe'}]let array2 = ['Deo', '555', 100]Array.prototype.push.apply(array1, array2)console.log(array1)//console(7) [12, &quot;foo&quot;, &quot;-123&quot;, {…}, &quot;Deo&quot;, &quot;555&quot;, 100] 12345let numbers = [1, 10, 12, 2, 4]let maxInNumers = Math.max.apply(Math, numbers)let minInNumbers = Math.min.call(Math, 1, 10, 2, 4)console.log(maxInNumers) // 12console.log(minInNumbers) // 1 1234// 验证是否是数组(toString未被修改)function isArray(obj) { return Object.prototype.toString.call(obj) === '[object Array]'} 面试实例#题1： 定义一个log方法，代理console.log方法 1234567891011121314151617181920212223function log(...args) { console.log(args)}function log1() { console.log.apply(console, arguments)}function log2() { let args = Array.prototype.slice.call(arguments) args.unshift('(app) ') console.log.apply(console, args)}log(1,2)log1(1,2,3)log2('1', 'wncwejcnk', {abc: 'test'})//console(2) [1, 2]1 2 3(app) 1 wncwejcnk {abc: &quot;test&quot;} bind#错误实例1：将方法从一个对象中拿出来赋值，并且希望this指向原来的对象，一般不做特殊处理都会丢失原来的对象 1234567let altwrite = document.writealtwrite('hello') // Uncaught TypeError: Illegal invocation//altwrite改变this的指向global或者window,导致非法调用//正确姿势altwrite.bind(document)('hello') // helloaltwrite.call(document, 'hello') // hello bind用于创建一个函数，使这个函数无论怎么调用都有相同的this值 当使用bind绑定函数时，以创建时传入bind的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数韩兆顺序作为原函数的参数来调用函数 示例1： 1234567891011121314151617181920212223let foo = { bar: 1, eventBind: function() { let _this = this $('.someClass').on('click', function(){ console.log(this) //&lt;h1 class=&quot;someClass&quot;&gt;abc&lt;/h1&gt; console.log(_this) //{bar: 1, eventBind: ƒ} }) }}foo.eventBind()let foo1 = { bar: 2, eventBind: function() { $('.someClass').on('click', function(){ console.log(this) //{bar: 2, eventBind: ƒ} }.bind(this)) }}foo1.eventBind() 示例2： 123456789101112let bar2 = function() { console.log(this.x)}bar2() //undefinedlet barObject = { x: 'this is from barObject'}let barFunc = bar2.bind(barObject) //不会立即执行barFunc() //this is from barObject 使用实例1：预定义参数#12345678910function list() { return Array.prototype.slice.call(arguments)}let list1 = list(1,2,3) // [1,2,3]let leading37List = list.bind(undefined, 37)let list2 = leading37List(1,2,3) // [37, 1, 2 ,3]let list3 = leading37List() // [37] 使用实例2： 与setTimeout/setinterval一起使用#12345678910111213141516171819202122232425function Bloomer() { this.petalCount = Math.ceil(Math.random() * 12 + 1)}Bloomer.prototype.bloom = function() { window.setTimeout(this.declare.bind(this), 1000)}Bloomer.prototype.declare = function() { console.log('declare.this', this) console.log('i have ' + this.petalCount + ' petal')}let bloo = new Bloomer // 等同于 new Bloomer()bloo.bloom() //i have 3 petallet myBloomer = { petalCount: 12}Bloomer.prototype.bloom2 = function(obj) { window.setTimeout(this.declare.bind(obj), 1000)}bloo.bloom2(myBloomer) //i have 12 petalbloo.bloom2().bind(myBloomer) // Uncaught TypeError: Cannot read property 'bind' of undefined 使用实例3：作为构造函数#适用于使用new操作符来构造目标函数的实例：此时this会被忽略，但传入的参数仍然有效(第二个参数开始) 12345678910111213141516171819202122function Point(x, y) { this.x = x; this.y = y;}Point.prototype.toString = function() { console.log(this.x + ',' + this.y)}let p = new Point(1, 2)p.toString() // 1,2let emptyObj = {}let YAxisPoint = Point.bind(emptyObj, 0) //x=0let YAxisPoint2 = Point.bind(null, 0) //不会报错，this被忽略let axisPoint = new YAxisPoint(5)axisPoint.toString() //0,5console.log(axisPoint instanceof Point) //trueconsole.log(axisPoint instanceof YAxisPoint) //trueconsole.log(new Point(1,3) instanceof YAxisPoint) //true 使用实例4： 捷径#12345678//改造前let slice = Array.prototype.sliceslice.call(arguments)//改造后let unbounSlice = Array.prototype.slicelet slice2 = Function.prototype.call.bind(unboundSlice)slice2(arguments) 自己来构造bind方法：bind并不是在所有浏览器中都支持(低版本浏览器不支持)#1234567891011121314151617181920Function.prototype.bind = function (oThis) { if (typeof this !== &quot;function&quot;) { throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {}, fBound = function () { return fToBind.apply( this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments)) ); }; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;}; mark: 多次bind无效，只有第一次bind是生效的#bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。 call/apply/bind#123456789101112131415let obj = { x: 81,}; let fooObj = { x: 3, getX: function() { return this.x; }} console.log(fooObj.getX.bind(obj)()); //81 , 多一个（）console.log(fooObj.getX.call(obj)); //81console.log(fooObj.getX.apply(obj)); console.log(fooObj.getX()) // 3 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 重写bind、call、apply、new#参考文档-掘金","link":"/2021/02/19/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8Bbind-call-apply/"},{"title":"前端基础之页面渲染与网路请求","text":"新开主题介绍计算机基础，其实也是前端的基础！ 页面渲染 DOM CSSOM 加载JS Render Tree 页面的重绘（repaint）与重排（reflow） 重绘（repaint）： 重排/回流（reflow）： NOTE 1. 重排必将引起重绘，而重绘不一定会引起重排。 2. 何时回引起重排？ 3. **如何减少和避免重排 ** 网络请求 TCP 三次握手建立连接 TCP 四次握手断开连接 Q &amp; A 为什么要将js放到页脚部分 引入样式的几种方式的权重 css属性书写顺序建议 何种类型的DOM操作是耗费性能的 参考文档 Q:从用户输入浏览器输入url到页面最后呈现 有哪些过程？ 用户输入URL地址 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存） 浏览器将端口号从URL中解析出来 浏览器建立一条与目标Web服务器的TCP连接（三次握手） 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器返回一条HTTP响应报文 关闭连接 浏览器解析文档 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕 页面渲染#主流的两个浏览器内核为WebKit 和 Gecko(Mozilla) 两者在用词上稍有差异，但主题流程基本为： HTML解析出DOM Tree CSS解析出Style Rules 将二者关联生成Render Tree Layout 根据Render Tree计算每个节点的信息 Painting 根据计算好的信息绘制整个页面 DOM#DOM树构建过程： 读取html文档， 将字节转换成字符， 确定tokens（标签）， 再将tokens转换成节点，以节点构建 DOM 树 CSSOM#CSSOM树构建过程与DOM树构建流程一致： 读取CSS文档， 将字节转换成字符， 确定tokens（标签）， 再将tokens转换成节点，以节点构建 CSSOM 树 加载JS#若在构建DOM树的过程中，当 HTML 解析器遇到一个 script 标记时，即遇到了js，将立即阻塞DOM树的构建，将控制权移交给 JavaScript 引擎，等到 JavaScript 引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建。 其根本原因在于，JS会对DOM节点进行操作，浏览器无法预测未来的DOM节点的具体内容，为了防止无效操作，节省资源，只能阻塞DOM树的构建。譬如，若不阻塞DOM树的构建，若JS删除了某个DOM节点A，那么浏览器为构建此节点A花费的资源就是无效的。 若在HTML头部加载JS文件，由于JS阻塞，会推迟页面的首绘。为了加快页面渲染，一般将JS文件放到HTML底部进行加载，或是对JS文件执行async或defer加载。 Render Tree#渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。 构建渲染树，根据渲染树计算每个可见元素的布局，并输出到绘制流程，将像素渲染到屏幕上。 页面的重绘（repaint）与重排（reflow）#重绘（repaint）：#屏幕的一部分要重绘。渲染树节点发生改变，但不影响该节点在页面当中的空间位置及大小。譬如某个div标签节点的背景颜色、字体颜色等等发生改变，但是该div标签节点的宽、高、内外边距并不发生变化，此时触发浏览器重绘（repaint）。 重排/回流（reflow）：#当渲染树节点发生改变，影响了节点的几何属性（如宽、高、内边距、外边距、或是float、position、display：none;等等），导致节点位置发生变化，此时触发浏览器重排（reflow），需要重新生成渲染树。譬如JS为某个p标签节点添加新的样式：”display:none;”。导致该p标签被隐藏起来，该p标签之后的所有节点位置都会发生改变。此时浏览器需要重新生成渲染树，重新布局，即重排（reflow）。 NOTE#1. 重排必将引起重绘，而重绘不一定会引起重排。#2. 何时回引起重排？#当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排： 添加或者删除可见的DOM元素； 元素位置改变——display、float、position、overflow等等； 元素尺寸改变——边距、填充、边框、宽度和高度 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变； 页面渲染初始化； 浏览器窗口尺寸改变——resize事件发生时； 3. **如何减少和避免重排 **#Reflow 的成本比 Repaint 的成本高得多的多。一个节点的 Reflow 很有可能导致子节点，甚至父节点以及兄弟节点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。 直接改变className，如果动态改变样式，则使用cssText（考虑没有优化的浏览器）； 让要操作的元素进行”离线处理”，处理完后一起更新； 使用DocumentFragment进行缓存操作,引发一次回流和重绘； 使用display:none技术，只引发两次回流和重绘； 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘； 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存； 让元素脱离动画流，减少回流的Render Tree的规模； 网络请求#TCP 三次握手建立连接#TCP 四次握手断开连接#Q &amp; A#为什么要将js放到页脚部分#引入样式的几种方式的权重#css属性书写顺序建议#何种类型的DOM操作是耗费性能的#参考文档#参考文档1how browsers workhow browsers work中文翻译","link":"/2021/01/29/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%B8%8E%E7%BD%91%E8%B7%AF%E8%AF%B7%E6%B1%82/"},{"title":"前端进阶之LRU实现","text":"参考文档","link":"/2021/02/19/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8BLRU%E5%AE%9E%E7%8E%B0/"},{"title":"算法基础-递归","text":"L. Peter Deutsch 说过：To Iterate is Human, to Recurse, Divine.中文译为：人理解迭代，神理解递归。 概念#递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。特别地，在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数调用它自身的情况，这也正是递归的定义所在。格外重要的是，这个解决问题的函数必须有明确的结束条件，否则就会导致无限递归的情况。 =&gt; 数学归纳法 数学归纳法适用于将解决的原问题转化为解决它的子问题，而它的子问题又变成子问题的子问题，而且我们发现这些问题其实都是一个模型，也就是说存在相同的逻辑归纳处理项。当然有一个是例外的，也就是归纳结束的那一个处理方法不适用于我们的归纳处理项，当然也不能适用，否则我们就无穷归纳了 三要素#明确递归终止条件#我们知道，递归就是有去有回，既然这样，那么必然应该有一个明确的临界点，程序一旦到达了这个临界点，就不用继续往下递去而是开始实实在在的归来。换句话说，该临界点就是一种简单情境，可以防止无限递归。 给出递归终止时的处理办法#我们刚刚说到，在递归的临界点存在一种简单情境，在这种简单情境下，我们应该直接给出问题的解决方案。一般地，在这种情境下，问题的解决方案是直观的、容易的。 提取重复的逻辑，缩小问题规模#我们在阐述递归思想内涵时谈到，递归问题必须可以分解为若干个规模较小、与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决。从程序实现的角度而言，我们需要抽象出一个干净利落的重复的逻辑，以便使用相同的方式解决子问题。 编程模型#模型一： 在递去的过程中解决问题#12345678function recursion(大规模){ if (end_condition) { // 明确的递归终止条件 end; // 简单情景 } else { // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题 solve; // 递去 recursion(小规模); // 递到最深处后，不断地归来 }} 模型二： 在归来的过程中解决问题#12345678function recursion(大规模){ if (end_condition) { // 明确的递归终止条件 end; // 简单情景 } else { // 先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题 recursion(小规模); // 递去 solve; // 归来 }} 例子#123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235/*** Title: 阶乘的实现 * Description:* 递归解法* 非递归解法* @author rico*/const Factorial = (n)=&gt; { if(n == 1) // 递归终止条件 return 1; // 简单情景 return n * Factorial(n-1); // 相同重复逻辑，缩小问题的规模}/** 斐波那契数列如下：* 1,1,2,3,5,8,13,21,34,...*/const fibonacci = (n)=&gt; { if (n == 1 || n == 2) return 1; return fibonacci(n-1) + fibonacci(n-2);}/** * @description 对经典递归法的优化 * * 斐波那契数列如下： * * 1,1,2,3,5,8,13,21,34,... * * 那么，我们可以这样看：fib(1,1,5) = fib(1,2,4) = fib(2,3,3) = 5 * * 也就是说，以1,1开头的斐波那契数列的第五项正是以1,2开头的斐波那契数列的第四项， * 而以1,2开头的斐波那契数列的第四项也正是以2,3开头的斐波那契数列的第三项， * 更直接地，我们就可以一步到位：fib(2,3,3) = 2 + 3 = 5,计算结束。 * * 注意，前两个参数是数列的开头两项，第三个参数是我们想求的以前两个参数开头的数列的第几项。 * 时间复杂度：O(n)* * @param first 数列的第一项* @param second 数列的第二项* @param n 目标项* @return */const optimizeFibonacci = (first, second, n)=&gt; { if (n &gt; 0) { if(n == 1){ // 递归终止条件 return first; // 简单情景 }else if(n == 2){ // 递归终止条件 return second; // 简单情景 }else if (n == 3) { // 递归终止条件 return first + second; // 简单情景 } return optimizeFibonacci(second, first + second, n - 1); // 相同重复逻辑，缩小问题规模 } return -1;}/** * 杨辉三角 * 杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)i的展开式的系数。* 它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。* * 例如，下面给出了杨辉三角形的前4行： * 1 * 1 1* 1 2 1* 1 3 3 1* @description 递归获取杨辉三角指定行、列(从0开始)的值* 注意：与是否创建杨辉三角无关* @x 指定行* @y 指定列 */const trangleValue = (x, y)=&gt; { if(y &lt;= x &amp;&amp; y &gt;= 0){ if(y == 0 || x == y){ // 递归终止条件 return 1; }else{ // 递归调用，缩小问题的规模 return trangleValue(x-1, y-1) + trangleValue(x-1, y); } } return -1;}/** * @description 递归判断一个字符串是否是回文字符串 * @param s * @return */const isPalindromeString_recursive = (s)=&gt; { let start = 0; let end = s.length - 1; if(end &gt; start){ // 递归终止条件:两个指针相向移动，当start超过end时，完成判断 if(s.charAt(start) != s.charAt(end)){ return false; }else{ // 递归调用，缩小问题的规模 return isPalindromeString_recursive(s.substring(start+1).substring(0, end-1)); } } return true;}/** * 字符串全排列 * @description 从字符串数组中每次选取一个元素，作为结果中的第一个元素;然后，对剩余的元素全排列* @param s* 字符数组* @param from* 起始下标* @param to* 终止下标*/const getStringPermutations3 = (s, from, to)=&gt; { if (s != null &amp;&amp; to &gt;= from &amp;&amp; to &lt; s.length &amp;&amp; from &gt;= 0) { // 边界条件检查 if (from == to) { // 递归终止条件 console.log(s); // 打印结果 } else { for (let i = from; i &lt;= to; i++) { swap(s, i, from); // 交换前缀,作为结果中的第一个元素，然后对剩余的元素全排列 getStringPermutations3(s, from + 1, to); // 递归调用，缩小问题的规模 swap(s, from, i); // 换回前缀，复原字符数组 } } } }const swap = (s, from, to)=&gt; { let temp = s[from]; s[from] = s[to]; s[to] = temp;}/*** @description 二分查找的递归实现* @param array 目标数组* @param low 左边界* @param high 右边界* @param target 目标值* @return 目标值所在位置*/const binarySearch = (array, low, high, target)=&gt; { //递归终止条件 if(low &lt;= high){ let mid = (low + high) &gt;&gt; 1; if(array[mid] == target){ return mid + 1; // 返回目标值的位置，从1开始 } else if(array[mid] &gt; target){ // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除 return binarySearch(array, low, mid-1, target); } else{ // 由于array[mid]不是目标值，因此再次递归搜索时，可以将其排除 return binarySearch(array, mid+1, high, target); } } return -1; //表示没有搜索到}/*** Title: 递归求解二叉树的深度*/const getTreeDepth = (t) =&gt; { // 树为空 if (t == null) // 递归终止条件 return 0; let left = getTreeDepth(t.left); // 递归求左子树深度，缩小问题的规模 let right = getTreeDepth(t.left); // 递归求右子树深度，缩小问题的规模 return left &gt; right ? left + 1 : right + 1;}/* 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。*/var generateParenthesis = function (n) { const res = []; const dfs = (lRemain, rRemain, str) =&gt; { // 左右括号所剩的数量，str是当前构建的字符串 if (str.length == 2 * n) { // 字符串构建完成 res.push(str); // 加入解集 return; // 结束当前递归分支 } if (lRemain &gt; 0) { // 只要左括号有剩，就可以选它，然后继续做选择（递归） dfs(lRemain - 1, rRemain, str + &quot;(&quot;); } if (lRemain &lt; rRemain) { // 右括号比左括号剩的多，才能选右括号 dfs(lRemain, rRemain - 1, str + &quot;)&quot;); // 然后继续做选择（递归） } }; dfs(n, n, &quot;&quot;); // 递归的入口，剩余数量都是n，初始字符串是空串 return res;};/* 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。*/function ListNode(val, next) { this.val = (val===undefined ? 0 : val) this.next = (next===undefined ? null : next)}var reverseKGroup = function(head, k) { if(!head) return head; let tmpArray = [], tmpHeader = new ListNode(head.val, head.next) for(let i = 0; i &lt; k; i++) { if(tmpHeader) { tmpArray.push(tmpHeader) } else { break; } tmpHeader = tmpHeader.next } if(tmpArray.length &lt; k) { return head } let nextUnitHeader = reverseKGroup(tmpHeader, k) for(let i = k - 1; i &gt; 0; i --) { let node = tmpArray[i] node.next = tmpArray[i-1] } tmpArray[0].next = nextUnitHeader return tmpArray[k-1]};let reverseKGroupNode1 = new ListNode(1)let reverseKGroupNode2 = new ListNode(2, reverseKGroupNode1)let reverseKGroupNode3 = new ListNode(3, reverseKGroupNode2)let reverseKGroupNode4 = new ListNode(4, reverseKGroupNode3) 参考文档#csdn","link":"/2021/02/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92/"},{"title":"canvas-weapp-h5","text":"忙完公司关于海报制作的需求，开这篇文章扯扯canvas！ fabric.js 画布 canvas 文本、图片：最基本的海报要素 Text Image 图层高度 自定义编辑框 自定义编辑功能 联调 1. 授权验证 WE-APP APP(RN) 2. 选择照片 WE-APP APP(RN) 3. 传递数据 WE-APP APP(RN) NOTE safeArea qrcode 二维码 fabricObject自定义附加字段 服务端处理 截取指定区域 字体 最开始的需求是在小程序内简单实现可以手动编辑的海报，不是根据数据直接套模板生成海报。找了github, 最终选的是疑似酷家乐团队的Painter。用下来基本能满足需求，但是遇到了两个问题： 新需求：可能需要整APP，那就意味着我得有个RN下的canvas组件、或者就是H5上整canvas; 调试困难：不知道是不是系统原因还是啥，mac上跑小程序编辑器一直都不是很流畅，一旦页面上跑得东西多了，动不动就可以去喝杯咖啡.. sad 接下来的小程序页面中又多加了一个需求：需要将整好的数据直接导出成图片。 首先想到的就是wxml-to-canvas。 用这还行，不过考虑到后续APP也会有相同的需求，最终把wxml-to-canvas放下，选择了H5上的canvas方案。wxml-to-canvas没法直接使用iconfont, 得把icon换成img才行。 在H5的现有方案中，首先选中的是小飞飞的easy-canvas. 但这个项目尚未支持z-index, 担心后续有图层调整相关的要求，无奈放弃。在小飞飞推荐下，开始折腾fabric.js 不用翻墙就能看的官网地址 github上有好心的前人写了中文文档. 稍微有点久远，不过用来初步入门已经足够了。 在此，就不赘述一些基本使用方法，直接按照项目中常见的需求来展开。 fabric.js#画布 canvas#12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;canvas-box&quot;&gt; &lt;canvas id=&quot;canvas&quot; :width='width' :height='height'&gt;&lt;/canvas&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import {fabric} from 'fabric';export default { data: ()=&gt; ({ width: 360, height: 640, canvas: '' }), created: function() { //预加载数据,组装等 }, mounted: function() { //canvas赋值必须得等页面加载之后才行 this.canvas = new fabric.Canvas('canvas') }, methods: { }}&lt;/script&gt; 文本、图片：最基本的海报要素#fabric.js项目作者将所有画布上的对象抽象为fabric.Object。其他所有的文本、图像之类全是基于这个基类。 Text#12345678910111213141516171819202122232425262728let obj = { text: '文本内容', //这里有借鉴Painter项目 css: { left: 100, top: 100, fontWeight: 600, color: '#fff', }}let text = new fabric.Text( obj.text, { left: obj.css.left, top: obj.css.top, fontFamily: 'Comic Sans' , fontSize: obj.css.fontSize || 20, fontWeight: obj.css.fontWeight, fill:obj.css.color, originX: obj.css.originX ||'left', })//绑定点击(选中)事件，默认是支持的，这里是为了调用自定义的编辑框text.on('selected', _this.selectedHandle)//可以配置fabric.Object不可被选中text.set('selectable', !!obj.editAble);this.canvas.add(text);//moveTo方法将在后续控制层高的地方讲到text.moveTo(1) Text有个进阶的Object: IText tips: Text可以设置padding, 默认的编辑框border距离文本实在是太近了，尤其是需要自定义编辑框按钮的时候，挨得太近根本没办法好好显示按钮，通过设置这个参数，就可以开心的留一些区域给按钮啦 Image#12345678910111213141516171819202122232425262728//加载跨域图片new fabric.Image.fromURL(obj.url, function(img) { //这里img.width/height是图片的原始宽高，单位px console.log(img.width , img.height, obj.css.width) let scaleRatio = obj.css.width / img.width //通过scale使图片适应设定的宽高 img.scale(scaleRatio); //可以设置翻转 // oImg.scale(0.5).set('flipX, true); img.on('selected', _this.selectedHandle) img.top = obj.css.top img.left = obj.css.left //不设置height,避免选择框不能匹配图像边缘 img.on('selected', _this.selectedHandle) img.set('selectable', !!obj.editAble);}, {crossOrigin: 'anonymous'})//加载本地图片// &lt;canvas id=&quot;c&quot;&gt;&lt;/canvas&gt;// &lt;img src=&quot;my_image.png&quot; id=&quot;my-image&quot;&gt;var canvas = new fabric.Canvas('c');var imgElement = document.getElementById('my-image');var imgInstance = new fabric.Image(imgElement, { left: 100, top: 100, angle: 30, opacity: 0.85});canvas.add(imgInstance); 加载跨域图片时候需要设置crossOrigin参数。 所有的fabric.Object下子类都是公用编辑框(controls)的 加载图片是个异步操作，不能保证所有Object的先后顺序。这就需要配合之前所说的moveTo函数来控制其图层高度。 图层高度#点此查看介绍文档 图层高度同z-index, 数值大的可以遮挡数值小的。控制图层一般用到这几个方法： 12345obj.bringToFront(); // 置顶obj.bringForward(); // 向上一层obj.sendToBack(); // 置底obj.sendBackwards(); // 向下一层obj.moveTo(n); // 设置层高N 自定义编辑框#fabric.js自带的编辑框还是蛮丑的… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103selectedHandle: function() { //getActiveObject()可以获取当前被选中的对象 -&gt; 进而获取其类型 let type = this.canvas.getActiveObject() ? this.canvas.getActiveObject().type : null type &amp;&amp; this.setupEditBox(type) //如果是文本, 则显示文本编辑菜单，如果是图片则显示图片菜单 this.showTextMenu = type == 'text' this.showImgMenu = type == 'image'},setupEditBox: function(targetType) { //首先隐藏默认的编辑框上的所有小点(按钮) Object.values(fabric.Object.prototype.controls).forEach(c =&gt; c.visible = false); //可以理解为原生按钮支持的事件handler let controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls; //icon直接用的base64 png图片，这里不适合全部黏贴上来，后续补充demo的时候，可以去demo查看 //编辑框画自定义的按钮还没尝试其他方法... 后续尝试下新的放方法 let _this = this, editIcon64 = 'data:image/png;base64,...' let eidtIconImg = document.createElement('img'); eidtIconImg.src = editIcon64; let scaleIcon64 = 'data:image/png;base64,...' let scaleIconImg = document.createElement('img'); scaleIconImg.src = scaleIcon64; let textCloseIcon64 = 'data:image/png;base64,...'; let textCloseIconImg = document.createElement('img'); textCloseIconImg.src = textCloseIcon64; //edit即为这个新按钮的名称，可以随意取 fabric.Object.prototype.controls.edit = new fabric.Control({ x: 0, //x y是以Object中心点为0的, 向上为Y负轴， 向左为X负轴 y: -0.5, //0.5其实指的是 height * 0.5 offsetY: -30, //30的单位是px cursorStyle: 'pointer', mouseUpHandler: _this.showEditPopover, //点击事件的handler，请看下一小节 render: renderTextEditIcon, //自定义绘制按钮 cornerSize: 32, visible: targetType == 'text' }); fabric.Object.prototype.controls.scale = new fabric.Control({ x: 0.5, y: 0.5, cursorStyle: 'pointer', render: renderImageScaleIcon, cornerSize: 32, actionHandler:scalingEqually, visible: targetType == 'image' }); fabric.Object.prototype.controls.text_close = new fabric.Control({ x: 0, y: 0.5, offsetY: 30, cursorStyle: 'pointer', render: renderTextCloseIcon, cornerSize: 32, mouseUpHandler: _this.deleteTextHandle, visible: targetType == 'text' }); //其实我也不想在这里写function, 试了下写外面，结果绘制没成功... sad function renderImageScaleIcon(ctx, left, top, styleOverride, fabricObject) { let w = 32, h = 32; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(scaleIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw edit box for img done') } function renderTextEditIcon(ctx, left, top, styleOverride, fabricObject) { let w = 32, h = 32; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(eidtIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw edit icon for text done') } function renderTextCloseIcon(ctx, left, top, styleOverride, fabricObject) { let w = 30, h = 30; ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle)); ctx.drawImage(textCloseIconImg, -w/2, -h/2, w, h); ctx.restore(); console.log('draw close icon for text done') }}, 自定义编辑功能#在controls.edit我们指定了mouseUpHandler为showEditPopover。control.close用了一样的方式来获取点击事件。 12345678910showEditPopover: function(eventData, target) { //没直接用传参 let obj = this.canvas.getActiveObject() if (!obj || obj.type != 'text') { return } //如果是文本被点击，则弹出modle允许编辑 this.showTextEditModel = true; this.textEditModelContent = obj.text}, 当我们的model中修改文本内容完成，则可以用下面的方法替换画布上的文本 12345678confirmTextEdit: function() { let obj = this.canvas.getActiveObject() if (!!obj &amp;&amp; obj.type == 'text') { obj.text = this.textEditModelContent } this.canvas.requestRenderAll(); //重新渲染画布 this.showTextEditModel = false //清除model}, 联调#涉及到联调的主要是这几个功能点： we-app的授权验证 选取移动端本地(相册)的照片 fabric.js生成的图片传给APP或者we-app使用 1. 授权验证#WE-APP#先引入wx-jdk，我是先在index.html顶部加载，然后通过vue的配置来获取的 vue.config.js12345configureWebpack: { externals: { 'weixin-js-sdk': 'wx' },}, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364created: function() { let _this = this //确认是否是在小程序中 wx.miniProgram.getEnv(function(res) { console.log(res.miniprogram) _this.weAppEnv = res.miniprogram })},mounted: function() { if(this.weAppEnv) { this.initWxConfig() }},methods: { initWxConfig: function() { let url = window.location.href url = url.split('#')[0] const promise = axios.get('/api/wechat/h5/sign/share' + '?app_id=' + this.appId + '&amp;url=' + url); promise.then(res =&gt; { if (res.data.code == 200) { const sign = res.data.data; this._wxConfigJSSDK(sign); } }); promise.catch((err) =&gt; { console.log(err.response); }) }, _wxConfigJSSDK: function(sign){ wx.config({ debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: sign.appId + '', // 必填，公众号的唯一标识 timestamp: parseInt(sign.timestamp), // 必填，生成签名的时间戳 nonceStr: sign.nonceStr + '', // 必填，生成签名的随机串 signature: sign.signature + '',// 必填，签名 jsApiList: ['chooseImage', 'downloadImage', 'previewImage', 'uploadImage'] // 必填，需要使用的JS接口列表 }) wx.ready(function(){ wx.checkJsApi({ jsApiList: [ 'chooseImage', 'previewImage', 'uploadImage', 'downloadImage' ], success: function (res) { if (res.checkResult.getLocation == false) { console.error('你的微信版本太低，不支持微信JS接口，请升级到最新的微信版本！'); return; }else{ console.log('授权成功', res) } }, fail: err=&gt; { console.log(err) } }); }); wx.error(function(res){ console.error(res) }); },} 中间涉及到一个appId,即为调用该页面的小程序关联的公众号appid 当我们需要调用分享(APP、H5内),就需要进行签名。具体逻辑参照官方文档 切记将这个fabric.js所在的域名添加到公众号下的安全域名内，没错，公众号！！！和小程序关联的公众号，同主体，同开发者平台账号下 切记将这个fabric.js所在的域名添加到小程序的合法业务域名下 小程序开发工具-网页模式可以用来调试当前fabric.js页面 小程序开发工具-小程序模式没办法使用模拟器来测试授权，必须真机测试！！！一般来说上一步的网页模式测试没问题，真机也不会有问题 不涉及选择照片功能的话，可以不授权。 APP(RN)#RN内好像没涉及授权问题 2. 选择照片#WE-APP#借用wx-js-sdk来手机上的照片，也可以支持拍照。前提是完成wx.config 1234567891011121314151617181920212223242526272829303132_getLocalImage: function() { let _this = this return new Promise((resolve, reject)=&gt; { wx.chooseImage({ count: 1, // 默认9 sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有 sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有 success: function (res) { var localIds = res.localIds; // 返回选定照片的本地ID列表，localId可以作为img标签的src属性显示图片 let targetImgId = localIds[0] console.log('wkwebview is' + !!window.__wxjs_is_wkwebview) wx.getLocalImgData({ localId: targetImgId, success: (res) =&gt; { let localData = res.localData // localData是图片的base64数据，可以用img标签显示 if (localData.indexOf('data:image') != 0) { //判断是否有这样的头部 =&gt; 兼容安卓机型（安卓机不包含data头） localData = 'data:image/jpeg;base64,' + localData } resolve(localData) }, fail: err=&gt; { reject(err) } }) }, fail: err=&gt; { reject(err) } }); })}, APP(RN)#rn中的选择照片就相对简单一点。主要是用到组件react-native-image-picker 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;Avatar containerStyle={styles.avatar} rounded size=&quot;large&quot; source={{ uri: 'https://' + this.props.agent.avatar }} title={!this.props.agent.avatar ? '店': null} &gt; &lt;Avatar.Accessory name=&quot;edit&quot; size={25} onPress={()=&gt; { let options = { mediaType: 'photo', maxWidth: '320', maxHeight: '320', quality: '0.8', }, callback = async (res) =&gt; { if(res &amp;&amp; res.uri) { let loading = Toast.loading('即将上传，请稍候', 0) let token = await applyToken() if(token) { Toast.remove(loading) let uploadLoading = Toast.loading('正在上传', 0), key = 'agent/avatar/' + this.props.agent.id + '/' + new Date().getTime() + '.jpg' upload( { key: key, path: res.uri.replace('file://', ''), //这个是关键 mimeType: res.type, token: token, zone: ZONE.HUABEI, }, null ).then(data =&gt; { console.log(data) Toast.remove(uploadLoading) Toast.success('上传成功', 2, ()=&gt; { let avatarURL = 'oss-xxx.XXX.com/' + data.key this.props.updateAgentAvatar({avatar: avatarURL}) //追加同步服务器的步骤 }) }) .catch(err =&gt; { console.error(err) if (err.code === CODE.UPLOAD_FAILURE) { console.log('upload error') } }) } } } launchImageLibrary(options, callback) }} /&gt;&lt;/Avatar&gt; 3. 传递数据#WE-APP#H5传数据给小程序的webview，难点在于接收数据的时机和页面切换。 用户点击H5上的生成海报时，先将base64数据postMsg给小程序，然后执行wx.miniProgram.redirectTo(‘url?params’) 嵌套H5的页面中webview绑定msgHandler接收H5传上来的数据,并存storage 跳转后的页面接收params, 稍作定时(假装loading)后，从storage中获取数据，转base64为本地文件展示。 APP(RN)#h512345let obj = { type: 'generate-img', img: cripedImage //base64}window.ReactNativeWebView &amp;&amp; window.ReactNativeWebView.postMessage(JSON.stringify(obj)) rn1234567891011121314151617181920212223242526272829//为了更好的区分H5是谁调用的，可以在此webview中设置前缀script(后续再补充)&lt;WebView onLoad={(e) =&gt; console.log('onLoad')} onLoadEnd={(e) =&gt; console.log('onLoadEnd')} onLoadStart={(e) =&gt; console.log('onLoadStart')} renderError={() =&gt; { console.log('renderError') return &lt;View&gt;&lt;Text&gt;renderError回调了，出现错误&lt;/Text&gt;&lt;/View&gt; }} renderLoading={() =&gt; { return &lt;View&gt;&lt;Text&gt;这是自定义Loading...&lt;/Text&gt;&lt;/View&gt; }} source={{uri: this.state.url}} //h5页面地址 style={{marginTop: 20}} onMessage={this._onMessage} //接收上面传过来的参数/&gt;_onMessage = (event)=&gt; { let webString = event.nativeEvent ? event.nativeEvent.data : '' if(webString) { let obj = JSON.parse(webString) if(obj &amp;&amp; obj.type == 'generate-img') { Actions['poster-preview']({ img: obj.img }) return } } console.log('H5-&gt;RN传参错误')} NOTE#safeArea#qrcode 二维码#fabricObject自定义附加字段#服务端处理#参考文档 截取指定区域#参考文档 123456789101112131415161718192021222324252627282930313233/** Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately* @param {Object} [options] Options object* @param {String} [options.format=png] The format of the output image. Either &quot;jpeg&quot; or &quot;png&quot;* @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.* @param {Number} [options.multiplier=1] Multiplier to scale by, to have consistent* @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14* @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14* @param {Number} [options.width] Cropping width. Introduced in v1.2.14* @param {Number} [options.height] Cropping height. Introduced in v1.2.14* @param {Boolean} [options.enableRetinaScaling] Enable retina scaling for clone image. Introduce in 2.0.0* @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format* @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}*/// @example &lt;caption&gt;Generate jpeg dataURL with lower quality&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'jpeg', quality: 0.8 });// @example &lt;caption&gt;Generate cropped png dataURL (clipping of canvas)&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'png', left: 100, top: 100, width: 200, height: 200 });// @example &lt;caption&gt;Generate double scaled png dataURL&lt;/caption&gt; var dataURL = canvas.toDataURL({ format: 'png', multiplier: 2 }); 字体#Q: 小程序内嵌H5， H5使用fabric, 但画布上的英文字很明显不是选用的字体? (后来发现这个是Times New Roman)A: 最开始怀疑是微信浏览器最字体做了限制，官方文档,后台注意到嵌入fabric的H5页面，非canvas内部的字体并没有受到影响。至此： 字体支持应该是设置的字体在电脑端(测试时)存在，但真机时并没有 尝试在真机上设置Text的字体为苹方，上述猜想得到证实 接下来就是得想办法让真机能支持自己设置的字体-&gt; 区分机型，并为不同机型寻找合适的字体PS: 至于node端设置字体，请参考这个文章","link":"/2020/12/28/canvas-weapp-h5/"},{"title":"React Native APP开发(2)","text":"采用RN开发APP基础篇 React基础 1. class组件 2. 路由-组件跳转 3. 状态管理 action reducer Store 数据流 全局引用 异步Action 4. 数据持久化 后记 React基础#安利个网站snack，方便在线调试自己写的代码(尤其是起步阶段，避免眼高手低) 可以不用注册，保存个链接，必要的时候赋值代码进去修改/运行 1. class组件#javascript123456789import React, { Component } from 'react';import { Text } from 'react-native';export default class Cat extends Component { render() { return ( &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; ); }} props对应外部传入的参数， 一般不在内部修改state对应组件内部的参数, 根据用户交互行为变更/赋值 javascript12345678910111213141516171819202122232425262728293031323334import React, { Component } from &quot;react&quot;;import { Button, Text, View } from &quot;react-native&quot;;export class Cat extends Component { state = { isHungry: true }; render() { return ( &lt;View&gt; &lt;Text&gt; I am {this.props.name}, and I am {this.state.isHungry ? &quot; hungry&quot; : &quot; full&quot;}! &lt;/Text&gt; &lt;Button onPress={() =&gt; { this.setState({ isHungry: false }); }} disabled={!this.state.isHungry} title={ this.state.isHungry ? &quot;Pour me some milk, please!&quot; : &quot;Thank you!&quot; } /&gt; &lt;/View&gt; ); }}export default class Cafe extends Component { render() { return ( &lt;&gt; &lt;Cat name=&quot;Munkustrap&quot; /&gt; &lt;Cat name=&quot;Spot&quot; /&gt; &lt;/&gt; ); }} 在class形式的组件中，不用管props的内部结构，只需要注意引用组件时怎么传递参数。 state 参数的命名方式需要注意。 onPress赋值的应该是一个函数，也可以直接提出来写 render返回必须用()包起来， 所有的模板内容必须用一个元素包起来，不能出现并列的多个元素javascript12345678910111213141516171819202122232425import React, { Component } from 'react';import { Text, Button, View } from 'react-native';export default class Cat extends Component { state = { showName: false, } showName = ()=&gt; { if(this.state.showName) return; this.setState({ showName: true }) } render() { return ( &lt;View&gt; &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; { this.state.showName ? (&lt;Text&gt;My name is Lily!&lt;/Text&gt;) : (null)} &lt;Button onPress={this.showName} title=&quot;show my name&quot;&gt;&lt;/Button&gt; &lt;/View&gt; // &lt;View&gt; // &lt;Text&gt;这个View-Text不能写, 类似于Vue只能有一个根元素&lt;/Text&gt; // &lt;/View&gt; ); }} 2. 路由-组件跳转#类似于vue-router，rn的路由管理组件为react-native-router-flux, 需要注意的是该组件有多个大版本，对应不同版本的react-navigation，查阅文档的时候请先留意版本是否匹配。官方还有react-router方案可选.当前以最新版V4.2.0为例。 首先构建两个页面(sence) javascript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//login.jsimport React, {Component} from 'react';import {View, Text, SafeAreaView,StatusBar} from 'react-native';import {Actions} from &quot;react-native-router-flux&quot;;export default class Login extends Component { gotoRegister = (params)=&gt; { Actions.register() } render() { return ( &lt;&gt; &lt;StatusBar&gt;&lt;/StatusBar&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text&gt;登录页面&lt;/Text&gt; &lt;Button onPress={this.gotoRegister} type=&quot;primary&quot; title=&quot;没有账号，立即注册&quot;&gt;&lt;/Button&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); }}//import React, {Component} from 'react';import {View, Text, SafeAreaView,StatusBar} from 'react-native';import {Actions} from &quot;react-native-router-flux&quot;;export default class Register extends Component { gotoIndex = (params)=&gt; { Actions.reset('index', {}) } render() { return ( &lt;&gt; &lt;StatusBar&gt;&lt;/StatusBar&gt; &lt;SafeAreaView&gt; &lt;View&gt; &lt;Text&gt;注册页面&lt;/Text&gt; &lt;Button onPress={this.gotoIndex} type=&quot;primary&quot; title=&quot;前往首页&quot;&gt;&lt;/Button&gt; &lt;/View&gt; &lt;/SafeAreaView&gt; &lt;/&gt; ); }} 构建APP.js javascript123456789101112131415161718192021222324import React, { Component } from 'react';import Login from './container/Login';import Register from './container/Register';import Index from './container/Index';import {Stack, Scene, Router, Actions, Tabs} from 'react-native-router-flux';export default class App extends Component&lt;Props&gt; { render() { return ( &lt;Router&gt; &lt;Stack key=&quot;root&quot; title=&quot;测试&quot;&gt; &lt;Scene key=&quot;login&quot; component={Login} initial=&quot;true&quot; //设置默认页面 title=&quot;Login&quot; /&gt; &lt;Scene key=&quot;register&quot; component={Register} title=&quot;Register&quot; /&gt; &lt;Scene key=&quot;index&quot; component={Index} hideNavBar /&gt; &lt;/Stack&gt; &lt;/Router&gt; ); }} react-native-router-flux提供了便捷的路由跳转API,可以通过在app.js内设置的sence.key搭配Actions直接跳转 javascript123456let props = { shopId: 123}Actions.login(props)// 等同于Actions.push('login', props) 常用的的API如下, javascript123456789101112131415// 返回上一页面Actions.pop();// 返回指定页面(堆栈中)Actions.popTo('key'); // 刷新页面Actions.refresh({ param1: 'hello', param2: 'world' });// 清空当前页面堆栈，重新打开指定的页面Actions.reset('index', props)// tabbar之间切换Actions.jump('key') 3. 状态管理#APP内往往需要全局共享用户的登录状态、昵称、头像等，这时候就需要状态管理组件react-redux。在使用react-redux之前，先了解下redux的一些基本概念。 action reducer store NOTE应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。惟一改变 state 的办法是触发 action(一个描述发生什么的对象)。为了描述 action 如何改变 state 树，你需要编写 reducers。 action#Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。 javascript12345678910//建议单独文件存放const ADD_TODO = 'ADD_TODO'import { ADD_TODO, REMOVE_TODO } from '../actionTypes'//action对象{ type: ADD_TODO, text: 'Build my first Redux app'} action creator之前说action是一个普通对象，action creator则是一个函数，根据传参来返回需要的action.如果我们把store对应的state想象成是一个人， 那么action就是各种人所包含动作的描述。 javascript123456789{ type: '跑步',}{ type: '平躺',}... action除type可以自定义各种属性，所以我们可以这样来细化action javascript12345678910111213141516{ type: '跑步', speed: '慢速',}{ type: '跑步', speed: '中速',}{ type: '跑步', speed: '快速',}... 这时候我们就会想，需要根据某个传参(比如说跑步前吃的多不多)来确定自己具体使用哪个action(跑多快),这就引出了creator函数 javascript12345678910111213141516171819function run(payload) { if(payload.full == 1) { return { type: '跑步', speed: '慢速', } } else if (payload.full == 0) { return { type: '跑步', speed: '快速', } } else { return { type: '跑步', speed: '中速', } }} 进一步， 我们也会根据其他参数来定义更加丰富的action(根据零花钱来确定是跑回去呢，还是打车等等)总的来看action creator的思路和java中的工厂模式类似。 javascript12345678910111213141516171819202122232425262728293031323334/* * action 类型 */export const ADD_TODO = 'ADD_TODO';export const TOGGLE_TODO = 'TOGGLE_TODO'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'/* * 其它的常量 */export const VisibilityFilters = { SHOW_ALL: 'SHOW_ALL', SHOW_COMPLETED: 'SHOW_COMPLETED', SHOW_ACTIVE: 'SHOW_ACTIVE'}/* * action 创建函数 */export function addTodo(text) { return { type: ADD_TODO, text }}export function toggleTodo(index) { return { type: TOGGLE_TODO, index }}export function setVisibilityFilter(filter) { return { type: SET_VISIBILITY_FILTER, filter }} Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。 javascript12dispatch(addTodo(text))dispatch(completeTodo(index)) 或者创建一个 被绑定的 action 创建函数 来自动 dispatch： javascript12const boundAddTodo = text =&gt; dispatch(addTodo(text))const boundCompleteTodo = index =&gt; dispatch(completeTodo(index)) 然后直接调用它们： javascript12boundAddTodo(text);boundCompleteTodo(index); reducer#reducer 是一个纯函数，接收旧的 state 和 action，返回新的 state。 1(previousState, action) =&gt; newState 保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 1234567891011121314151617181920212223242526272829303132333435import { WALK, RUN, TAXI } from './actions'const initialState = { useVehicle: false, costMoney: false speed: null};function backHome(state, action) { if (typeof state === 'undefined') { return initialState } //处理其他action return state}//上述undefined的判断可以精简为如下function todoApp(state = initialState, action) { switch (action.type) { case WALK.type: return Object.assign({}, state, { useVehicle: false, costMoney: false speed: '5km/h' }) case RUN.type: return { ...state, useVehicle: false, costMoney: false speed: '15km/h' }) default: return state }} reducer合并 12345678910111213141516import { combineReducers } from 'redux'const todoApp = combineReducers({ visibilityFilter, mytodo: todos})export default todoApp//等价于export default function todoApp(state = {}, action) { return { visibilityFilter: visibilityFilter(state.visibilityFilter, action), todos: todos(state.todos, action) }} Store#Store的功能： 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 方法更新 state； 通过 subscribe(listener) 注册监听器; 通过 subscribe(listener) 返回的函数注销监听器。 12345import { createStore } from 'redux'import todoApp from './reducers'let store = createStore(todoApp)// 设置初始状态let store = createStore(todoApp, window.STATE_FROM_SERVER) 数据流#严格的单向数据流是 Redux 架构的设计核心。应用中所有的数据都遵循相同的生命周期，这样可以让应用变得更加可预测且容易理解。 Redux 应用中数据的生命周期遵循下面 4 个步骤： 调用 store.dispatch(action); Redux store 调用传入的 reducer 函数: Store 会把两个参数(当前的 state 树和 上述action)传入 reducer; 根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树 Redux store 保存了根 reducer 返回的完整 state 树 NOTE Redux 和 React 之间没有关系 Redux 的 React 绑定库(react-redux)是基于 容器组件和展示组件相分离 的开发思想 全局引用#React Redux 组件 让所有容器组件都可以访问 store，而不必显示地传递它。只需要在渲染根组件时使用即可。 123456789101112131415import React from 'react'import { render } from 'react-dom'import { Provider } from 'react-redux'import { createStore } from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp)render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 异步Action#默认情况下，createStore() 所创建的 Redux store 没有使用 middleware，所以只支持 同步数据流。你可以使用 applyMiddleware() 来增强 createStore()。虽然这不是必须的，但是它可以帮助你用简便的方式来描述异步的 action。像 redux-thunk 或 redux-promise 这样支持异步的 middleware 都包装了 store 的 dispatch() 方法，以此来让你 dispatch 一些除了 action 以外的其他内容，例如：函数或者 Promise。你所使用的任何 middleware 都可以以自己的方式解析你 dispatch 的任何内容，并继续传递 actions 给下一个 middleware。比如，支持 Promise 的 middleware 能够拦截 Promise，然后为每个 Promise 异步地 dispatch 一对 begin/end actions。当 middleware 链中的最后一个 middleware 开始 dispatch action 时，这个 action 必须是一个普通对象。这是 同步式的 Redux 数据流 开始的地方（译注：这里应该是指，你可以使用任意多异步的 middleware 去做你想做的事情，但是需要使用普通对象作为最后一个被 dispatch 的 action ，来将处理流程带回同步方式）。项目中，我们常常会需要发起异步请求，这时候action就会需要异步等待请求的结果(success or fail)。请先在项目引入redux-thunk，以发起请求为例 actions123{ type: 'REQUEST_POST' }{ type: 'RECEIVE_POSTS', error: 'Oops', response: null }{ type: 'RECEIVE_POSTS', response: { ... }, error: null } 构建action creator, 三个同步action: 发起请求 请求成功 请求失败123456789101112131415161718192021222324//通知 reducer 请求开始的 actionexport function requestPosts(){ return { type: REQUEST_POSTS, isFetch:true //进度条相关 }} //通知 reducer 请求成功的 actionexport function receviePostOnSuccess(data){ return { type: RECEIVE_POSTS, isFetch:false, amount: data }} //通知 reducer 请求失败的 action。export function receviePostOnError( message){ return{ type: RECEIVE_POSTS, isFetch:false, errorMsg:message }} 假设我们的请求是用来获取阅读量amount, 实际项目中建议改为data12345const initState={ isFetch: false, amount: 0, errorMsg: null,} reducers12345678910111213141516171819export function request_reducer(state=initState, action) { console.log(action.type, JSON.stringify(action)) switch (action.type){ case REQUEST_POSTS: return { ...state, isFetch: action.isFetch ? true : false, } case RECEIVE_POSTS: return { ...state, isFetch: false, amount: action.amount ? action.amount : 0, errorMsg: action.errorMsg ? action.errorMsg : null } default: return state; }} 异步action的关键在于action creator返回的不是一个简单对象{type: ...}, 而是一个函数/Promise(归功于thunk) 1234567891011121314151617181920212223242526272829//最核心的异步操作export function fetchAmount() { return axios.get('http://www.baidu.com')}//异步action//异步请求action 【将上面3个基础的action整合】export function getAmountPromise(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) const {num} = getState() return new Promise((resolve, reject)=&gt; { let success = (res)=&gt; { setTimeout(()=&gt; { dispatch(receviePostOnSuccess(num.number)) resolve(res) }, 2000) }, fail = (err)=&gt; { console.log(error); dispatch(receviePostOnError('error')) reject(err) } fetchAmount().then(success, fail) }) }} 完整例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//一个异步请求import axios from 'axios';const REQUEST_POSTS = &quot;REQUEST_POST&quot;;const RECEIVE_POSTS = &quot;RECEIVE_POSTS&quot;;const initState={ isFetch: false, amount: 0, errorMsg: null,}export function request_reducer(state=initState, action) { console.log(action.type, JSON.stringify(action)) switch (action.type){ case REQUEST_POSTS: return { ...state, isFetch: action.isFetch ? true : false, } case RECEIVE_POSTS: return { ...state, isFetch: false, amount: action.amount ? action.amount : 0, errorMsg: action.errorMsg ? action.errorMsg : null } default: return state; }}export function fetchAmount() { return axios.get('http://www.baidu.com')}//通知 reducer 请求开始的 actionexport function requestPosts(){ return { type: REQUEST_POSTS, isFetch:true //进度条相关 }} //通知 reducer 请求成功的 actionexport function receviePostOnSuccess(data){ return { type: RECEIVE_POSTS, isFetch:false, amount: data }} //通知 reducer 请求失败的 action。export function receviePostOnError( message){ return{ type: RECEIVE_POSTS, isFetch:false, errorMsg:message }} //异步请求action 【将上面3个基础的action整合】//写法一export function getAmount(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 // console.log( JSON.stringify(this), JSON.stringify(_this)) console.log(&quot;==================&quot;) dispatch(requestPosts()) const {num} = getState() //异步请求后端接口 return fetchAmount().then( data=&gt; { console.log(num); dispatch(receviePostOnSuccess(num.number)) }, error=&gt; { console.log(error); dispatch(receviePostOnError('error')) } ) }}//异步请求action 【将上面3个基础的action整合】//写法二export function getAmountPromise(){ let _this = this return (dispatch, getState)=&gt;{ // 首次 dispatch：更新应用的 state 来通知API 请求发起了 dispatch(requestPosts()) const {num} = getState() return new Promise((resolve, reject)=&gt; { let success = (res)=&gt; { setTimeout(()=&gt; { dispatch(receviePostOnSuccess(num.number)) resolve(res) }, 2000) }, fail = (err)=&gt; { console.log(error); dispatch(receviePostOnError('error')) reject(err) } fetchAmount().then(success, fail) }) }} 4. 数据持久化#TODO 后记#写异步action的时候一直有疑惑，如果把所有的网络请求都用redux的思路来写的话，这个代码量简直爆炸。请教了之前写RN的朋友，被告知，异步网络请求可以不走action, 简单封装下axios, 统一管理API即可。","link":"/2020/10/30/rn-app-step2/"},{"title":"前端基础之CommonJs、AMD、CMD、UMD","text":"本文主要介绍CommonJs、AMD、CMD、UMD以及由此衍生的require、export、exports、import等。 CommonJs module.exports和exports的区别 AMD 异步模块定义 CMD CMD 与 AMD 的区别 UMD 实现 export 命名式导出 注意 默认导出（定义式导出） import 引入模块 命名式导入 默认导入 ES6中的 Module 概述 自动严格模式 export 注意点 import 注意点 提升 表达式和变量 只加载，不执行 单例模式 与CommonJS/require混用时注意点 整体加载 export default export 符合 import 模块的集成 跨模块常量 参考文档 CommonJs#一种服务器端模块化的规范，Nodejs实现了这种规范，所以就说Nodejs支持CommonJS。 CommonJS分为三部分： require 模块加载 exports 模块导出 module 模块本身 根据规范一个单独的JS文件就是一个module，每个单独的module是一个单独的作用域。也就是说在一个文件里定义的变量和函数都是私有，对其他文件不可见，除非用exports导出了。在CommonJS中,暴露模块使用module.exports和exports，很多人不明白暴露对象为什么会有两个,后面会介绍区别 在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载和调用。 math.js123456const math = { add: function(x, y) { return x + y }}module.exports = math utils.js123exports.toInt = function(string) =&gt; { return parseInt(string) || 0} 123var math = require('math');let {toInt} = require('utils')math.add(2,3); // 5 正是由于CommonJS 使用的require方式的推动，才有了后面的AMD、CMD 也采用的require方式来引用模块的风格. module.exports和exports的区别#module和exports是Node.js给每个js文件内置的两个对象。 在node.js中打印console.log(module)可以看出 module 和 exports 都是node中提供的两个对象，其中module里包裹着exports 123456789Module { id: '.', exports: {}, parent: null, filename: '', loaded: false, children: [], paths:[] } 实际上这两个对象指向同一块内存。这也就是说module.exports和exports是等价的。 12exports.age = 18; module.exports.age = 18; 这两种写法是一致的（都相当于给最初的空对象{}添加了一个属性，通过require得到的就是{age: 18}）。 但是 每个导出模块 node.js 默认会返回 return module.exports; 当直接给module.exports或exports赋值时，就相当于改变了内存，两者指代的就不是同一内存，这样就会导致exports中的内容失效，因为module.exports所指向的内存永远是真正的内存 直接给module.exports赋值导致内存改变，新生成的内存依然是真正的内存，那exports原先指向的内存就无效了 1234567//song.jsmodule.exports = {name: '樱花树下'}；exports = {name: '不吐不快'};//main.jslet song= require('./song');console.log(song);//输出：{name: '樱花树下'} 直接给exports赋值导致内存改变，那么exports所指的内存就是无效内存，所以会返回module.exports空对象 123456//song.jsexports = {name: '不吐不快'};//main.jslet song= require('./song');console.log(song);//输出：{} soexports = module.exports 这个用来重新建立引用关系的就是重新把无效内存指向真正内存 这样 exports 和 module.exports 就重新建立了联系 AMD 异步模块定义#产生背景：第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 AMD是浏览器上的规范. 123456789101112131415161718192021222324252627define(id?, dependencies?, factory)/* 参数解释- id:字符串，模块名称(可选)- dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式- factory: 工厂方法，返回一个模块函数*/// math.js 如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。define(function (){ var add = function (x,y){ return x+y; }; return { add: add };});//如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。define(['Lib'], function(Lib){ function foo(){ Lib.doSomething(); } return { foo : foo };}); AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： 123456789require([module], callback);/* 第一个参数[module]，是一个数组，里面的成员就是要加载的模块； 第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：*/require(['math'], function (math) { math.add(2, 3);} 主要有两个Javascript库实现了AMD规范：require.js和curl.js。 CMD#CMD (Common Module Definition), 是seajs推崇的规范，CMD则是依赖就近，用的时候再require。它写起来是这样的： 1234define(function(require, exports, module) { var clock = require('clock'); //主要是这行代码 clock.start();} CMD与AMD一样，也是采用特定的define()函数来定义,用require方式来引用模块 1234567891011121314define(id?, dependencies?, factory)/* id:字符串，模块名称(可选) dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式 factory: 工厂方法，返回一个模块函数*/define('hello', ['jquery'], function(require, exports, module) { // 模块代码});//如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。define(function(require, exports, module) { // 模块代码} CMD 与 AMD 的区别#AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。 AMD依赖前置，js可以方便知道依赖模块是谁，立即加载； 而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 UMD#Universal Module Definition。从名字就可以看出来UMD做的是大一统的工作，把前后端加载糅合在了一起，提供了一个前后端统一的解决方案。支持AMD和CommonJS模式。 实现# 先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。 前两个都不存在，则将模块公开到全局（window或global）。 example123456789101112131415161718192021// if the module has no dependencies, the above pattern can be simplified to(function (root, factory) { if (typeof define === 'function' &amp;&amp; define.amd) { // AMD. Register as an anonymous module. define([], factory); } else if (typeof exports === 'object') { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); } else { // Browser globals (root is window) root.returnExports = factory(); }}(this, function () { // Just return a value to define the module export. // This example returns an object, but the module // can return a function as the exported value. return {};})); export#export语法声明用于导出函数、对象、指定文件（或模块）的原始值。ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块.(浏览器)但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports/exports导出接口。 export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。 1234567891011121314151617181920export { name1, name2, …, nameN };export { variable1 as name1, variable2 as name2, …, nameN };export let name1, name2, …, nameN; // also varexport let name1 = …, name2 = …, …, nameN; // also var, const export default expression;export default function (…) { … } // also class, function*export default function name1(…) { … } // also class, function*export { name1 as default, … }; export * from …;export { name1, name2, …, nameN } from …;export { import1 as name1, import2 as name2, …, nameN } from …;/*name1… nameN－导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用import引用default－设置模块的默认导出。设置后import不通过“标识符”而直接引用默认导入－继承模块并导出继承模块所有的方法和属性as－重命名导出“标识符”from－从已经存在的模块、脚本文件…导出*/ 命名式导出#12345678910export { myFunction }; // 导出一个已定义的函数export const foo = Math.sqrt(2); // 导出一个常量export * from 'article'; //使用*和from关键字来实现的模块的继承：=&gt;这句话没怎么理解var name = 'IT笔录';var domain = 'http://itbilu.com'; export {name as siteName, domain}; 注意#下面的语法有严重错误的情况： 12345// 错误演示export 1; // 绝对不可以 var a = 100;export a; export在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出1没有任何意义，也不可能在import的时候有一个变量与之对应.上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样export a虽然看上去成立，但是a的值是一个数字，根本无法完成解构，因此必须写成export {a}的形式。即使a被赋值为一个function，也是不允许的。而且，大部分风格都建议，模块中最好在末尾用一个export导出所有的接口，例如： 1export {fun as default,a,b,c}; 正确的写法应该是这样 12345const D = 123; export default D;export { D as default }; 或者按照ES6的规则:export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 12345678910111213141516// 写法一export var m = 1;// 写法二var m = 1;export {m};// 写法三var n = 1;export {n as m};// 同理, 以下写法也是对的export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 默认导出（定义式导出）#默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在import引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块import导入时也会很容易引用。 12export default function() {}; // 可以导出一个函数export default class(){}; // 也可以出一个类 import 引入模块#import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。 import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。 import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。 123456789101112131415161718import defaultMember from &quot;module-name&quot;;import * as name from &quot;module-name&quot;;import { member } from &quot;module-name&quot;;import { member as alias } from &quot;module-name&quot;;import { member1 , member2 } from &quot;module-name&quot;;import { member1 , member2 as alias2 , [...] } from &quot;module-name&quot;;import defaultMember, { member [ , [...] ] } from &quot;module-name&quot;;import defaultMember, * as name from &quot;module-name&quot;;import &quot;module-name&quot;;/* name－从将要导入模块中收到的导出值的名称 member, memberN－从导出模块，导入指定名称的多个成员 defaultMember－从导出模块，导入默认导出成员 alias, aliasN－别名，对指定导入成员进行的重命名 module-name－要导入的模块。是一个文件名 as－重命名导入成员名称（“标识符”） from－从已经存在的模块、脚本文件等导入*/ 命名式导入#花括号里面的变量与export后面的变量一一对应 12import {myMember} from &quot;my-module&quot;;import {foo, bar} from &quot;my-module&quot;; 通过*符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（’my-module.js’）所有的导出绑定内容，插入到当前模块（’myModule’）的作用域中： 1import * as myModule from &quot;my-module&quot;; 导入模块对象时，也可以使用as对导入成员重命名，以方便在当前模块内使用： 1import {reallyReallyLongModuleMemberName as shortName} from &quot;my-module&quot;; 导入多个成员时，同样可以使用别名： 1import {reallyReallyLongModuleMemberName as shortName, anotherLongModuleName as short} from &quot;my-module&quot;; 导入一个模块，但不进行任何绑定： 1import &quot;my-module&quot;; 默认导入#在模块导出时，可能会存在默认导出。同样的，在导入时可以使用import指令导出这些默认值。 直接导入默认值： 1import myDefault from &quot;my-module&quot;; 也可以在命名空间导入和名称导入中，同时使用默认导入： 123import myDefault, * as myModule from &quot;my-module&quot;; // myModule 做为命名空间使用//或import myDefault, {foo, bar} from &quot;my-module&quot;; // 指定成员导入 ES6中的 Module#概述#在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 12345678// CommonJS模块let { stat, exists, readfile } = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12// ES6模块import { stat, exists, readFile } from 'fs'; 上面代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 自动严格模式#ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。 严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀 0 表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 export 注意点#export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面代码输出变量foo，值为bar，500 毫秒之后变成baz。 import 注意点#提升#import命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import { foo } from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 表达式和变量#由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12345678910111213// 报错import { 'f' + 'oo' } from 'my_module';// 报错let module = 'my_module';import { foo } from module;// 报错if (x === 1) { import { foo } from 'module1';} else { import { foo } from 'module2';} 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 只加载，不执行#import语句会执行所加载的模块，因此可以有下面的写法。 1import 'lodash'; 上面代码仅仅执行lodash模块，但是不输入任何值。 单例模式#如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 12import 'lodash';import 'lodash'; 上面代码加载了两次lodash，但是只会执行一次。 12345import { foo } from 'my_module';import { bar } from 'my_module';// 等同于import { foo, bar } from 'my_module'; 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module模块。也就是说，import语句是 Singleton 模式。 与CommonJS/require混用时注意点#目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。 123require('core-js/modules/es6.symbol');require('core-js/modules/es6.promise');import React from 'React'; 整体加载#除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 1234567891011121314// circle.jsexport function area(radius) { return Math.PI * radius * radius;}export function circumference(radius) { return 2 * Math.PI * radius;}//main.jsimport * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); export default#12345678910111213// 第一组export default function crc32() { // 输出 // ...}import crc32 from 'crc32'; // 输入// 第二组export function crc32() { // 输出 // ...};import {crc32} from 'crc32'; // 输入 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 1234567891011121314151617181920212223242526272829// modules.jsfunction add(x, y) { return x * y;}export {add as default};// 等同于// export default add;// app.jsimport { default as foo } from 'modules';// 等同于// import foo from 'modules';// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1;// 正确export default 42;// 报错export 42; 上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。同样地，因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。 如果想在一条import语句中，同时输入默认方法和其他接口，可以写成下面这样。 12345678910111213import _, { each, forEach } from 'lodash';//对应上面代码的export语句如下。export default function (obj) { // ···}export function each(obj, iterator, context) { // ···}export { each as forEach }; export 符合 import#1234567export { foo, bar } from 'my_module';// 可以简单理解为import { foo, bar } from 'my_module';export { foo, bar };export * from 'my_module'; 模块的集成#1234567// circleplus.jsexport * from 'circle'; //注意这里是exportexport var e = 2.71828182846;export default function(x) { return Math.exp(x);} 上面代码中的export *，表示输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 跨模块常量#1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import {A, B} from './constants';console.log(A); // 1console.log(B); // 3 回到es6 Module的初衷,当常量module.js文件非常大时，使用{}指明需要引用的内容，可以大大减少内存使用。 参考文档#123阮一峰教程","link":"/2021/02/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BCommonJs-AMD-CMD-UMD/"},{"title":"前端基础之JS基本","text":"很多时候都会想不起或者忽略这些基础概念。有空的时候还是得老老实实看一遍记一遍。 切勿眼高手低~ 组成 原始值和引用值 Undefined Null Boolean Number String 类型转换 转换成字符串 转换成数值 parseInt parseFloat 强制类型转换 引用类型 Object Boolean 对象 Number 对象 toFixed() 方法 toExponential() 方法 toPrecision() 方法 =&gt; 取N位有效数 String 对象 length charAt() 和 charCodeAt() 方法 es6 concat() 方法 indexOf() 和 lastIndexOf() 方法 localeCompare() 方法 slice() 和 substring() toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase() 提示 instanceof 运算符 等性运算符 等号(==)与非等号(!==) 全等号与非全等号 Function length属性 Function 对象 闭包 简单的闭包 复杂的闭包 对象类型 本地对象 内部对象 宿主对象 继承 对象冒充 对象冒充可以实现多重继承 call() apply() 原型链 混合 组成#JavaScript 由以下 3 个不同部分组成的： 核心（ECMAScript）: 描述js的语法和基本对象 文档对象模型（DOM）: 处理网页内容的方法和接口 浏览器对象模型（BOM）: 与浏览器进行交互的方法和接口 DOMDOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物 BOMIE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的标准。 BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括： 弹出新的浏览器窗口 移动、关闭浏览器窗口以及调整窗口大小 提供 Web 浏览器详细信息的定位对象 提供用户屏幕分辨率详细信息的屏幕对象 对 cookie 的支持 IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象 由于没有相关的 BOM 标准，每种浏览器都有自己的 BOM 实现。有一些事实上的标准，如具有一个窗口对象和一个导航对象，不过每种浏览器可以为这些对象或其他对象定义自己的属性和方法。 原始值和引用值#在 ECMAScript 中，变量可以存在两种类型的值，即原始值和引用值。 原始值存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。引用值存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的原始类型之一，即 Undefined、Null、Boolean、Number 和 String 型。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。 在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript 打破了这一传统。 如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 原始类型ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String。ECMA-262 把术语类型（type）定义为值的一个集合，每种原始类型定义了它包含的值的范围及其字面量表示形式。 ECMAScript 提供了 typeof 运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。 1234var sTemp = &quot;test string&quot;;alert (typeof sTemp); //输出 &quot;string&quot;alert (typeof 86); //输出 &quot;number&quot;console.log(typeof 1 == 'number') //true 对变量或值调用 typeof 运算符将返回下列值之一： undefined - 如果变量是 Undefined 类型的 boolean - 如果变量是 Boolean 类型的 number - 如果变量是 Number 类型的 string - 如果变量是 String 类型的 object - 如果变量是一种引用类型或 Null 类型的 NOTE注释：为什么 typeof 运算符对于 null 值会返回 &quot;Object&quot;。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。 Undefined# 当声明的变量未初始化时，该变量的默认值是 undefined。 当函数无明确返回值时，返回的也是值 “undefined”123456789var oTemp;alert(typeof oTemp); //输出 &quot;undefined&quot;alert(typeof oTemp2); //输出 &quot;undefined&quot;function testFunc() {}alert(testFunc() == undefined); //输出 &quot;true&quot; 前面的代码对两个变量输出的都是 “undefined”，即使只有变量 oTemp2 从未被声明过。如果对 oTemp2 使用除 typeof 之外的其他运算符的话，会引起错误，因为其他运算符只能用于已声明的变量上。 Null#另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。 尽管这两个值相等，但它们的含义不同: undefined 是声明了变量但未对其初始化时赋予该变量的值， null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。1alert(null == undefined); //输出 &quot;true&quot; Boolean#Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。 即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的。 12var bFound = true;var bLost = false; Number#ECMA-262 中定义的最特殊的类型是 Number 类型。这种类型既可以表示32 位的整数，还可以表示64 位的浮点数。 直接输入的（而不是从另一个变量访问的）任何数字都被看做 Number 类型的字面量。 八进制数和十六进制数 整数也可以被表示为八进制（以 8 为底）或十六进制（以 16 为底）的字面量。八进制字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7） 十六进制的字面量，首位数字必须为 0，后面接字母 x，然后是任意的十六进制数字（0 到 9 和 A 到 F）。这些字母可以是大写的，也可以是小写的 浮点数要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量对于浮点字面量的有趣之处在于，用它进行计算前，真正存储的是字符串。 科学计数法对于非常大或非常小的数，可以用科学计数法表示浮点数，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数 特殊的 Number 值 Number.MAX_VALUE 和 Number.MIN_VALUE Number.POSITIVE_INFINITY 和 Number.NEGATIVE_INFINITY Infinity NaN 当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 Number.MIN_VALUE 的计算也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。 事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。Number.POSITIVE_INFINITY 的值为 Infinity。Number.NEGATIVE_INFINITY 的值为 -Infinity。 由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用 isFinite() 方法，以确保该数不是无穷大 NaN 是个奇怪的特殊值。一般说来，这种情况发生在类型（String、Boolean 等）转换失败时。例如，要把单词 blue 转换成数值就会失败，因为没有与之等价的数值。与无穷大一样，NaN 也不能用于算术计算。NaN 的另一个奇特之处在于，它与自身不相等，这意味着下面的代码将返回 false 1234alert(NaN == NaN); //输出 &quot;false&quot;//不推荐使用 NaN 值本身。函数 isNaN() 会做得相当好：alert(isNaN(&quot;blue&quot;)); //输出 &quot;true&quot;alert(isNaN(&quot;666&quot;)); //输出 &quot;false&quot; String#String 类型的独特之处在于，它是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种国际字符集，本教程后面将讨论它）。 字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1： 字符串字面量是由双引号（”）或单引号（’）声明的。而 Java 则是用双引号声明字符串，用单引号声明字符。但是由于 ECMAScript 没有字符类型，所以可使用这两种表示法中的任何一种 类型转换#转换成字符串#Boolean 值、数字和字符串的原始值的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。Number 类型的 toString() 方法比较特殊，它有两种模式，即默认模式和基模式。采用默认模式，toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）在默认模式中，无论最初采用什么表示法声明数字，Number 类型的 toString() 方法返回的都是数字的十进制表示。因此，以八进制或十六进制字面量形式声明的数字输出的都是十进制形式的.采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。 1234567891011121314var sColor = &quot;red&quot;;alert(sColor.length); //输出 &quot;3&quot;var bFound = false;alert(bFound.toString()); //输出 &quot;false&quot;//默认模式var iNum1 = 10;var iNum2 = 10.0;alert(iNum1.toString()); //输出 &quot;10&quot;alert(iNum2.toString()); //输出 &quot;10&quot;//基模式var iNum = 10;alert(iNum.toString(2)); //输出 &quot;1010&quot;alert(iNum.toString(8)); //输出 &quot;12&quot;alert(iNum.toString(16)); //输出 &quot;A&quot; 转换成数值# parseInt parseFloat 前者把值转换成整数，后者把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。 parseInt#1234var iNum1 = parseInt(&quot;12345red&quot;); //返回 12345var iNum1 = parseInt(&quot;0xA&quot;); //返回 10var iNum1 = parseInt(&quot;56.9&quot;); //返回 56var iNum1 = parseInt(&quot;red&quot;); //返回 NaN parseInt() 方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。 12345678var iNum1 = parseInt(&quot;AF&quot;, 16); //返回 175var iNum1 = parseInt(&quot;10&quot;, 2); //返回 2var iNum2 = parseInt(&quot;10&quot;, 8); //返回 8var iNum3 = parseInt(&quot;10&quot;, 10); //返回 10//如果十进制数包含前导 0，那么最好采用基数 10，这样才不会意外地得到八进制的值var iNum1 = parseInt(&quot;010&quot;); //返回 8var iNum2 = parseInt(&quot;010&quot;, 8); //返回 8var iNum3 = parseInt(&quot;010&quot;, 10); //返回 10 parseFloat#parseFloat() 方法与 parseInt() 方法的处理方式相似，从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数。 不过，对于这个方法来说，第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。parseFloat() 会把这个小数点之前的字符转换成数字。这意味着字符串 &quot;11.22.33&quot; 将被解析成 11.22。 使用 parseFloat() 方法的另一不同之处在于，字符串必须以十进制形式表示浮点数，而不是用八进制或十六进制。该方法会忽略前导 0，所以八进制数 0102 将被解析为 102。对于十六进制数 0xA，该方法将返回 NaN，因为在浮点数中，x 不是有效字符。（注释：经测试，具体的浏览器实现会返回 0，而不是 NaN。） 此外，parseFloat() 方法也没有基模式。 12345678var fNum1 = parseFloat(&quot;12345red&quot;); //返回 12345var fNum2 = parseFloat(&quot;0xA&quot;); //返回 NaNvar fNum3 = parseFloat(&quot;11.2&quot;); //返回 11.2var fNum4 = parseFloat(&quot;11.22.33&quot;); //返回 11.22var fNum5 = parseFloat(&quot;0102&quot;); //返回 102var fNum6 = parseFloat(&quot;red&quot;); //返回 NaNvar fNum7 = parseFloat(&quot;abc.123&quot;); //返回 NaNvar fNum7 = parseFloat(&quot;.123abc&quot;); //返回 0.123 强制类型转换#ECMAScript 中可用的 3 种强制类型转换如下： Boolean(value) - 把给定的值转换成 Boolean 型； Number(value) - 把给定的值转换成数字（可以是整数或浮点数）； String(value) - 把给定的值转换成字符串；用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。 Boolean() 函数当要转换的值是至少有一个字符的字符串、非 0 数字或对象时，Boolean() 函数将返回 true。如果该值是空字符串、数字 0、undefined 或 null，它将返回 false。 123456var b1 = Boolean(&quot;&quot;); //false - 空字符串var b2 = Boolean(&quot;hello&quot;); //true - 非空字符串var b1 = Boolean(50); //true - 非零数字var b1 = Boolean(null); //false - nullvar b1 = Boolean(0); //false - 零var b1 = Boolean(new object()); //true - 对象 Number() 函数Number() 函数的强制类型转换与 parseInt() 和 parseFloat() 方法的处理方式相似，只是它转换的是整个值，而不是部分值。 还记得吗，parseInt() 和 parseFloat() 方法只转换第一个无效字符之前的字符串，因此 “1.2.3” 将分别被转换为 “1” 和 “1.2”。 用 Number() 进行强制类型转换，&quot;1.2.3&quot; 将返回 NaN，因为整个字符串值不能转换成数字。如果字符串值能被完整地转换，Number() 将判断是调用 parseInt() 方法还是 parseFloat() 方法。 123456789Number(false) // 0Number(true) // 1Number(undefined) // NaNNumber(null) // 0Number(&quot;1.2&quot;) // 1.2Number(&quot;12&quot;) // 12Number(&quot;1.2.3&quot;) // NaNNumber(new object()) // NaNNumber(50) // 50 String() 函数最后一种强制类型转换方法 String() 是最简单的，因为它可把任何值转换成字符串。 要执行这种强制类型转换，只需要调用作为参数传递进来的值的 toString() 方法，即把 12 转换成 “12”，把 true 转换成 “true”，把 false 转换成 “false”，以此类推。 强制转换成字符串和调用 toString() 方法的唯一不同之处在于，对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误： 123var s1 = String(null); //&quot;null&quot;var oNull = null;var s2 = oNull.toString(); //会引发错误 引用类型#Object#123let obj = new Object() //同let obj = new Object //为了避免混淆，尽量加上括号 Object 对象具有下列属性： constructor对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。 Prototype对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。 Object 对象还具有下列方法： hasOwnProperty(property)判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，o.hasOwnProperty(“name”)） IsPrototypeOf(object)判断该对象是否为另一个对象的原型。 PropertyIsEnumerable()判断给定的属性是否可以用 for…in 语句进行枚举。 ToString()返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。 ValueOf()返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。 注释：上面列出的每种属性和方法都会被其他对象覆盖。 Boolean 对象#Boolean 对象是 Boolean 原始类型的引用类型。 要创建 Boolean 对象，只需要传递 Boolean 值作为参数： 1var oBooleanObject = new Boolean(true); Number 对象#正如你可能想到的，Number 对象是 Number 原始类型的引用类型。要创建 Number 对象，采用下列代码： 1var oNumberObject = new Number(68); 您应该已认出本章前面小节中讨论特殊值（如 Number.MAX_VALUE）时提到的 Number 对象。所有特殊值都是 Number 对象的静态属性。 要得到数字对象的 Number 原始值，只需要使用 valueOf() 方法： 1var iNumber = oNumberObject.valueOf(); toFixed() 方法#toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toFixed(2)); //输出 &quot;68.00&quot; toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误 toExponential() 方法#与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。 与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toExponential(1)); //输出 &quot;6.8e+1&quot; 这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x10¹。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。 toPrecision() 方法 =&gt; 取N位有效数#toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如， 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(1)); //输出 &quot;7e+1&quot; 这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了： 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(2)); //输出 &quot;68&quot; 当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？ 12var oNumberObject = new Number(68);alert(oNumberObject.toPrecision(3)); //输出 &quot;68.0&quot; 在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。 toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数。 提示：与 Boolean 对象相似，Number 对象也很重要，不过应该少用这种对象，以避免潜在的问题。只要可能，都使用数字的原始表示法。 String 对象#String 对象是 String 原始类型的对象表示法，它是以下方式创建的： 1var oStringObject = new String(&quot;hello world&quot;); length#String 对象具有属性 length，它是字符串中的字符个数： 123var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.length); //输出 &quot;11&quot;alert('龍'.length) // 1 这个例子输出的是 “11”，即 “hello world” 中的字符个数。注意，即使字符串包含双字节的字符（与 ASCII 字符相对，ASCII 字符只占用一个字节），每个字符也只算一个字符。 charAt() 和 charCodeAt() 方法#首先，两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。 charAt() 方法返回的是包含指定位置处的字符的字符串： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charAt(1)); //输出 &quot;e&quot; 在字符串 “hello world” 中，位置 1 处的字符是 “e”。在“ECMAScript 原始类型”这一节中我们讲过，第一个字符的位置是 0，第二个字符的位置是 1，依此类推。因此，调用 charAt(1) 返回的是 “e”。 如果想得到的不是字符，而是字符代码，那么可以调用 charCodeAt() 方法： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.charCodeAt(1)); //输出 &quot;101&quot; 这个例子输出 “101”，即小写字母 “e” 的字符代码。 es6#es6中字符串追加了unicode的支持遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 123456789101112let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) { console.log(text[i]);}// &quot; &quot;// &quot; &quot;for (let i of text) { console.log(i);}// &quot;𠮷&quot; concat() 方法#用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，保持原始的 String 对象不变： 1234var oStringObject = new String(&quot;hello &quot;);var sResult = oStringObject.concat(&quot;world&quot;);alert(sResult); //输出 &quot;hello world&quot;alert(oStringObject); //输出 &quot;hello &quot; indexOf() 和 lastIndexOf() 方法#1234var oStringObject = new String(&quot;hello world!&quot;);alert(oStringObject.indexOf(&quot;o&quot;)); 输出 &quot;4&quot;alert(oStringObject.lastIndexOf(&quot;o&quot;)); 输出 &quot;7&quot;alert(oStringObject.lastIndexOf(&quot;orl&quot;)); 输出 &quot;7&quot; localeCompare() 方法#下一个方法是 localeCompare()，对字符串进行排序。该方法有一个参数 - 要进行比较的字符串，返回的是下列三个值之一： 如果 String 对象按照字母顺序排在参数中的字符串之前，返回负数。 如果 String 对象等于参数中的字符串，返回 0 如果 String 对象按照字母顺序排在参数中的字符串之后，返回正数。 注释：如果返回负数，那么最常见的是 -1，不过真正返回的是由实现决定的。如果返回正数，那么同样的，最常见的是 1，不过真正返回的是由实现决定的。localeCompare() 方法的独特之处在于，实现所处的区域（locale，兼指国家/地区和语言）确切说明了这种方法运行的方式。在美国，英语是 ECMAScript 实现的标准语言，localeCompare() 是区分大小写的，大写字母在字母顺序上排在小写字母之后。不过，在其他区域，情况可能并非如此。示例如下： 1234var oStringObject = new String(&quot;yellow&quot;);alert(oStringObject.localeCompare(&quot;brick&quot;)); //输出 &quot;1&quot;alert(oStringObject.localeCompare(&quot;yellow&quot;)); //输出 &quot;0&quot;alert(oStringObject.localeCompare(&quot;zoo&quot;)); //输出 &quot;-1&quot; slice() 和 substring()#ECMAScript 提供了两种方法从子串创建字符串值，即 slice() 和 substring()。这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。如果省略第二个参数，终止位就默认为字符串的长度。 与 concat() 方法一样，slice() 和 substring() 方法都不改变 String 对象自身的值。它们只返回原始的 String 值，保持 String 对象不变。 12345var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.slice(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.substring(&quot;3&quot;)); //输出 &quot;lo world&quot;alert(oStringObject.slice(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot;alert(oStringObject.substring(&quot;3&quot;, &quot;7&quot;)); //输出 &quot;lo w&quot; 在这个例子中，slice() 和 substring() 的用法相同，返回值也一样。当只有参数 3 时，两个方法返回的都是 “lo world”，因为 “hello” 中的第二个 “l” 位于位置 3 上。当有两个参数 “3” 和 “7” 时，两个方法返回的值都是 “lo w”（”world” 中的字母 “o” 位于位置 7 上，所以它不包括在结果中）。 为什么有两个功能完全相同的方法呢？事实上，这两个方法并不完全相同，不过只在参数为负数时，它们处理参数的方式才稍有不同。 对于负数参数，slice() 方法会用字符串的长度加上参数，substring() 方法则将其作为 0 处理（也就是说将忽略它）。例如： 12345var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject.slice(&quot;-3&quot;)); //输出 &quot;rld&quot;alert(oStringObject.substring(&quot;-3&quot;)); //输出 &quot;hello world&quot;alert(oStringObject.slice(&quot;3, -4&quot;)); //输出 &quot;lo w&quot;alert(oStringObject.substring(&quot;3, -4&quot;)); //输出 &quot;hel&quot; 这样即可看出 slice() 和 substring() 方法的主要不同。 当只有参数 -3 时，slice() 返回 “rld”，substring() 则返回 “hello world”。这是因为对于字符串 “hello world”，slice(“-3”) 将被转换成 slice(“8”)，而 substring(“-3”) 将被转换成 substring(“0”)。 同样，使用参数 3 和 -4 时，差别也很明显。slice() 将被转换成 slice(3, 7)，与前面的例子相同，返回 “lo w”。而 substring() 方法则将两个参数解释为 substring(3, 0)，实际上即 substring(0, 3)，因为 substring() 总把较小的数字作为起始位，较大的数字作为终止位。因此，substring(“3, -4”) 返回的是 “hel”。这里的最后一行代码用来说明如何使用这些方法。 toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()#最后一套要讨论的方法涉及大小写转换。有 4 种方法用于执行大小写转换，即 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() 一般来说，如果不知道在以哪种编码运行一种语言，则使用区域特定的方法比较安全。 提示#记住，String 对象的所有属性和方法都可应用于 String 原始值上，因为它们是伪对象。 instanceof 运算符#在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。 instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如： 12var oStringObject = new String(&quot;hello world&quot;);alert(oStringObject instanceof String); //输出 &quot;true&quot; 这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是 “true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。 等性运算符#等号(==)与非等号(!==)#执行类型转换的规则如下： 如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。 在比较时，该运算符还遵守下列规则： 值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 1234567891011null == undefined //true&quot;NaN&quot; == NaN //false5 == NaN //falseNaN == NaN //falseNaN != NaN //truefalse == 0 //truetrue == 1 //truetrue == 2 //falseundefined == 0 //falsenull == 0 //false&quot;5&quot; == 5 //true 全等号与非全等号#这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 12345var sNum = &quot;66&quot;;var iNum = 66;alert(sNum == iNum); //输出 &quot;true&quot;alert(sNum === iNum); //输出 &quot;false&quot;alert(sNum !== iNum); //输出 &quot;true&quot; Function#length属性#ECMAScript 定义的属性 length 声明了函数期望的参数个数。例如： 12345678910function doAdd(iNum) { alert(iNum + 10);}function sayHi() { alert(&quot;Hi&quot;);}alert(doAdd.length); //输出 &quot;1&quot;alert(sayHi.length); //输出 &quot;0&quot; Function 对象#有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。例如： 12345function doAdd(iNum) { alert(iNum + 10);}document.write(doAdd.toString()); 闭包#闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。 简单的闭包#1234567var sMessage = &quot;hello world&quot;;function sayHelloWorld() { alert(sMessage);}sayHelloWorld(); 在上面这段代码中，脚本被载入内存后，并没有为函数 sayHelloWorld() 计算变量 sMessage 的值。该函数捕获 sMessage 的值只是为了以后的使用，也就是说，解释程序知道在调用该函数时要检查 sMessage 的值。sMessage 将在函数调用 sayHelloWorld() 时（最后一行）被赋值，显示消息 “hello world”。 复杂的闭包#12345678var iBaseNum = 10;function addNum(iNum1, iNum2) { function doAdd() { return iNum1 + iNum2 + iBaseNum; } return doAdd();} 这里，函数 addNum() 包括函数 doAdd() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 iNum1 和 iNum2 以及全局变量 iBaseNum 的值。 addNum() 的最后一步调用了 doAdd()，把两个参数和全局变量相加，并返回它们的和。 这里要掌握的重要概念是，doAdd() 函数根本不接受参数，它使用的值是从执行环境中获取的。 对象类型#本地对象# Object Function Array String Boolean Number Date RegExp Error EvalError RangeError ReferenceError SyntaxError TypeError URIError 内部对象#即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。 宿主对象#所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。 所有 BOM 和 DOM 对象都是宿主对象。 继承#要用 ECMAScript 实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可作为基类。出于安全原因，本地类和宿主类不能作为基类，这样可以防止公用访问编译过的浏览器级的代码，因为这些代码可以被用于恶意攻击。 对象冒充#构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 ClassA 构造函数成为 ClassB 的方法，然后调用它。ClassB 就会收到 ClassA 的构造函数中定义的属性和方法。例如，用下面的方式定义 ClassA 和 ClassB： 123456789101112function ClassA(sColor) { this.color = sColor; this.sayColor = function () { alert(this.color); };}function ClassB(sColor) { this.newMethod = ClassA; this.newMethod(sColor); delete this.newMethod;} 在这段代码中，为 ClassA 赋予了方法 newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是 ClassB 构造函数的参数 sColor。最后一行代码删除了对 ClassA 的引用，这样以后就不能再调用它。 所有新属性和新方法都必须在删除了新方法的代码行后定义。否则，可能会覆盖超类的相关属性和方法： 12345678910111213141516function ClassB(sColor, sName) { this.newMethod = ClassA; this.newMethod(sColor); delete this.newMethod; this.name = sName; this.sayName = function () { alert(this.name); };}var objA = new ClassA(&quot;blue&quot;);var objB = new ClassB(&quot;red&quot;, &quot;John&quot;);objA.sayColor(); //输出 &quot;blue&quot;objB.sayColor(); //输出 &quot;red&quot;objB.sayName(); //输出 &quot;John&quot; 对象冒充可以实现多重继承#123456789function ClassZ() { this.newMethod = ClassX; this.newMethod(); delete this.newMethod; this.newMethod = ClassY; this.newMethod(); delete this.newMethod;} 这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法，ClassY 具有高优先级。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。 由于这种继承方法的流行，ECMAScript 的第三版为 Function 对象加入了两个方法，即 call() 和 apply()。 call()#call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如： 12345678function sayColor(sPrefix,sSuffix) { alert(sPrefix + this.color + sSuffix);};var obj = new Object();obj.color = &quot;blue&quot;;sayColor.call(obj, &quot;The color is &quot;, &quot;a very nice color indeed.&quot;); 在这个例子中，函数 sayColor() 在对象外定义，即使它不属于任何对象，也可以引用关键字 this。对象 obj 的 color 属性等于 blue。调用 call() 方法时，第一个参数是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个和第三个参数是字符串。它们与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息 “The color is blue, a very nice color indeed.” 将被显示出来。 要与继承机制的对象冒充方法一起使用该方法，只需将前三行的赋值、调用和删除代码替换即可： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.call(this, sColor); this.name = sName; this.sayName = function () { alert(this.name); };} 这里，我们需要让 ClassA 中的关键字 this 等于新创建的 ClassB 对象，因此 this 是第一个参数。第二个参数 sColor 对两个类来说都是唯一的参数。 apply()#apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如： 12345678function sayColor(sPrefix,sSuffix) { alert(sPrefix + this.color + sSuffix);};var obj = new Object();obj.color = &quot;blue&quot;;sayColor.apply(obj, new Array(&quot;The color is &quot;, &quot;a very nice color indeed.&quot;)); 这个例子与前面的例子相同，只是现在调用的是 apply() 方法。调用 apply() 方法时，第一个参数仍是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个参数是由两个字符串构成的数组，与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息仍是 “The color is blue, a very nice color indeed.”，将被显示出来。 该方法也用于替换前三行的赋值、调用和删除新方法的代码： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.apply(this, new Array(sColor)); this.name = sName; this.sayName = function () { alert(this.name); };} 同样的，第一个参数仍是 this，第二个参数是只有一个值 color 的数组。可以把 ClassB 的整个 arguments 对象作为第二个参数传递给 apply() 方法： 1234567891011function ClassB(sColor, sName) { //this.newMethod = ClassA; //this.newMethod(color); //delete this.newMethod; ClassA.apply(this, arguments); this.name = sName; this.sayName = function () { alert(this.name); };} 当然，只有超类中的参数顺序与子类中的参数顺序完全一致时才可以传递参数对象。如果不是，就必须创建一个单独的数组，按照正确的顺序放置参数。此外，还可使用 call() 方法。 原型链#prototype 对象是个模板，要实例化的对象都以这个模板为基础。总而言之，prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。 123456789101112131415function ClassA() {}ClassA.prototype.color = &quot;blue&quot;;ClassA.prototype.sayColor = function () { alert(this.color);};function ClassB() {}ClassB.prototype = new ClassA(); //mark /*这里，把 ClassB 的 prototype 属性设置成 ClassA 的实例。这很有意思，因为想要 ClassA 的所有属性和方法，但又不想逐个将它们 ClassB 的 prototype 属性。还有比把 ClassA 的实例赋予 prototype 属性更好的方法吗？*/ 注意： 调用 ClassA 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。 子类的所有属性和方法都必须出现在 prototype 属性被赋值后，因为在它之前赋值的所有方法都会被删除。为什么？因为 prototype 属性被替换成了新对象，添加了新方法的原始对象将被销毁。所以，为 ClassB 类添加 name 属性和 sayName() 方法的代码如下：123456789function ClassB() {}ClassB.prototype = new ClassA();ClassB.prototype.name = &quot;&quot;;ClassB.prototype.sayName = function () { alert(this.name);}; 混合#对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。开发者如何选择呢？答案很简单，两者都用。创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制，用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法.12345678910111213141516171819202122232425function ClassA(sColor) { this.color = sColor;}ClassA.prototype.sayColor = function () { alert(this.color);};function ClassB(sColor, sName) { ClassA.call(this, sColor); //对象冒用 this.name = sName; //构造函数定义属性}ClassB.prototype = new ClassA(); //原型链继承//继承后定义新的方法ClassB.prototype.sayName = function () { alert(this.name);};var objA = new ClassA(&quot;blue&quot;);var objB = new ClassB(&quot;red&quot;, &quot;John&quot;);objA.sayColor(); //输出 &quot;blue&quot;objB.sayColor(); //输出 &quot;red&quot;objB.sayName(); //输出 &quot;John&quot;","link":"/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"RN","slug":"RN","link":"/tags/RN/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"sentry","slug":"sentry","link":"/tags/sentry/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"fabric.js","slug":"fabric-js","link":"/tags/fabric-js/"}],"categories":[{"name":"建站","slug":"建站","link":"/categories/%E5%BB%BA%E7%AB%99/"},{"name":"运维","slug":"运维","link":"/categories/%E8%BF%90%E7%BB%B4/"},{"name":"APP","slug":"APP","link":"/categories/APP/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"前端基础","slug":"前端基础","link":"/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"},{"name":"前端进阶","slug":"前端进阶","link":"/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机基础","slug":"前端基础/计算机基础","link":"/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"canvas","slug":"canvas","link":"/categories/canvas/"}]}