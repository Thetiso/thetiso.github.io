<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>前端基础之JS基本 - Thetiso&#039;s Tech Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Thetiso&#039;s Tech Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Thetiso&#039;s Tech Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="很多时候都会想不起或者忽略这些基础概念。有空的时候还是得老老实实看一遍记一遍。 切勿眼高手低~"><meta property="og:type" content="blog"><meta property="og:title" content="前端基础之JS基本"><meta property="og:url" content="http://thetiso.github.io/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/"><meta property="og:site_name" content="Thetiso&#039;s Tech Blog"><meta property="og:description" content="很多时候都会想不起或者忽略这些基础概念。有空的时候还是得老老实实看一遍记一遍。 切勿眼高手低~"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://thetiso.github.io/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/1.gif"><meta property="og:image" content="http://thetiso.github.io/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/string.gif"><meta property="article:published_time" content="2021-02-13T12:08:00.000Z"><meta property="article:modified_time" content="2021-02-18T01:03:25.914Z"><meta property="article:author" content="Thetiso"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/1.gif"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://thetiso.github.io/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/"},"headline":"Thetiso's Tech Blog","image":["http://thetiso.github.io/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/1.gif","http://thetiso.github.io/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/string.gif"],"datePublished":"2021-02-13T12:08:00.000Z","dateModified":"2021-02-18T01:03:25.914Z","author":{"@type":"Person","name":"Thetiso"},"description":"很多时候都会想不起或者忽略这些基础概念。有空的时候还是得老老实实看一遍记一遍。 切勿眼高手低~"}</script><link rel="canonical" href="http://thetiso.github.io/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Thetiso&#039;s Tech Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About Me</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-13T12:08:00.000Z" title="2021/2/13 下午8:08:00">2021-02-13</time>发表</span><span class="level-item"><time dateTime="2021-02-18T01:03:25.914Z" title="2021/2/18 上午9:03:25">2021-02-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a></span><span class="level-item">1 小时读完 (大约9659个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">前端基础之JS基本</h1><div class="content"><p>很多时候都会想不起或者忽略这些基础概念。有空的时候还是得老老实实看一遍记一遍。 切勿眼高手低~</p>
<a id="more"></a>

<div class="toc">

<!-- toc -->

<ul>
<li><a href="#zu-cheng">组成</a></li>
<li><a href="#yuan-shi-zhi-he-yin-yong-zhi">原始值和引用值</a><ul>
<li><a href="#undefined">Undefined</a></li>
<li><a href="#null">Null</a></li>
<li><a href="#boolean">Boolean</a></li>
<li><a href="#number">Number</a></li>
<li><a href="#string">String</a></li>
</ul>
</li>
<li><a href="#lei-xing-zhuan-huan">类型转换</a><ul>
<li><a href="#zhuan-huan-cheng-zi-fu-chuan">转换成字符串</a></li>
<li><a href="#zhuan-huan-cheng-shu-zhi">转换成数值</a><ul>
<li><a href="#parseint">parseInt</a></li>
<li><a href="#parsefloat">parseFloat</a></li>
</ul>
</li>
<li><a href="#qiang-zhi-lei-xing-zhuan-huan">强制类型转换</a></li>
</ul>
</li>
<li><a href="#yin-yong-lei-xing">引用类型</a><ul>
<li><a href="#object">Object</a></li>
<li><a href="#boolean-dui-xiang">Boolean 对象</a></li>
<li><a href="#number-dui-xiang">Number 对象</a><ul>
<li><a href="#tofixed-fang-fa">toFixed() 方法</a></li>
<li><a href="#toexponential-fang-fa">toExponential() 方法</a></li>
<li><a href="#toprecision-fang-fa-qu-n-wei-you-xiao-shu">toPrecision() 方法 =&gt; 取N位有效数</a></li>
</ul>
</li>
<li><a href="#string-dui-xiang">String 对象</a><ul>
<li><a href="#length">length</a></li>
<li><a href="#charat-he-charcodeat-fang-fa">charAt() 和 charCodeAt() 方法</a><ul>
<li><a href="#es6">es6</a></li>
</ul>
</li>
<li><a href="#concat-fang-fa">concat() 方法</a></li>
<li><a href="#indexof-he-lastindexof-fang-fa">indexOf() 和 lastIndexOf() 方法</a></li>
<li><a href="#localecompare-fang-fa">localeCompare() 方法</a></li>
<li><a href="#slice-he-substring">slice() 和 substring()</a></li>
<li><a href="#tolowercase-tolocalelowercase-touppercase-he-tolocaleuppercase">toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()</a></li>
<li><a href="#ti-shi">提示</a></li>
</ul>
</li>
<li><a href="#instanceof-yun-suan-fu">instanceof 运算符</a></li>
</ul>
</li>
<li><a href="#deng-xing-yun-suan-fu">等性运算符</a><ul>
<li><a href="#deng-hao-yu-fei-deng-hao">等号(==)与非等号(!==)</a></li>
<li><a href="#quan-deng-hao-yu-fei-quan-deng-hao">全等号与非全等号</a></li>
</ul>
</li>
<li><a href="#function">Function</a><ul>
<li><a href="#length-shu-xing">length属性</a></li>
<li><a href="#function-dui-xiang">Function 对象</a></li>
</ul>
</li>
<li><a href="#bi-bao">闭包</a><ul>
<li><a href="#jian-dan-de-bi-bao">简单的闭包</a></li>
<li><a href="#fu-za-de-bi-bao">复杂的闭包</a></li>
</ul>
</li>
<li><a href="#dui-xiang-lei-xing">对象类型</a><ul>
<li><a href="#ben-di-dui-xiang">本地对象</a></li>
<li><a href="#nei-bu-dui-xiang">内部对象</a></li>
<li><a href="#su-zhu-dui-xiang">宿主对象</a></li>
</ul>
</li>
<li><a href="#ji-cheng">继承</a><ul>
<li><a href="#dui-xiang-mou-chong">对象冒充</a></li>
<li><a href="#dui-xiang-mou-chong-ke-yi-shi-xian-duo-chong-ji-cheng">对象冒充可以实现多重继承</a></li>
<li><a href="#call">call()</a></li>
<li><a href="#apply">apply()</a></li>
<li><a href="#yuan-xing-lian">原型链</a></li>
<li><a href="#hun-he">混合</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="zu-cheng">组成</span><a href="#zu-cheng" class="header-anchor">#</a></h1><p>JavaScript 由以下 3 个不同部分组成的：</p>
<ul>
<li>核心（ECMAScript）:  描述js的语法和基本对象</li>
<li>文档对象模型（DOM）:  处理网页内容的方法和接口</li>
<li>浏览器对象模型（BOM）:  与浏览器进行交互的方法和接口</li>
</ul>
<p><strong>DOM</strong><br>DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物</p>
<p><strong>BOM</strong><br>IE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的标准。</p>
<p>BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括：</p>
<ul>
<li>弹出新的浏览器窗口</li>
<li>移动、关闭浏览器窗口以及调整窗口大小</li>
<li>提供 Web 浏览器详细信息的定位对象</li>
<li>提供用户屏幕分辨率详细信息的屏幕对象</li>
<li>对 cookie 的支持</li>
<li>IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象</li>
</ul>
<p>由于没有相关的 BOM 标准，每种浏览器都有自己的 BOM 实现。有一些事实上的标准，如具有一个窗口对象和一个导航对象，不过每种浏览器可以为这些对象或其他对象定义自己的属性和方法。</p>
<h1><span id="yuan-shi-zhi-he-yin-yong-zhi">原始值和引用值</span><a href="#yuan-shi-zhi-he-yin-yong-zhi" class="header-anchor">#</a></h1><p>在 ECMAScript 中，变量可以存在两种类型的值，即原始值和引用值。</p>
<p><strong>原始值</strong><br>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。<br><strong>引用值</strong><br>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。<br>为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。<strong>要实现这一点，解释程序则需尝试判断该值是否为 ECMAScript 的原始类型之一，即 Undefined、Null、Boolean、Number 和 String 型</strong>。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。</p>
<p>在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript 打破了这一传统。</p>
<p>如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</p>
<img src="/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/1.gif" class alt="js的堆、栈">

<p><strong>原始类型</strong><br>ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String。<br>ECMA-262 把术语类型（type）定义为值的一个集合，每种原始类型定义了它包含的值的范围及其字面量表示形式。</p>
<p>ECMAScript 提供了 <strong>typeof</strong> 运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sTemp = <span class="string">&quot;test string&quot;</span>;</span><br><span class="line">alert (<span class="keyword">typeof</span> sTemp);    <span class="comment">//输出 &quot;string&quot;</span></span><br><span class="line">alert (<span class="keyword">typeof</span> <span class="number">86</span>);    <span class="comment">//输出 &quot;number&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span> == <span class="string">&#x27;number&#x27;</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>对变量或值调用 typeof 运算符将返回下列值之一：</p>
<ul>
<li>undefined - 如果变量是 Undefined 类型的</li>
<li>boolean - 如果变量是 Boolean 类型的</li>
<li>number - 如果变量是 Number 类型的</li>
<li>string - 如果变量是 String 类型的</li>
<li>object - 如果变量是一种引用类型或 Null 类型的</li>
</ul>
<p><strong><em>NOTE</em></strong><br>注释：为什么 typeof 运算符对于<code> null 值会返回 &quot;Object&quot;</code>。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。</p>
<h2><span id="undefined">Undefined</span><a href="#undefined" class="header-anchor">#</a></h2><ol>
<li>当声明的变量未初始化时，该变量的默认值是 undefined。</li>
<li>当函数无明确返回值时，返回的也是值 “undefined”<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oTemp;</span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">typeof</span> oTemp);  <span class="comment">//输出 &quot;undefined&quot;</span></span><br><span class="line">alert(<span class="keyword">typeof</span> oTemp2);  <span class="comment">//输出 &quot;undefined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(testFunc() == <span class="literal">undefined</span>);  <span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
前面的代码对两个变量输出的都是 “undefined”，即使只有变量 oTemp2 从未被声明过。<br>如果对 oTemp2 使用除 typeof 之外的其他运算符的话，会引起错误，<code>因为其他运算符只能用于已声明的变量上</code>。</li>
</ol>
<h2><span id="null">Null</span><a href="#null" class="header-anchor">#</a></h2><p>另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。<code>值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的</code>。</p>
<p>尽管这两个值相等，但它们的含义不同: </p>
<ul>
<li>undefined 是声明了变量但未对其初始化时赋予该变量的值，</li>
<li>null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<h2><span id="boolean">Boolean</span><a href="#boolean" class="header-anchor">#</a></h2>Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。</li>
</ul>
<p>即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bFound = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bLost = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="number">Number</span><a href="#number" class="header-anchor">#</a></h2><p>ECMA-262 中定义的最特殊的类型是 Number 类型。这种类型既可以表示<code>32 位</code>的整数，还可以表示<code>64 位</code>的浮点数。</p>
<p>直接输入的（而不是从另一个变量访问的）任何数字都被看做 Number 类型的字面量。</p>
<p><strong>八进制数和十六进制数</strong></p>
<ul>
<li>整数也可以被表示为八进制（以 8 为底）或十六进制（以 16 为底）的字面量。八进制字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7）</li>
<li>十六进制的字面量，首位数字必须为 0，后面接字母 x，然后是任意的十六进制数字（0 到 9 和 A 到 F）。这些字母可以是大写的，也可以是小写的</li>
</ul>
<p><strong>浮点数</strong><br>要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量<br><code>对于浮点字面量的有趣之处在于，用它进行计算前，真正存储的是字符串</code>。</p>
<p><strong>科学计数法</strong><br>对于非常大或非常小的数，可以用科学计数法表示浮点数，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数</p>
<p><strong>特殊的 Number 值</strong></p>
<ul>
<li><strong><em>Number.MAX_VALUE 和 Number.MIN_VALUE</em></strong></li>
<li><strong><em>Number.POSITIVE_INFINITY 和 Number.NEGATIVE_INFINITY</em></strong></li>
<li><strong><em>Infinity</em></strong></li>
<li><strong><em>NaN</em></strong></li>
</ul>
<p>当计算生成的数大于 Number.MAX_VALUE 时，它将被赋予值 Number.POSITIVE_INFINITY，意味着不再有数字值。同样，生成的数值小于 Number.MIN_VALUE 的计算也会被赋予值 Number.NEGATIVE_INFINITY，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。</p>
<p>事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。Number.POSITIVE_INFINITY 的值为 Infinity。Number.NEGATIVE_INFINITY 的值为 -Infinity。</p>
<p>由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用 isFinite() 方法，以确保该数不是无穷大</p>
<p><code>NaN</code> 是个奇怪的特殊值。一般说来，这种情况发生在类型（String、Boolean 等）转换失败时。例如，要把单词 blue 转换成数值就会失败，因为没有与之等价的数值。与无穷大一样，NaN 也不能用于算术计算。NaN 的另一个奇特之处在于，<code>它与自身不相等</code>，这意味着下面的代码将返回 false</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">NaN</span> == <span class="literal">NaN</span>);  <span class="comment">//输出 &quot;false&quot;</span></span><br><span class="line"><span class="comment">//不推荐使用 NaN 值本身。函数 isNaN() 会做得相当好：</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));  <span class="comment">//输出 &quot;true&quot;</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;666&quot;</span>));  <span class="comment">//输出 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<h2><span id="string">String</span><a href="#string" class="header-anchor">#</a></h2><p>String 类型的独特之处在于，它是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种国际字符集，本教程后面将讨论它）。</p>
<p>字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1：</p>
<img src="/2021/02/13/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJS%E5%9F%BA%E6%9C%AC/string.gif" class alt="字符串的长度和字符的位置">


<p>字符串字面量是由双引号（”）或单引号（’）声明的。而 Java 则是用双引号声明字符串，用单引号声明字符。但是由于 ECMAScript 没有字符类型，所以可使用这两种表示法中的任何一种</p>
<h1><span id="lei-xing-zhuan-huan">类型转换</span><a href="#lei-xing-zhuan-huan" class="header-anchor">#</a></h1><h2><span id="zhuan-huan-cheng-zi-fu-chuan">转换成字符串</span><a href="#zhuan-huan-cheng-zi-fu-chuan" class="header-anchor">#</a></h2><p>Boolean 值、数字和字符串的原始值的有趣之处在于它们是伪对象，这意味着它们实际上具有属性和方法。<br>Number 类型的 toString() 方法比较特殊，它有两种模式，即默认模式和基模式。采用默认模式，toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法）<br>在<code>默认模式</code>中，无论最初采用什么表示法声明数字，Number 类型的 toString() 方法返回的都是数字的十进制表示。因此，以八进制或十六进制字面量形式声明的数字输出的都是十进制形式的.<br>采用 Number 类型的 toString() 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">alert(sColor.length);	<span class="comment">//输出 &quot;3&quot;</span></span><br><span class="line"><span class="keyword">var</span> bFound = <span class="literal">false</span>;</span><br><span class="line">alert(bFound.toString());	<span class="comment">//输出 &quot;false&quot;</span></span><br><span class="line"><span class="comment">//默认模式</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="number">10.0</span>;</span><br><span class="line">alert(iNum1.toString());	<span class="comment">//输出 &quot;10&quot;</span></span><br><span class="line">alert(iNum2.toString());	<span class="comment">//输出 &quot;10&quot;</span></span><br><span class="line"><span class="comment">//基模式</span></span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">alert(iNum.toString(<span class="number">2</span>));	<span class="comment">//输出 &quot;1010&quot;</span></span><br><span class="line">alert(iNum.toString(<span class="number">8</span>));	<span class="comment">//输出 &quot;12&quot;</span></span><br><span class="line">alert(iNum.toString(<span class="number">16</span>));	<span class="comment">//输出 &quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<h2><span id="zhuan-huan-cheng-shu-zhi">转换成数值</span><a href="#zhuan-huan-cheng-shu-zhi" class="header-anchor">#</a></h2><ul>
<li>parseInt</li>
<li>parseFloat</li>
</ul>
<p>前者把值转换成整数，后者把值转换成浮点数。<code>只有对 String 类型调用这些方法</code>，它们才能正确运行；对其他类型返回的都是 NaN。</p>
<h3><span id="parseint">parseInt</span><a href="#parseint" class="header-anchor">#</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;12345red&quot;</span>);	<span class="comment">//返回 12345</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>);	<span class="comment">//返回 10</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;56.9&quot;</span>);	<span class="comment">//返回 56</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;red&quot;</span>);	<span class="comment">//返回 NaN</span></span><br></pre></td></tr></table></figure>
<p>parseInt() 方法还有<code>基模式</code>，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>);	<span class="comment">//返回 175</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>);	<span class="comment">//返回 2</span></span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>);	<span class="comment">//返回 8</span></span><br><span class="line"><span class="keyword">var</span> iNum3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>);	<span class="comment">//返回 10</span></span><br><span class="line"><span class="comment">//如果十进制数包含前导 0，那么最好采用基数 10，这样才不会意外地得到八进制的值</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>);	<span class="comment">//返回 8</span></span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>, <span class="number">8</span>);	<span class="comment">//返回 8</span></span><br><span class="line"><span class="keyword">var</span> iNum3 = <span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>, <span class="number">10</span>);	<span class="comment">//返回 10</span></span><br></pre></td></tr></table></figure>
<h3><span id="parsefloat">parseFloat</span><a href="#parsefloat" class="header-anchor">#</a></h3><p>parseFloat() 方法与 parseInt() 方法的处理方式相似，<code>从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数</code>。</p>
<p>不过，对于这个方法来说，第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。<code>parseFloat() 会把这个小数点之前的字符转换成数字。这意味着字符串 &quot;11.22.33&quot; 将被解析成 11.22</code>。</p>
<p>使用 parseFloat() 方法的另一不同之处在于，字符串<code>必须以十进制形式表示浮点数</code>，而不是用八进制或十六进制。该方法会忽略前导 0，所以八进制数 0102 将被解析为 102。对于十六进制数 0xA，该方法将返回 NaN，因为在浮点数中，x 不是有效字符。（注释：经测试，具体的浏览器实现会返回 0，而不是 NaN。）</p>
<p>此外，parseFloat() 方法也<code>没有基模式</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fNum1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;12345red&quot;</span>);	<span class="comment">//返回 12345</span></span><br><span class="line"><span class="keyword">var</span> fNum2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>);	<span class="comment">//返回 NaN</span></span><br><span class="line"><span class="keyword">var</span> fNum3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;11.2&quot;</span>);	<span class="comment">//返回 11.2</span></span><br><span class="line"><span class="keyword">var</span> fNum4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;11.22.33&quot;</span>);	<span class="comment">//返回 11.22</span></span><br><span class="line"><span class="keyword">var</span> fNum5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0102&quot;</span>);	<span class="comment">//返回 102</span></span><br><span class="line"><span class="keyword">var</span> fNum6 = <span class="built_in">parseFloat</span>(<span class="string">&quot;red&quot;</span>);	<span class="comment">//返回 NaN</span></span><br><span class="line"><span class="keyword">var</span> fNum7 = <span class="built_in">parseFloat</span>(<span class="string">&quot;abc.123&quot;</span>);	<span class="comment">//返回 NaN</span></span><br><span class="line"><span class="keyword">var</span> fNum7 = <span class="built_in">parseFloat</span>(<span class="string">&quot;.123abc&quot;</span>);	<span class="comment">//返回 0.123</span></span><br></pre></td></tr></table></figure>
<h2><span id="qiang-zhi-lei-xing-zhuan-huan">强制类型转换</span><a href="#qiang-zhi-lei-xing-zhuan-huan" class="header-anchor">#</a></h2><p>ECMAScript 中可用的 3 种强制类型转换如下：</p>
<ul>
<li>Boolean(value) - 把给定的值转换成 Boolean 型；</li>
<li>Number(value) - 把给定的值转换成数字（可以是整数或浮点数）；</li>
<li>String(value) - 把给定的值转换成字符串；<br>用这三个函数之一转换值，将创建一个新值，<code>存放由原始值直接转换成的值</code>。这会造成意想不到的后果。</li>
</ul>
<p><strong>Boolean() 函数</strong><br>当要转换的值是至少有一个字符的字符串、非 0 数字或对象时，Boolean() 函数将返回 true。如果该值是空字符串、数字 0、undefined 或 null，它将返回 false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>);		<span class="comment">//false - 空字符串</span></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">&quot;hello&quot;</span>);		<span class="comment">//true - 非空字符串</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="number">50</span>);		<span class="comment">//true - 非零数字</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="literal">null</span>);		<span class="comment">//false - null</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="number">0</span>);		<span class="comment">//false - 零</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="keyword">new</span> object());	<span class="comment">//true - 对象</span></span><br></pre></td></tr></table></figure>
<p><strong>Number() 函数</strong><br>Number() 函数的强制类型转换与 parseInt() 和 parseFloat() 方法的处理方式相似，只是它转换的是整个值，而不是部分值。</p>
<p>还记得吗，parseInt() 和 parseFloat() 方法只转换第一个无效字符之前的字符串，因此 “1.2.3” 将分别被转换为 “1” 和 “1.2”。</p>
<p>用 Number() 进行强制类型转换，<code>&quot;1.2.3&quot; 将返回 NaN</code>，因为整个字符串值不能转换成数字。如果字符串值能被完整地转换，Number() 将判断是调用 parseInt() 方法还是 parseFloat() 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">//	0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">//	1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>)	<span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>)	<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;1.2&quot;</span>)	<span class="comment">// 1.2</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;12&quot;</span>)	<span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;1.2.3&quot;</span>)	<span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> object())	<span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">50</span>)	<span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<p><strong>String() 函数</strong><br>最后一种强制类型转换方法 String() 是最简单的，因为它可把任何值转换成字符串。</p>
<p>要执行这种强制类型转换，只需要调用作为参数传递进来的值的 toString() 方法，即把 12 转换成 “12”，把 true 转换成 “true”，把 false 转换成 “false”，以此类推。</p>
<p>强制转换成字符串和调用 toString() 方法的唯一不同之处在于，对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">String</span>(<span class="literal">null</span>);	<span class="comment">//&quot;null&quot;</span></span><br><span class="line"><span class="keyword">var</span> oNull = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = oNull.toString();	<span class="comment">//会引发错误</span></span><br></pre></td></tr></table></figure>
<h1><span id="yin-yong-lei-xing">引用类型</span><a href="#yin-yong-lei-xing" class="header-anchor">#</a></h1><h2><span id="object">Object</span><a href="#object" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>() </span><br><span class="line"><span class="comment">//同</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span> <span class="comment">//为了避免混淆，尽量加上括号</span></span><br></pre></td></tr></table></figure>
<p>Object 对象具有下列<strong>属性</strong>：</p>
<ul>
<li>constructor<br>对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。</li>
<li>Prototype<br>对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。</li>
</ul>
<p>Object 对象还具有下列<strong>方法</strong>：</p>
<ul>
<li>hasOwnProperty(property)<br>判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，o.hasOwnProperty(“name”)）</li>
<li>IsPrototypeOf(object)<br>判断该对象是否为另一个对象的原型。</li>
<li>PropertyIsEnumerable()<br>判断给定的属性是否可以用 for…in 语句进行枚举。</li>
<li>ToString()<br>返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。</li>
<li>ValueOf()<br>返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。</li>
</ul>
<p>注释：上面列出的每种属性和方法都会被其他对象覆盖。</p>
<h2><span id="boolean-dui-xiang">Boolean 对象</span><a href="#boolean-dui-xiang" class="header-anchor">#</a></h2><p>Boolean 对象是 Boolean 原始类型的引用类型。</p>
<p>要创建 Boolean 对象，只需要传递 Boolean 值作为参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oBooleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2><span id="number-dui-xiang">Number 对象</span><a href="#number-dui-xiang" class="header-anchor">#</a></h2><p>正如你可能想到的，Number 对象是 Number 原始类型的引用类型。要创建 Number 对象，采用下列代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br></pre></td></tr></table></figure>
<p>您应该已认出本章前面小节中讨论特殊值（如 Number.MAX_VALUE）时提到的 Number 对象。所有特殊值都是 Number 对象的静态属性。</p>
<p>要得到数字对象的 Number <code>原始值</code>，只需要使用 valueOf() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNumber = oNumberObject.valueOf();</span><br></pre></td></tr></table></figure>
<h3><span id="tofixed-fang-fa">toFixed() 方法</span><a href="#tofixed-fang-fa" class="header-anchor">#</a></h3><p>toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toFixed(<span class="number">2</span>));  <span class="comment">//输出 &quot;68.00&quot;</span></span><br></pre></td></tr></table></figure>
<p>toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误</p>
<h3><span id="toexponential-fang-fa">toExponential() 方法</span><a href="#toexponential-fang-fa" class="header-anchor">#</a></h3><p>与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。</p>
<p>与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toExponential(<span class="number">1</span>));  <span class="comment">//输出 &quot;6.8e+1&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x10¹。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。</p>
<h3><span id="toprecision-fang-fa-gt-qu-n-wei-you-xiao-shu">toPrecision() 方法 =&gt; 取N位有效数</span><a href="#toprecision-fang-fa-gt-qu-n-wei-you-xiao-shu" class="header-anchor">#</a></h3><p>toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">1</span>));  <span class="comment">//输出 &quot;7e+1&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">2</span>));  <span class="comment">//输出 &quot;68&quot;</span></span><br></pre></td></tr></table></figure>
<p>当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">3</span>));  <span class="comment">//输出 &quot;68.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。</p>
<p>toFixed()、toExponential() 和 toPrecision() 方法都会进行<code>舍入</code>操作，以便用正确的小数位数正确地表示一个数。</p>
<p><em>提示</em>：与 Boolean 对象相似，Number 对象也很重要，不过应该少用这种对象，以避免潜在的问题。只要可能，都使用数字的原始表示法。</p>
<h2><span id="string-dui-xiang">String 对象</span><a href="#string-dui-xiang" class="header-anchor">#</a></h2><p>String 对象是 String 原始类型的对象表示法，它是以下方式创建的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3><span id="length">length</span><a href="#length" class="header-anchor">#</a></h3><p>String 对象具有属性 length，它是字符串中的字符个数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.length);	<span class="comment">//输出 &quot;11&quot;</span></span><br><span class="line">alert(<span class="string">&#x27;龍&#x27;</span>.length) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这个例子输出的是 “11”，即 “hello world” 中的字符个数。注意，<code>即使字符串包含双字节的字符（与 ASCII 字符相对，ASCII 字符只占用一个字节），每个字符也只算一个字符</code>。</p>
<h3><span id="charat-he-charcodeat-fang-fa">charAt() 和 charCodeAt() 方法</span><a href="#charat-he-charcodeat-fang-fa" class="header-anchor">#</a></h3><p>首先，两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。</p>
<p>charAt() 方法返回的是包含指定位置处的字符的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.charAt(<span class="number">1</span>));	<span class="comment">//输出 &quot;e&quot;</span></span><br></pre></td></tr></table></figure>
<p>在字符串 “hello world” 中，位置 1 处的字符是 “e”。在“ECMAScript 原始类型”这一节中我们讲过，第一个字符的位置是 0，第二个字符的位置是 1，依此类推。因此，调用 charAt(1) 返回的是 “e”。</p>
<p>如果想得到的不是字符，而是<code>字符代码</code>，那么可以调用 charCodeAt() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.charCodeAt(<span class="number">1</span>));	<span class="comment">//输出 &quot;101&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子输出 “101”，即小写字母 “e” 的字符代码。</p>
<h4><span id="es6">es6</span><a href="#es6" class="header-anchor">#</a></h4><p>es6中字符串追加了unicode的支持<br>遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot; &quot;</span></span><br><span class="line"><span class="comment">// &quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br></pre></td></tr></table></figure>
<h3><span id="concat-fang-fa">concat() 方法</span><a href="#concat-fang-fa" class="header-anchor">#</a></h3><p>用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，<code>保持原始的 String 对象不变</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sResult = oStringObject.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">alert(sResult);		<span class="comment">//输出 &quot;hello world&quot;</span></span><br><span class="line">alert(oStringObject);	<span class="comment">//输出 &quot;hello &quot;</span></span><br></pre></td></tr></table></figure>
<h3><span id="indexof-he-lastindexof-fang-fa">indexOf() 和 lastIndexOf() 方法</span><a href="#indexof-he-lastindexof-fang-fa" class="header-anchor">#</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">alert(oStringObject.indexOf(<span class="string">&quot;o&quot;</span>));		输出 <span class="string">&quot;4&quot;</span></span><br><span class="line">alert(oStringObject.lastIndexOf(<span class="string">&quot;o&quot;</span>));	输出 <span class="string">&quot;7&quot;</span></span><br><span class="line">alert(oStringObject.lastIndexOf(<span class="string">&quot;orl&quot;</span>));	输出 <span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure>
<h3><span id="localecompare-fang-fa">localeCompare() 方法</span><a href="#localecompare-fang-fa" class="header-anchor">#</a></h3><p>下一个方法是 localeCompare()，对字符串进行排序。该方法有一个参数 - 要进行比较的字符串，返回的是下列三个值之一：</p>
<ul>
<li>如果 String 对象按照字母顺序排在参数中的字符串之前，返回负数。</li>
<li>如果 String 对象等于参数中的字符串，返回 0</li>
<li>如果 String 对象按照字母顺序排在参数中的字符串之后，返回正数。</li>
</ul>
<p>注释：如果返回负数，那么最常见的是 -1，不过真正返回的是由实现决定的。如果返回正数，那么同样的，最常见的是 1，不过真正返回的是由实现决定的。<br>localeCompare() 方法的独特之处在于，实现所处的区域（locale，兼指国家/地区和语言）确切说明了这种方法运行的方式。在美国，英语是 ECMAScript 实现的标准语言，localeCompare() 是区分大小写的，<code>大写字母在字母顺序上排在小写字母之后</code>。不过，在其他区域，情况可能并非如此。<br>示例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">alert(oStringObject.localeCompare(<span class="string">&quot;brick&quot;</span>));		<span class="comment">//输出 &quot;1&quot;</span></span><br><span class="line">alert(oStringObject.localeCompare(<span class="string">&quot;yellow&quot;</span>));		<span class="comment">//输出 &quot;0&quot;</span></span><br><span class="line">alert(oStringObject.localeCompare(<span class="string">&quot;zoo&quot;</span>));		<span class="comment">//输出 &quot;-1&quot;</span></span><br></pre></td></tr></table></figure>
<h3><span id="slice-he-substring">slice() 和 substring()</span><a href="#slice-he-substring" class="header-anchor">#</a></h3><p>ECMAScript 提供了两种方法从子串创建字符串值，即 slice() 和 substring()。这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。如果省略第二个参数，终止位就默认为字符串的长度。</p>
<p>与 concat() 方法一样，slice() 和 substring() 方法都<code>不改变 String 对象自身的值</code>。它们只返回原始的 String 值，保持 String 对象不变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.slice(<span class="string">&quot;3&quot;</span>));		<span class="comment">//输出 &quot;lo world&quot;</span></span><br><span class="line">alert(oStringObject.substring(<span class="string">&quot;3&quot;</span>));		<span class="comment">//输出 &quot;lo world&quot;</span></span><br><span class="line">alert(oStringObject.slice(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;7&quot;</span>));		<span class="comment">//输出 &quot;lo w&quot;</span></span><br><span class="line">alert(oStringObject.substring(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;7&quot;</span>));	<span class="comment">//输出 &quot;lo w&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，slice() 和 substring() 的用法相同，返回值也一样。当只有参数 3 时，两个方法返回的都是 “lo world”，因为 “hello” 中的第二个 “l” 位于位置 3 上。当有两个参数 “3” 和 “7” 时，两个方法返回的值都是 “lo w”（”world” 中的字母 “o” 位于位置 7 上，所以它不包括在结果中）。</p>
<p>为什么有两个功能完全相同的方法呢？事实上，这两个方法并不完全相同，不过只在<code>参数为负数时，它们处理参数的方式才稍有不同</code>。</p>
<p>对于负数参数，slice() 方法会用字符串的长度加上参数，substring() 方法则将其作为 0 处理（也就是说将忽略它）。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.slice(<span class="string">&quot;-3&quot;</span>));		<span class="comment">//输出 &quot;rld&quot;</span></span><br><span class="line">alert(oStringObject.substring(<span class="string">&quot;-3&quot;</span>));	<span class="comment">//输出 &quot;hello world&quot;</span></span><br><span class="line">alert(oStringObject.slice(<span class="string">&quot;3, -4&quot;</span>));		<span class="comment">//输出 &quot;lo w&quot;</span></span><br><span class="line">alert(oStringObject.substring(<span class="string">&quot;3, -4&quot;</span>));	<span class="comment">//输出 &quot;hel&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样即可看出 slice() 和 substring() 方法的主要不同。</p>
<p>当只有参数 -3 时，slice() 返回 “rld”，substring() 则返回 “hello world”。这是因为对于字符串 “hello world”，slice(“-3”) 将被转换成 slice(“8”)，而 substring(“-3”) 将被转换成 substring(“0”)。</p>
<p>同样，使用参数 3 和 -4 时，差别也很明显。slice() 将被转换成 slice(3, 7)，与前面的例子相同，返回 “lo w”。而 substring() 方法则将两个参数解释为 substring(3, 0)，实际上即 substring(0, 3)，因为 substring() 总把较小的数字作为起始位，较大的数字作为终止位。因此，substring(“3, -4”) 返回的是 “hel”。这里的最后一行代码用来说明如何使用这些方法。</p>
<h3><span id="tolowercase-tolocalelowercase-touppercase-he-tolocaleuppercase">toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()</span><a href="#tolowercase-tolocalelowercase-touppercase-he-tolocaleuppercase" class="header-anchor">#</a></h3><p>最后一套要讨论的方法涉及大小写转换。有 4 种方法用于执行大小写转换，即</p>
<ul>
<li>toLowerCase()</li>
<li>toLocaleLowerCase()</li>
<li>toUpperCase()</li>
<li>toLocaleUpperCase()</li>
</ul>
<p>一般来说，如果不知道在以哪种编码运行一种语言，则使用区域特定的方法比较安全。</p>
<h3><span id="ti-shi">提示</span><a href="#ti-shi" class="header-anchor">#</a></h3><p>记住，<code>String 对象的所有属性和方法都可应用于 String 原始值上，因为它们是伪对象</code>。</p>
<h2><span id="instanceof-yun-suan-fu">instanceof 运算符</span><a href="#instanceof-yun-suan-fu" class="header-anchor">#</a></h2><p>在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。</p>
<p><code>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject <span class="keyword">instanceof</span> <span class="built_in">String</span>);	<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是 “true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。</p>
<h1><span id="deng-xing-yun-suan-fu">等性运算符</span><a href="#deng-xing-yun-suan-fu" class="header-anchor">#</a></h1><h2><span id="deng-hao-yu-fei-deng-hao">等号(==)与非等号(!==)</span><a href="#deng-hao-yu-fei-deng-hao" class="header-anchor">#</a></h2><p><code>执行类型转换</code>的规则如下：</p>
<ul>
<li>如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。</li>
<li>如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。</li>
<li>如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。</li>
<li>如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。</li>
</ul>
<p>在比较时，该运算符还遵守下列规则：</p>
<ul>
<li>值 null 和 undefined 相等。</li>
<li>在检查相等性时，不能把 null 和 undefined 转换成其他值。</li>
<li>如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。</li>
<li>如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span>	<span class="comment">//true</span></span><br><span class="line"><span class="string">&quot;NaN&quot;</span> == <span class="literal">NaN</span>	<span class="comment">//false</span></span><br><span class="line"><span class="number">5</span> == <span class="literal">NaN</span>	<span class="comment">//false</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>	<span class="comment">//false</span></span><br><span class="line"><span class="literal">NaN</span> != <span class="literal">NaN</span>	<span class="comment">//true</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>	<span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">1</span>	<span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">2</span>	<span class="comment">//false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span>	<span class="comment">//false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span>	<span class="comment">//false</span></span><br><span class="line"><span class="string">&quot;5&quot;</span> == <span class="number">5</span>	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2><span id="quan-deng-hao-yu-fei-quan-deng-hao">全等号与非全等号</span><a href="#quan-deng-hao-yu-fei-quan-deng-hao" class="header-anchor">#</a></h2><p>这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，<code>不执行类型转换</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sNum = <span class="string">&quot;66&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">66</span>;</span><br><span class="line">alert(sNum == iNum);	<span class="comment">//输出 &quot;true&quot;</span></span><br><span class="line">alert(sNum === iNum);	<span class="comment">//输出 &quot;false&quot;</span></span><br><span class="line">alert(sNum !== iNum);	<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<h1><span id="function">Function</span><a href="#function" class="header-anchor">#</a></h1><h2><span id="length-shu-xing">length属性</span><a href="#length-shu-xing" class="header-anchor">#</a></h2><p>ECMAScript 定义的属性 length 声明了函数期望的参数个数。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">iNum</span>) </span>&#123;</span><br><span class="line">  alert(iNum + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(doAdd.length);	<span class="comment">//输出 &quot;1&quot;</span></span><br><span class="line">alert(sayHi.length);	<span class="comment">//输出 &quot;0&quot;</span></span><br></pre></td></tr></table></figure>
<h2><span id="function-dui-xiang">Function 对象</span><a href="#function-dui-xiang" class="header-anchor">#</a></h2><p>有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的<code>源代码</code>，在调试时尤其有用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">iNum</span>) </span>&#123;</span><br><span class="line">  alert(iNum + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(doAdd.toString());</span><br></pre></td></tr></table></figure>
<h1><span id="bi-bao">闭包</span><a href="#bi-bao" class="header-anchor">#</a></h1><p>闭包，指的是词法表示包括不被计算的变量的函数，也就是说，<code>函数可以使用函数之外定义的变量</code>。</p>
<h2><span id="jian-dan-de-bi-bao">简单的闭包</span><a href="#jian-dan-de-bi-bao" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sMessage = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHelloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(sMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHelloWorld();</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，脚本被载入内存后，并没有为函数 sayHelloWorld() 计算变量 sMessage 的值。该函数捕获 sMessage 的值只是为了以后的使用，也就是说，解释程序知道在调用该函数时要检查 sMessage 的值。sMessage 将在函数调用 sayHelloWorld() 时（最后一行）被赋值，显示消息 “hello world”。</p>
<h2><span id="fu-za-de-bi-bao">复杂的闭包</span><a href="#fu-za-de-bi-bao" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iBaseNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNum</span>(<span class="params">iNum1, iNum2</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iNum1 + iNum2 + iBaseNum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doAdd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，函数 addNum() 包括函数 doAdd() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 iNum1 和 iNum2 以及全局变量 iBaseNum 的值。 addNum() 的最后一步调用了 doAdd()，把两个参数和全局变量相加，并返回它们的和。</p>
<p>这里要掌握的重要概念是，doAdd() 函数根本不接受参数，它使用的值是从执行环境中获取的。</p>
<h1><span id="dui-xiang-lei-xing">对象类型</span><a href="#dui-xiang-lei-xing" class="header-anchor">#</a></h1><h2><span id="ben-di-dui-xiang">本地对象</span><a href="#ben-di-dui-xiang" class="header-anchor">#</a></h2><ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>String</li>
<li>Boolean</li>
<li>Number</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
<li>EvalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h2><span id="nei-bu-dui-xiang">内部对象</span><a href="#nei-bu-dui-xiang" class="header-anchor">#</a></h2><p>即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。</p>
<h2><span id="su-zhu-dui-xiang">宿主对象</span><a href="#su-zhu-dui-xiang" class="header-anchor">#</a></h2><p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。</p>
<p>所有 BOM 和 DOM 对象都是宿主对象。</p>
<h1><span id="ji-cheng">继承</span><a href="#ji-cheng" class="header-anchor">#</a></h1><p>要用 ECMAScript 实现继承机制，您可以从要继承的基类入手。<code>所有开发者定义的类都可作为基类</code>。出于安全原因，<code>本地类和宿主类不能作为基类</code>，这样可以防止公用访问编译过的浏览器级的代码，因为这些代码可以被用于恶意攻击。</p>
<h2><span id="dui-xiang-mou-chong">对象冒充</span><a href="#dui-xiang-mou-chong" class="header-anchor">#</a></h2><p>构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 ClassA 构造函数成为 ClassB 的方法，然后调用它。ClassB 就会收到 ClassA 的构造函数中定义的属性和方法。例如，用下面的方式定义 ClassA 和 ClassB：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params">sColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = sColor;</span><br><span class="line">    <span class="built_in">this</span>.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.color);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.newMethod = ClassA;</span><br><span class="line">    <span class="built_in">this</span>.newMethod(sColor);</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.newMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，为 ClassA 赋予了方法 newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是 ClassB 构造函数的参数 sColor。最后一行代码删除了对 ClassA 的引用，这样以后就不能再调用它。</p>
<p><code>所有新属性和新方法都必须在删除了新方法的代码行后定义</code>。否则，可能会覆盖超类的相关属性和方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.newMethod = ClassA;</span><br><span class="line">    <span class="built_in">this</span>.newMethod(sColor);</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.newMethod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> ClassA(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> ClassB(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">objA.sayColor();	<span class="comment">//输出 &quot;blue&quot;</span></span><br><span class="line">objB.sayColor();	<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">objB.sayName();		<span class="comment">//输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure>
<h2><span id="dui-xiang-mou-chong-ke-yi-shi-xian-duo-chong-ji-cheng">对象冒充可以实现多重继承</span><a href="#dui-xiang-mou-chong-ke-yi-shi-xian-duo-chong-ji-cheng" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassZ</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.newMethod = ClassX;</span><br><span class="line">    <span class="built_in">this</span>.newMethod();</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.newMethod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.newMethod = ClassY;</span><br><span class="line">    <span class="built_in">this</span>.newMethod();</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.newMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法，ClassY 具有高优先级。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。</p>
<p>由于这种继承方法的流行，ECMAScript 的第三版为 Function 对象加入了两个方法，即 call() 和 apply()。</p>
<h2><span id="call">call()</span><a href="#call" class="header-anchor">#</a></h2><p>call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params">sPrefix,sSuffix</span>) </span>&#123;</span><br><span class="line">    alert(sPrefix + <span class="built_in">this</span>.color + sSuffix);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">sayColor.call(obj, <span class="string">&quot;The color is &quot;</span>, <span class="string">&quot;a very nice color indeed.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，函数 sayColor() 在对象外定义，即使它不属于任何对象，也可以引用关键字 this。对象 obj 的 color 属性等于 blue。调用 call() 方法时，第一个参数是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个和第三个参数是字符串。它们与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息 “The color is blue, a very nice color indeed.” 将被显示出来。</p>
<p>要与继承机制的对象冒充方法一起使用该方法，只需将前三行的赋值、调用和删除代码替换即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this.newMethod = ClassA;</span></span><br><span class="line">    <span class="comment">//this.newMethod(color);</span></span><br><span class="line">    <span class="comment">//delete this.newMethod;</span></span><br><span class="line">    ClassA.call(<span class="built_in">this</span>, sColor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们需要让 ClassA 中的关键字 this 等于新创建的 ClassB 对象，因此 this 是第一个参数。第二个参数 sColor 对两个类来说都是唯一的参数。</p>
<h2><span id="apply">apply()</span><a href="#apply" class="header-anchor">#</a></h2><p>apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params">sPrefix,sSuffix</span>) </span>&#123;</span><br><span class="line">    alert(sPrefix + <span class="built_in">this</span>.color + sSuffix);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">sayColor.apply(obj, <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;The color is &quot;</span>, <span class="string">&quot;a very nice color indeed.&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这个例子与前面的例子相同，只是现在调用的是 apply() 方法。调用 apply() 方法时，第一个参数仍是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个参数是由两个字符串构成的数组，与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息仍是 “The color is blue, a very nice color indeed.”，将被显示出来。</p>
<p>该方法也用于替换前三行的赋值、调用和删除新方法的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this.newMethod = ClassA;</span></span><br><span class="line">    <span class="comment">//this.newMethod(color);</span></span><br><span class="line">    <span class="comment">//delete this.newMethod;</span></span><br><span class="line">    ClassA.apply(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="built_in">Array</span>(sColor));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，第一个参数仍是 this，第二个参数是只有一个值 color 的数组。可以把 ClassB 的整个 arguments 对象作为第二个参数传递给 apply() 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this.newMethod = ClassA;</span></span><br><span class="line">    <span class="comment">//this.newMethod(color);</span></span><br><span class="line">    <span class="comment">//delete this.newMethod;</span></span><br><span class="line">    ClassA.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，只有超类中的参数顺序与子类中的参数顺序完全一致时才可以传递参数对象。如果不是，就必须创建一个单独的数组，按照正确的顺序放置参数。此外，还可使用 call() 方法。</p>
<h2><span id="yuan-xing-lian">原型链</span><a href="#yuan-xing-lian" class="header-anchor">#</a></h2><p>prototype 对象是个模板，要实例化的对象都以这个模板为基础。总而言之，<code>prototype 对象的任何属性和方法都被传递给那个类的所有实例</code>。原型链利用这种功能来实现继承机制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassA.prototype.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">ClassA.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();  <span class="comment">//mark </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里，把 ClassB 的 prototype 属性设置成 ClassA 的实例。这很有意思，因为想要 ClassA 的所有属性和方法，但又不想逐个将它们 ClassB 的 prototype 属性。还有比把 ClassA 的实例赋予 prototype 属性更好的方法吗？</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>注意</code>：</p>
<ul>
<li>调用 ClassA 的构造函数，没有给它传递参数。这在原型链中是标准做法。要<code>确保构造函数没有任何参数</code>。</li>
<li>子类的所有属性和方法都必须出现在 prototype 属性被<code>赋值后</code>，因为在它之前赋值的所有方法都会被删除。为什么？因为 prototype 属性被替换成了新对象，添加了新方法的原始对象将被销毁。所以，为 ClassB 类添加 name 属性和 sayName() 方法的代码如下：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();</span><br><span class="line"></span><br><span class="line">ClassB.prototype.name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">ClassB.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="hun-he">混合</span><a href="#hun-he" class="header-anchor">#</a></h2><code>对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了</code>。开发者如何选择呢？答案很简单，两者都用。<br>创建类的最好方式是用<code>构造函数定义属性</code>，<code>用原型定义方法</code>。这种方式同样适用于继承机制，用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params">sColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = sColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassA.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    ClassA.call(<span class="built_in">this</span>, sColor);   <span class="comment">//对象冒用</span></span><br><span class="line">    <span class="built_in">this</span>.name = sName;  <span class="comment">//构造函数定义属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();  <span class="comment">//原型链继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//继承后定义新的方法</span></span><br><span class="line">ClassB.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>前端基础之JS基本</p><p><a href="http://thetiso.github.io/2021/02/13/前端基础之JS基本/">http://thetiso.github.io/2021/02/13/前端基础之JS基本/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Thetiso</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-02-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-02-18</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/09/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92/"><span class="level-item">算法基础-递归</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Thetiso&#039;s Tech Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Thetiso</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>