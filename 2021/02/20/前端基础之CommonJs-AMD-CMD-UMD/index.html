<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>前端基础之CommonJs、AMD、CMD、UMD - Thetiso&#039;s Tech Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Thetiso&#039;s Tech Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Thetiso&#039;s Tech Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文主要介绍CommonJs、AMD、CMD、UMD以及由此衍生的require、export、exports、import等。"><meta property="og:type" content="blog"><meta property="og:title" content="前端基础之CommonJs、AMD、CMD、UMD"><meta property="og:url" content="http://thetiso.github.io/2021/02/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BCommonJs-AMD-CMD-UMD/"><meta property="og:site_name" content="Thetiso&#039;s Tech Blog"><meta property="og:description" content="本文主要介绍CommonJs、AMD、CMD、UMD以及由此衍生的require、export、exports、import等。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://thetiso.github.io/img/og_image.png"><meta property="article:published_time" content="2021-02-20T07:32:51.000Z"><meta property="article:modified_time" content="2021-02-23T09:07:12.494Z"><meta property="article:author" content="Thetiso"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://thetiso.github.io/2021/02/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BCommonJs-AMD-CMD-UMD/"},"headline":"Thetiso's Tech Blog","image":["http://thetiso.github.io/img/og_image.png"],"datePublished":"2021-02-20T07:32:51.000Z","dateModified":"2021-02-23T09:07:12.494Z","author":{"@type":"Person","name":"Thetiso"},"description":"本文主要介绍CommonJs、AMD、CMD、UMD以及由此衍生的require、export、exports、import等。"}</script><link rel="canonical" href="http://thetiso.github.io/2021/02/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BCommonJs-AMD-CMD-UMD/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Thetiso&#039;s Tech Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About Me</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-20T07:32:51.000Z" title="2021/2/20 下午3:32:51">2021-02-20</time>发表</span><span class="level-item"><time dateTime="2021-02-23T09:07:12.494Z" title="2021/2/23 下午5:07:12">2021-02-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a></span><span class="level-item">39 分钟读完 (大约5857个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">前端基础之CommonJs、AMD、CMD、UMD</h1><div class="content"><p>本文主要介绍CommonJs、AMD、CMD、UMD以及由此衍生的require、export、exports、import等。</p>
<a id="more"></a>

<div class="toc">

<!-- toc -->

<ul>
<li><a href="#commonjs">CommonJs</a><ul>
<li><a href="#module-exports-he-exports-de-qu-bie">module.exports和exports的区别</a></li>
</ul>
</li>
<li><a href="#amd-yi-bu-mo-kuai-ding-yi">AMD 异步模块定义</a></li>
<li><a href="#cmd">CMD</a><ul>
<li><a href="#cmd-yu-amd-de-qu-bie">CMD 与 AMD 的区别</a></li>
</ul>
</li>
<li><a href="#umd">UMD</a><ul>
<li><a href="#shi-xian">实现</a></li>
</ul>
</li>
<li><a href="#export">export</a><ul>
<li><a href="#ming-ming-shi-dao-chu">命名式导出</a><ul>
<li><a href="#zhu-yi">注意</a></li>
</ul>
</li>
<li><a href="#mo-ren-dao-chu-ding-yi-shi-dao-chu">默认导出（定义式导出）</a></li>
</ul>
</li>
<li><a href="#import-yin-ru-mo-kuai">import 引入模块</a><ul>
<li><a href="#ming-ming-shi-dao-ru">命名式导入</a></li>
<li><a href="#mo-ren-dao-ru">默认导入</a></li>
</ul>
</li>
<li><a href="#es6-zhong-de-module">ES6中的 Module</a><ul>
<li><a href="#gai-shu">概述</a></li>
<li><a href="#zi-dong-yan-ge-mo-shi">自动严格模式</a></li>
<li><a href="#export-zhu-yi-dian">export 注意点</a></li>
<li><a href="#import-zhu-yi-dian">import 注意点</a><ul>
<li><a href="#ti-sheng">提升</a></li>
<li><a href="#biao-da-shi-he-bian-liang">表达式和变量</a></li>
<li><a href="#zhi-jia-zai-bu-zhi-xing">只加载，不执行</a></li>
<li><a href="#dan-li-mo-shi">单例模式</a></li>
<li><a href="#yu-commonjs-require-hun-yong-shi-zhu-yi-dian">与CommonJS/require混用时注意点</a></li>
</ul>
</li>
<li><a href="#zheng-ti-jia-zai">整体加载</a></li>
<li><a href="#export-default">export default</a></li>
<li><a href="#export-fu-he-import">export 符合 import</a></li>
<li><a href="#mo-kuai-de-ji-cheng">模块的集成</a></li>
<li><a href="#kua-mo-kuai-chang-liang">跨模块常量</a></li>
</ul>
</li>
<li><a href="#can-kao-wen-dang">参考文档</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="commonjs">CommonJs</span><a href="#commonjs" class="header-anchor">#</a></h1><p>一种<code>服务器</code>端模块化的规范，Nodejs实现了这种规范，所以就说Nodejs支持CommonJS。</p>
<p>CommonJS分为三部分：</p>
<ul>
<li>require 模块加载</li>
<li>exports 模块导出</li>
<li>module 模块本身</li>
</ul>
<p>根据规范一个单独的JS文件就是一个module，每个单独的module是一个单独的作用域。也就是说在一个文件里定义的变量和函数都是私有，对其他文件不可见，除非用exports导出了。<br>在CommonJS中,暴露模块使用module.exports和exports，很多人不明白暴露对象为什么会有两个,后面会介绍区别</p>
<p>在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载和调用。</p>
<figure class="highlight js"><figcaption><span>math.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = &#123;</span><br><span class="line">	add: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = math</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>utils.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.toInt = <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) =&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(string) || <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">&#x27;math&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> &#123;toInt&#125;  = <span class="built_in">require</span>(<span class="string">&#x27;utils&#x27;</span>)</span><br><span class="line">math.add(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>正是由于CommonJS 使用的require方式的推动，才有了后面的AMD、CMD 也采用的require方式来引用模块的风格.</p>
<h2><span id="module-exports-he-exports-de-qu-bie">module.exports和exports的区别</span><a href="#module-exports-he-exports-de-qu-bie" class="header-anchor">#</a></h2><p>module和exports是Node.js给每个js文件内置的两个对象。</p>
<p>在node.js中打印console.log(module)可以看出 module 和 exports 都是node中提供的两个对象，其中module里包裹着exports</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module &#123;</span><br><span class="line">  id: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children: [],</span><br><span class="line">  paths:[] </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>实际上这两个对象指向同一块内存。这也就是说<code>module.exports和exports是等价的</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.age = <span class="number">18</span>;</span><br><span class="line"> <span class="built_in">module</span>.exports.age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure>
<p>这两种写法是一致的（都相当于给最初的空对象{}添加了一个属性，通过require得到的就是{age: 18}）。</p>
<p><strong>但是</strong></p>
<p><code>每个导出模块 node.js 默认会返回 return module.exports</code>;</p>
<p>当直接给module.exports或exports赋值时，就相当于改变了内存，两者指代的就不是同一内存，这样就会导致exports中的内容失效，因为<code>module.exports所指向的内存永远是真正的内存</code></p>
<p>直接给module.exports赋值导致内存改变，新生成的内存依然是真正的内存，那exports原先指向的内存就无效了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//song.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">name</span>: <span class="string">&#x27;樱花树下&#x27;</span>&#125;；</span><br><span class="line"><span class="built_in">exports</span> = &#123;<span class="attr">name</span>: <span class="string">&#x27;不吐不快&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">let</span> song= <span class="built_in">require</span>(<span class="string">&#x27;./song&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(song);<span class="comment">//输出：&#123;name: &#x27;樱花树下&#x27;&#125;</span></span><br></pre></td></tr></table></figure>
<p>直接给exports赋值导致内存改变，那么exports所指的内存就是无效内存，所以会返回module.exports空对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//song.js</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;<span class="attr">name</span>: <span class="string">&#x27;不吐不快&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">let</span> song= <span class="built_in">require</span>(<span class="string">&#x27;./song&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(song);<span class="comment">//输出：&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>so</strong><br>exports = module.exports 这个用来重新建立引用关系的<br>就是重新把无效内存指向真正内存 这样 exports 和 module.exports 就重新建立了联系</p>
<h1><span id="amd-yi-bu-mo-kuai-ding-yi">AMD  异步模块定义</span><a href="#amd-yi-bu-mo-kuai-ding-yi" class="header-anchor">#</a></h1><p><strong>产生背景：</strong><br>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<br>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。<br>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p>
<p><strong>AMD是<code>浏览器</code>上的规范.</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br><span class="line"><span class="comment">/* 参数解释</span></span><br><span class="line"><span class="comment">- id:字符串，模块名称(可选)</span></span><br><span class="line"><span class="comment">- dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</span></span><br><span class="line"><span class="comment">- factory: 工厂方法，返回一个模块函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// math.js  如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> x+y;</span><br><span class="line">　　&#125;;</span><br><span class="line">　　<span class="keyword">return</span> &#123;</span><br><span class="line">　　　　add: add</span><br><span class="line">　　&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</span></span><br><span class="line">define([<span class="string">&#x27;Lib&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">Lib</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　	Lib.doSomething();</span><br><span class="line">　	&#125;</span><br><span class="line">　		<span class="keyword">return</span> &#123;</span><br><span class="line">　　	foo : foo</span><br><span class="line">　	&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	第一个参数[module]，是一个数组，里面的成员就是要加载的模块；</span></span><br><span class="line"><span class="comment">	第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;math&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">　math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要有两个Javascript库实现了AMD规范：<code>require.js</code>和<code>curl.js</code>。</p>
<h1><span id="cmd">CMD</span><a href="#cmd" class="header-anchor">#</a></h1><p>CMD (Common Module Definition), 是<code>seajs</code>推崇的规范，CMD则是<code>依赖就近</code>，用的时候再require。它写起来是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">var</span> clock = <span class="built_in">require</span>(<span class="string">&#x27;clock&#x27;</span>); <span class="comment">//主要是这行代码</span></span><br><span class="line">  	clock.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMD与AMD一样，也是采用特定的define()函数来定义,用require方式来引用模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	id:字符串，模块名称(可选)</span></span><br><span class="line"><span class="comment">	dependencies: 是我们要载入的依赖模块(可选)，使用相对路径。,注意是数组格式</span></span><br><span class="line"><span class="comment">	factory: 工厂方法，返回一个模块函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">define(<span class="string">&#x27;hello&#x27;</span>, [<span class="string">&#x27;jquery&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  	<span class="comment">// 模块代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"> 	<span class="comment">// 模块代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="cmd-yu-amd-de-qu-bie">CMD 与 AMD 的区别</span><a href="#cmd-yu-amd-de-qu-bie" class="header-anchor">#</a></h2><p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。</p>
<ul>
<li>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；</li>
<li>而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</li>
</ul>
<h1><span id="umd">UMD</span><a href="#umd" class="header-anchor">#</a></h1><p>Universal Module Definition。从名字就可以看出来UMD做的是大一统的工作，把前后端加载糅合在了一起，提供了一个<code>前后端统一</code>的解决方案。<code>支持AMD和CommonJS模式</code>。</p>
<h2><span id="shi-xian">实现</span><a href="#shi-xian" class="header-anchor">#</a></h2><ol>
<li>先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。</li>
<li>再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。</li>
<li>前两个都不存在，则将模块公开到全局（window或global）。</li>
</ol>
<figure class="highlight js"><figcaption><span>example</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the module has no dependencies, the above pattern can be simplified to</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// AMD. Register as an anonymous module.</span></span><br><span class="line">        define([], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// Node. Does not work with strict CommonJS, but</span></span><br><span class="line">        <span class="comment">// only CommonJS-like environments that support module.exports,</span></span><br><span class="line">        <span class="comment">// like Node.</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Browser globals (root is window)</span></span><br><span class="line">        root.returnExports = factory();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Just return a value to define the module export.</span></span><br><span class="line">    <span class="comment">// This example returns an object, but the module</span></span><br><span class="line">    <span class="comment">// can return a function as the exported value.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h1><span id="export">export</span><a href="#export" class="header-anchor">#</a></h1><p>export语法声明用于<code>导出函数、对象、指定文件（或模块）的原始值</code>。<br>ES6标准发布后，module成为标准，标准使用是以export指令导出接口，以import引入模块.(浏览器)<br>但是在我们一贯的node模块中，我们依然采用的是CommonJS规范，使用require引入模块，使用module.exports/exports导出接口。</p>
<p>export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），<code>命名式导出每个模块可以多个，而默认导出每个模块仅一个</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> name1, variable2 <span class="keyword">as</span> name2, …, nameN &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1, name2, …, nameN; <span class="comment">// also var</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1 = …, name2 = …, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> expression;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">name1</span>(<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1 <span class="keyword">as</span> <span class="keyword">default</span>, … &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; import1 <span class="keyword">as</span> name1, import2 <span class="keyword">as</span> name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name1… nameN－导出的“标识符”。导出后，可以通过这个“标识符”在另一个模块中使用import引用</span></span><br><span class="line"><span class="comment">default－设置模块的默认导出。设置后import不通过“标识符”而直接引用默认导入</span></span><br><span class="line"><span class="comment">－继承模块并导出继承模块所有的方法和属性</span></span><br><span class="line"><span class="comment">as－重命名导出“标识符”</span></span><br><span class="line"><span class="comment">from－从已经存在的模块、脚本文件…导出</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2><span id="ming-ming-shi-dao-chu">命名式导出</span><a href="#ming-ming-shi-dao-chu" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; myFunction &#125;; <span class="comment">// 导出一个已定义的函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="built_in">Math</span>.sqrt(<span class="number">2</span>); <span class="comment">// 导出一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;article&#x27;</span>;  <span class="comment">//使用*和from关键字来实现的模块的继承：=&gt;这句话没怎么理解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;IT笔录&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="string">&#x27;http://itbilu.com&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> &#123;name <span class="keyword">as</span> siteName, domain&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="zhu-yi">注意</span><a href="#zhu-yi" class="header-anchor">#</a></h3><p>下面的语法有严重错误的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误演示</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span>; <span class="comment">// 绝对不可以</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">export</span> a;</span><br></pre></td></tr></table></figure>
<p>export在导出接口的时候，必须与模块内部的变量具有一一对应的关系。直接导出1没有任何意义，也不可能在import的时候有一个变量与之对应.<br>上面两种写法都会报错，因为没有提供对外的<code>接口</code>。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口。正确的写法是下面这样<br>export a虽然看上去成立，但是a的值是一个数字，根本无法完成解构，因此必须写成export {a}的形式。<code>即使a被赋值为一个function，也是不允许的</code>。而且，大部分风格都建议，模块中最好在末尾用一个export导出所有的接口，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;fun <span class="keyword">as</span> <span class="keyword">default</span>,a,b,c&#125;;</span><br></pre></td></tr></table></figure>
<p>正确的写法应该是这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> D = <span class="number">123</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> D;</span><br><span class="line"><span class="keyword">export</span> &#123; D <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者按照ES6的规则:export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同理, 以下写法也是对的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> firstName = <span class="string">&#x27;Michael&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> lastName = <span class="string">&#x27;Jackson&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="mo-ren-dao-chu-ding-yi-shi-dao-chu">默认导出（定义式导出）</span><a href="#mo-ren-dao-chu-ding-yi-shi-dao-chu" class="header-anchor">#</a></h2><p>默认导出也被称做定义式导出。命名式导出可以导出多个值，但在在import引用时，也要使用相同的名称来引用相应的值。而默认导出每个导出只有一个单一值，这个输出可以是一个函数、类或其它类型的值，这样在模块import导入时也会很容易引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 可以导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="title">class</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 也可以出一个类</span></span><br></pre></td></tr></table></figure>
<h1><span id="import-yin-ru-mo-kuai">import 引入模块</span><a href="#import-yin-ru-mo-kuai" class="header-anchor">#</a></h1><p>import语法声明用于从已导出的模块、脚本中导入<code>函数、对象、指定文件（或模块）的原始值</code>。</p>
<p>import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。</p>
<p>import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> defaultMember <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; member &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; member <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; member1 , member2 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; member1 , member2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultMember, &#123; member [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultMember, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	name－从将要导入模块中收到的导出值的名称</span></span><br><span class="line"><span class="comment">	member, memberN－从导出模块，导入指定名称的多个成员</span></span><br><span class="line"><span class="comment">	defaultMember－从导出模块，导入默认导出成员</span></span><br><span class="line"><span class="comment">	alias, aliasN－别名，对指定导入成员进行的重命名</span></span><br><span class="line"><span class="comment">	module-name－要导入的模块。是一个文件名</span></span><br><span class="line"><span class="comment">	as－重命名导入成员名称（“标识符”）</span></span><br><span class="line"><span class="comment">	from－从已经存在的模块、脚本文件等导入</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2><span id="ming-ming-shi-dao-ru">命名式导入</span><a href="#ming-ming-shi-dao-ru" class="header-anchor">#</a></h2><p><code>花括号里面的变量与export后面的变量一一对应</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;myMember&#125; <span class="keyword">from</span> <span class="string">&quot;my-module&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">&quot;my-module&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>通过*符号，我们可以导入模块中的全部属性和方法。当导入模块全部导出内容时，就是将导出模块（’my-module.js’）所有的导出绑定内容，插入到当前模块（’myModule’）的作用域中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&quot;my-module&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>导入模块对象时，也可以使用as对导入成员重命名，以方便在当前模块内使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reallyReallyLongModuleMemberName <span class="keyword">as</span> shortName&#125; <span class="keyword">from</span> <span class="string">&quot;my-module&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>导入多个成员时，同样可以使用别名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reallyReallyLongModuleMemberName <span class="keyword">as</span> shortName, anotherLongModuleName <span class="keyword">as</span> short&#125; <span class="keyword">from</span> <span class="string">&quot;my-module&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>导入一个模块，但不进行任何绑定：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;my-module&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="mo-ren-dao-ru">默认导入</span><a href="#mo-ren-dao-ru" class="header-anchor">#</a></h2><p>在模块导出时，可能会存在默认导出。同样的，在导入时可以使用import指令导出这些默认值。</p>
<p>直接导入默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myDefault <span class="keyword">from</span> <span class="string">&quot;my-module&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>也可以在命名空间导入和名称导入中，同时使用默认导入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> myDefault, * <span class="keyword">as</span> myModule <span class="keyword">from</span> <span class="string">&quot;my-module&quot;</span>; <span class="comment">// myModule 做为命名空间使用</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">import</span> myDefault, &#123;foo, bar&#125; <span class="keyword">from</span> <span class="string">&quot;my-module&quot;</span>; <span class="comment">// 指定成员导入</span></span><br></pre></td></tr></table></figure>
<h1><span id="es6-zhong-de-module">ES6中的 Module</span><a href="#es6-zhong-de-module" class="header-anchor">#</a></h1><h2><span id="gai-shu">概述</span><a href="#gai-shu" class="header-anchor">#</a></h2><p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为<code>浏览器和服务器通用</code>的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.stat;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.exists;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.readfile;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“<code>运行时加载</code>”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<p>ES6 模块不是对象，而是<code>通过export命令显式指定输出的代码，再通过import命令输入</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的实质是从fs模块加载 3 个方法，<code>其他方法不加载</code>。这种加载称为<code>“编译时加载”或者静态加载</code>，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</p>
<p>由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</p>
<p>除了静态加载带来的各种好处，ES6 模块还有以下<code>好处</code>。</p>
<ul>
<li>不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。</li>
<li>不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。</li>
</ul>
<h2><span id="zi-dong-yan-ge-mo-shi">自动严格模式</span><a href="#zi-dong-yan-ge-mo-shi" class="header-anchor">#</a></h2><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”;。</p>
<p>严格模式主要有以下限制。</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li>
<li>eval不会在它的外层作用域引入变量</li>
<li>eval和arguments不能被重新赋值</li>
<li>arguments不会自动反映函数参数的变化</li>
<li>不能使用arguments.callee</li>
<li>不能使用arguments.caller</li>
<li>禁止this指向全局对象</li>
<li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li>
<li>增加了保留字（比如protected、static和interface）</li>
</ul>
<p>其中，尤其需要注意this的限制。ES6 模块之中，<code>顶层的this指向undefined</code>，即不应该在顶层代码使用this。</p>
<h2><span id="export-zhu-yi-dian">export 注意点</span><a href="#export-zhu-yi-dian" class="header-anchor">#</a></h2><p>export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码输出变量foo，值为bar，500 毫秒之后变成baz。</p>
<h2><span id="import-zhu-yi-dian">import 注意点</span><a href="#import-zhu-yi-dian" class="header-anchor">#</a></h2><h3><span id="ti-sheng">提升</span><a href="#ti-sheng" class="header-anchor">#</a></h3><p>import命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。</p>
<h3><span id="biao-da-shi-he-bian-liang">表达式和变量</span><a href="#biao-da-shi-he-bian-liang" class="header-anchor">#</a></h3><p>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&#x27;f&#x27;</span> + <span class="string">&#x27;oo&#x27;</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module1&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module2&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。</p>
<h3><span id="zhi-jia-zai-bu-zhi-xing">只加载，不执行</span><a href="#zhi-jia-zai-bu-zhi-xing" class="header-anchor">#</a></h3><p>import语句会执行所加载的模块，因此可以有下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码仅仅执行lodash模块，但是不输入任何值。</p>
<h3><span id="dan-li-mo-shi">单例模式</span><a href="#dan-li-mo-shi" class="header-anchor">#</a></h3><p>如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码加载了两次lodash，但是只会执行一次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module模块。也就是说，import语句是 Singleton 模式。</p>
<h3><span id="yu-commonjs-require-hun-yong-shi-zhu-yi-dian">与CommonJS/require混用时注意点</span><a href="#yu-commonjs-require-hun-yong-shi-zhu-yi-dian" class="header-anchor">#</a></h3><p>目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是<code>最好不要这样做</code>。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.symbol&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.promise&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;React&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="zheng-ti-jia-zai">整体加载</span><a href="#zheng-ti-jia-zai" class="header-anchor">#</a></h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> circle <span class="keyword">from</span> <span class="string">&#x27;./circle&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;圆面积：&#x27;</span> + circle.area(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;圆周长：&#x27;</span> + circle.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure>
<h2><span id="export-default">export default</span><a href="#export-default" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">&#x27;crc32&#x27;</span>; <span class="comment">// 输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 输出</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;crc32&#125; <span class="keyword">from</span> <span class="string">&#x27;crc32&#x27;</span>; <span class="comment">// 输入</span></span><br></pre></td></tr></table></figure>
<p>上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。</p>
<p>export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应export default命令。</p>
<p>本质上，<code>export default就是输出一个叫做default的变量或方法</code>，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// import foo from &#x27;modules&#x27;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。<br>同样地，因为export default命令的本质是将后面的值，赋给default变量，所以可以直接将一个值写在export default之后。</p>
<p>如果想在一条import语句中，<code>同时输入默认方法和其他接口</code>，可以写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _, &#123; each, forEach &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应上面代码的export语句如下。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, iterator, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; each <span class="keyword">as</span> forEach &#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="export-fu-he-import">export 符合 import</span><a href="#export-fu-he-import" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以简单理解为</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="mo-kuai-de-ji-cheng">模块的集成</span><a href="#mo-kuai-de-ji-cheng" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;circle&#x27;</span>;  <span class="comment">//注意这里是export</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的export *，表示输出circle模块的<code>所有属性和方法</code>。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。</p>
<h2><span id="kua-mo-kuai-chang-liang">跨模块常量</span><a href="#kua-mo-kuai-chang-liang" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>回到es6 Module的初衷,当常量module.js文件非常大时，使用{}指明需要引用的内容，可以大大减少内存使用。 </p>
<h1><span id="can-kao-wen-dang">参考文档</span><a href="#can-kao-wen-dang" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/genglei101/article/details/52853980">1</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/p3118601/article/details/100150075">2</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fightjianxian/p/12151010.html">3</a><br><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module">阮一峰教程</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>前端基础之CommonJs、AMD、CMD、UMD</p><p><a href="http://thetiso.github.io/2021/02/20/前端基础之CommonJs-AMD-CMD-UMD/">http://thetiso.github.io/2021/02/20/前端基础之CommonJs-AMD-CMD-UMD/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Thetiso</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-02-20</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-02-23</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/26/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%B9%8BWorker/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">前端基础之Worker</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/19/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8BLRU%E5%AE%9E%E7%8E%B0/"><span class="level-item">前端进阶之LRU实现</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "d1e89ff032c998dc45e435032eb24e28",
            repo: "blog-site-comments",
            owner: "thetiso",
            clientID: "6fc0041775b201d6de94",
            clientSecret: "6e7e41e3c9efa52eaa1712f435f3890d4325596b",
            admin: ["thetiso"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Thetiso&#039;s Tech Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Thetiso</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>