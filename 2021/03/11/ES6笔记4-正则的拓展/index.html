<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ES6笔记4-正则的拓展 - Thetiso&#039;s Tech Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Thetiso&#039;s Tech Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Thetiso&#039;s Tech Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="mark: 正则的后行断言"><meta property="og:type" content="blog"><meta property="og:title" content="ES6笔记4-正则的拓展"><meta property="og:url" content="http://thetiso.github.io/2021/03/11/ES6%E7%AC%94%E8%AE%B04-%E6%AD%A3%E5%88%99%E7%9A%84%E6%8B%93%E5%B1%95/"><meta property="og:site_name" content="Thetiso&#039;s Tech Blog"><meta property="og:description" content="mark: 正则的后行断言"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://thetiso.github.io/img/og_image.png"><meta property="article:published_time" content="2021-03-11T06:44:48.000Z"><meta property="article:modified_time" content="2021-03-11T08:30:35.040Z"><meta property="article:author" content="Thetiso"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://thetiso.github.io/2021/03/11/ES6%E7%AC%94%E8%AE%B04-%E6%AD%A3%E5%88%99%E7%9A%84%E6%8B%93%E5%B1%95/"},"headline":"Thetiso's Tech Blog","image":["http://thetiso.github.io/img/og_image.png"],"datePublished":"2021-03-11T06:44:48.000Z","dateModified":"2021-03-11T08:30:35.040Z","author":{"@type":"Person","name":"Thetiso"},"description":"mark: 正则的后行断言"}</script><link rel="canonical" href="http://thetiso.github.io/2021/03/11/ES6%E7%AC%94%E8%AE%B04-%E6%AD%A3%E5%88%99%E7%9A%84%E6%8B%93%E5%B1%95/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Thetiso&#039;s Tech Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About Me</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-11T06:44:48.000Z" title="2021/3/11 下午2:44:48">2021-03-11</time>发表</span><span class="level-item"><time dateTime="2021-03-11T08:30:35.040Z" title="2021/3/11 下午4:30:35">2021-03-11</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/ES6/">ES6</a></span><span class="level-item">36 分钟读完 (大约5414个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">ES6笔记4-正则的拓展</h1><div class="content"><p><code>mark: 正则的后行断言</code> </p>
<a id="more"></a>

<div class="toc">

<!-- toc -->

<ul>
<li><a href="#regexp-gou-zao-han-shu-zai-es6-zhong-de-diao-zheng">RegExp 构造函数 =&gt; 在ES6中的调整</a></li>
<li><a href="#zi-fu-chuan-de-zheng-ze-fang-fa-nei-bu-diao-yong-zhi-xiang-regexp">字符串的正则方法 =&gt; 内部调用指向 RegExp</a></li>
<li><a href="#u-xiu-shi-fu-unicode-mo-shi">u 修饰符  =&gt; Unicode 模式</a><ul>
<li><a href="#1-dian-zi-fu">1. 点字符 <code>.</code></a></li>
<li><a href="#2-unicode-zi-fu-biao-shi-fa-shi-bie-da-gua-hao-biao-shi-fa">2. Unicode 字符表示法 =&gt; 识别大括号表示法</a></li>
<li><a href="#3-liang-ci-zheng-que-huo-qu-ge-shu">3. 量词  =&gt; 正确获取个数</a></li>
<li><a href="#4-yu-ding-yi-mo-shi">4. 预定义模式</a></li>
<li><a href="#5-i-xiu-shi-fu-shi-bie-fei-gui-fan-de-zi-fu">5. i 修饰符  =&gt;  识别非规范的字符</a></li>
<li><a href="#6-zhuan-yi">6. 转义</a></li>
</ul>
</li>
<li><a href="#regexp-prototype-unicode-shu-xing">RegExp.prototype.unicode 属性</a></li>
<li><a href="#y-xiu-shi-fu">y 修饰符</a><ul>
<li><a href="#lastindex-shu-xing">lastIndex 属性</a></li>
<li><a href="#cong-zi-fu-chuan-ti-qu-token-ci-yuan">从字符串提取 token（词元）</a></li>
</ul>
</li>
<li><a href="#regexp-prototype-sticky-shu-xing">RegExp.prototype.sticky 属性</a></li>
<li><a href="#regexp-prototype-flags-shu-xing">RegExp.prototype.flags 属性</a></li>
<li><a href="#s-xiu-shi-fu-dotall-mo-shi-ji-dian-dot-dai-biao-yi-qie-zi-fu">s 修饰符：dotAll 模式 =&gt; 即点（dot）代表一切字符</a></li>
<li><a href="#hou-xing-duan-yan">后行断言</a></li>
<li><a href="#unicode-shu-xing-lei">Unicode 属性类</a></li>
<li><a href="#ju-ming-zu-pi-pei">具名组匹配</a><ul>
<li><a href="#1-jie-gou-fu-zhi-he-ti-huan">1. 解构赋值和替换</a></li>
<li><a href="#yin-yong">引用</a></li>
</ul>
</li>
<li><a href="#zheng-ze-pi-pei-suo-yin-huan-zai-di-san-jie-duan-sui-ran-huan-mei-cheng-wei-zheng-shi-gui-fan-dan-ye-shi-chi-zao-de-shi-qing">正则匹配索引 =&gt; 还在第三阶段，虽然还没成为正式规范，但也是迟早的事情</a></li>
<li><a href="#string-prototype-matchall">String.prototype.matchAll()</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="regexp-gou-zao-han-shu-gt-zai-es6-zhong-de-diao-zheng">RegExp 构造函数 =&gt; 在ES6中的调整</span><a href="#regexp-gou-zao-han-shu-gt-zai-es6-zhong-de-diao-zheng" class="header-anchor">#</a></h1><p>在 ES5 中，RegExp构造函数的参数有两种情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br><span class="line"><span class="comment">//但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">//Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure>
<p>ES6中，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。<br>而且，<strong>返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">&#x27;i&#x27;</span>).flags</span><br><span class="line"><span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。</p>
<h1><span id="zi-fu-chuan-de-zheng-ze-fang-fa-gt-nei-bu-diao-yong-zhi-xiang-regexp">字符串的正则方法 =&gt; 内部调用指向 RegExp</span><a href="#zi-fu-chuan-de-zheng-ze-fang-fa-gt-nei-bu-diao-yong-zhi-xiang-regexp" class="header-anchor">#</a></h1><p>ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。<br>ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
<h1><span id="u-xiu-shi-fu-gt-unicode-mo-shi">u 修饰符  =&gt; Unicode 模式</span><a href="#u-xiu-shi-fu-gt-unicode-mo-shi" class="header-anchor">#</a></h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。</p>
<p><strong>该模式下部分正则表达式的行为也会有所改变</strong></p>
<h2><span id="1-dian-zi-fu">1. 点字符 <code>.</code></span><a href="#1-dian-zi-fu" class="header-anchor">#</a></h2><p>点（.）字符在正则表达式中，含义是除了换行符以外的<strong>任意单个字符</strong>。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line">/^.$/.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 </p>
<h2><span id="2-unicode-zi-fu-biao-shi-fa-gt-shi-bie-da-gua-hao-biao-shi-fa">2. Unicode 字符表示法 =&gt; 识别大括号表示法</span><a href="#2-unicode-zi-fu-biao-shi-fa-gt-shi-bie-da-gua-hao-biao-shi-fa" class="header-anchor">#</a></h2><p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/\u&#123;20BB7&#125;/u.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。</p>
<h2><span id="3-liang-ci-gt-zheng-que-huo-qu-ge-shu">3. 量词  =&gt; 正确获取个数</span><a href="#3-liang-ci-gt-zheng-que-huo-qu-ge-shu" class="header-anchor">#</a></h2><p>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/a&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/a&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;aa&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/.test(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/u.test(<span class="string">&#x27;𠮷𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2><span id="4-yu-ding-yi-mo-shi">4. 预定义模式</span><a href="#4-yu-ding-yi-mo-shi" class="header-anchor">#</a></h2><p>u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/^\S$/.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/^\S$/u.test(<span class="string">&#x27;𠮷&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。<br>利用这一点，可以写出一个正确返回字符串长度的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line">  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷𠮷&#x27;</span>;</span><br><span class="line">s.length <span class="comment">// 4</span></span><br><span class="line">codePointLength(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2><span id="5-i-xiu-shi-fu-gt-shi-bie-fei-gui-fan-de-zi-fu">5. i 修饰符  =&gt;  识别非规范的字符</span><a href="#5-i-xiu-shi-fu-gt-shi-bie-fei-gui-fan-de-zi-fu" class="header-anchor">#</a></h2><p>有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/i.test(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">&#x27;\u212A&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，不加u修饰符，就无法识别非规范的K字符。</p>
<h2><span id="6-zhuan-yi">6. 转义</span><a href="#6-zhuan-yi" class="header-anchor">#</a></h2><p><code>mark  没理解其用意</code><br>没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义,）无效，而在u模式会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\,<span class="regexp">/ /</span><span class="regexp">/ /</span>\,/</span><br><span class="line">/\,<span class="regexp">/u /</span><span class="regexp">/ 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。</p>
<h1><span id="regexp-prototype-unicode-shu-xing">RegExp.prototype.unicode 属性</span><a href="#regexp-prototype-unicode-shu-xing" class="header-anchor">#</a></h1><p>正则实例对象新增unicode属性，表示是否设置了u修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">r1.unicode <span class="comment">// false</span></span><br><span class="line">r2.unicode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。</p>
<h1><span id="y-xiu-shi-fu">y 修饰符</span><a href="#y-xiu-shi-fu" class="header-anchor">#</a></h1><p>除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。<br>y修饰符的作用与g修饰符类似，也是<strong>全局匹配</strong>，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须<strong>从剩余的第一个位置</strong>开始，这也就是“粘连”的涵义。  =&gt; 也就是说， 剩余的字符串的0开始匹配</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;aaa_aa_a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// [&quot;aaa&quot;]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// [&quot;aa&quot;]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。<br>由于<strong>g修饰没有位置要求</strong>，所以第二次执行会返回结果，而<strong>y修饰符要求匹配必须从头部开始</strong>(即_aa_a的第一个_开始匹配，巧了，正好不是字符a)，所以返回null。</p>
<h2><span id="lastindex-shu-xing">lastIndex 属性</span><a href="#lastindex-shu-xing" class="header-anchor">#</a></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line"><span class="comment">// 在3号位置匹配成功</span></span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。</p>
<p>y修饰符同样遵守lastIndex属性，但是要求<strong>必须在lastIndex指定的位置发现匹配</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/y</span>;</span><br><span class="line"><span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>) <span class="comment">// null</span></span><br><span class="line"><span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line"><span class="keyword">const</span> match = REGEX.exec(<span class="string">&#x27;xaya&#x27;</span>);</span><br><span class="line">match.index <span class="comment">// 3</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p><code>实际上，y修饰符号隐含了头部匹配的标志^</code>。 y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REGEX = <span class="regexp">/a/gy</span>;</span><br><span class="line"><span class="string">&#x27;aaxa&#x27;</span>.replace(REGEX, <span class="string">&#x27;-&#x27;</span>) <span class="comment">// &#x27;--xa&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。</p>
<p>单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a1a2a3&#x27;</span>.match(<span class="regexp">/a\d/y</span>) <span class="comment">// [&quot;a1&quot;]</span></span><br><span class="line"><span class="string">&#x27;a1a2a3&#x27;</span>.match(<span class="regexp">/a\d/gy</span>) <span class="comment">// [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]</span></span><br></pre></td></tr></table></figure>
<h2><span id="cong-zi-fu-chuan-ti-qu-token-ci-yuan">从字符串提取 token（词元）</span><a href="#cong-zi-fu-chuan-ti-qu-token-ci-yuan" class="header-anchor">#</a></h2><p>y修饰符确保了匹配之间不会有漏掉的字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TOKEN_Y = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line"><span class="keyword">const</span> TOKEN_G  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">&#x27;3 + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokenize(TOKEN_Y, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27; ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">&#x27;3x + 4&#x27;</span>)</span><br><span class="line"><span class="comment">// [ &#x27;3&#x27;, &#x27;+&#x27;, &#x27;4&#x27; ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。</p>
<h1><span id="regexp-prototype-sticky-shu-xing">RegExp.prototype.sticky 属性</span><a href="#regexp-prototype-sticky-shu-xing" class="header-anchor">#</a></h1><p>与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1><span id="regexp-prototype-flags-shu-xing">RegExp.prototype.flags 属性</span><a href="#regexp-prototype-flags-shu-xing" class="header-anchor">#</a></h1><p>ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的 source 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.source</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的 flags 属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.flags</span><br><span class="line"><span class="comment">// &#x27;gi&#x27;</span></span><br></pre></td></tr></table></figure>
<h1><span id="s-xiu-shi-fu-dotall-mo-shi-gt-ji-dian-dot-dai-biao-yi-qie-zi-fu">s 修饰符：dotAll 模式 =&gt; 即点（dot）代表一切字符</span><a href="#s-xiu-shi-fu-dotall-mo-shi-gt-ji-dian-dot-dai-biao-yi-qie-zi-fu" class="header-anchor">#</a></h1><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。<br>一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；<br>另一个是<strong>行终止符</strong>（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</p>
<ul>
<li>U+000A 换行符（\n）</li>
<li>U+000D 回车符（\r）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/.test(<span class="string">&#x27;foo\nbar&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">//上面代码中，因为.不匹配\n，所以正则表达式返回false。</span></span><br></pre></td></tr></table></figure>
很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/foo[^]bar/.test(<span class="string">&#x27;foo\nbar&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
这种解决方案毕竟不太符合直觉，<code>ES2018</code> 引入s修饰符，使得.可以匹配任意单个字符。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
这被称为dotAll模式，即点（dot）代表一切字符。<br>所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="comment">// const re = new RegExp(&#x27;foo.bar&#x27;, &#x27;s&#x27;);</span></span><br><span class="line"></span><br><span class="line">re.test(<span class="string">&#x27;foo\nbar&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">re.dotAll <span class="comment">// true</span></span><br><span class="line">re.flags <span class="comment">// &#x27;s&#x27;</span></span><br></pre></td></tr></table></figure>
/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。</li>
</ul>
<h1><span id="hou-xing-duan-yan">后行断言</span><a href="#hou-xing-duan-yan" class="header-anchor">#</a></h1><p><code>mark  后续研究下</code><br>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。</p>
<p>“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\d+(?=%)/.exec(<span class="string">&#x27;100% of US presidents have been male&#x27;</span>)  <span class="comment">// [&quot;100&quot;]</span></span><br><span class="line">/\d+(?!%)/.exec(<span class="string">&#x27;that’s all 44 of them&#x27;</span>)                 <span class="comment">// [&quot;44&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，“先行断言”括号之中的部分（(?=%)），是不计入返回结果的。</p>
<p>“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=$)\d+/。“后行否定断言”则与“先行否定断言”相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!$)\d+/。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=\$)\d+<span class="regexp">/.exec(&#x27;Benjamin Franklin is on the $100 bill&#x27;)  /</span><span class="regexp">/ [&quot;100&quot;]</span></span><br><span class="line"><span class="regexp">/</span>(?&lt;!\$)\d+<span class="regexp">/.exec(&#x27;it’s is worth about €90&#x27;)                /</span><span class="regexp">/ [&quot;90&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，“后行断言”的括号之中的部分（(?&lt;=$)），也是不计入返回结果。</p>
<p>下面的例子是使用后行断言进行字符串替换。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DOLLAR_PREFIX = <span class="regexp">/(?&lt;=\$)foo/g</span>;</span><br><span class="line"><span class="string">&#x27;$foo %foo foo&#x27;</span>.replace(RE_DOLLAR_PREFIX, <span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;$bar %foo foo&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，只有在美元符号后面的foo才会被替换。</p>
<p>“后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p>
<p>首先，后行断言的组匹配，与正常情况下结果是不一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(\d+)(\d+))$/.exec(<span class="string">&#x27;1053&#x27;</span>) <span class="comment">// [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]</span></span><br><span class="line">/^(\d+)(\d+)$/.exec(<span class="string">&#x27;1053&#x27;</span>) <span class="comment">// [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。</p>
<p>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(?&lt;=(o)d\<span class="number">1</span>)r/.exec(<span class="string">&#x27;hodor&#x27;</span>)  <span class="comment">// null</span></span><br><span class="line">/(?&lt;=\1d(o))r/.exec(<span class="string">&#x27;hodor&#x27;</span>)  <span class="comment">// [&quot;r&quot;, &quot;o&quot;]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p>
<h1><span id="unicode-shu-xing-lei">Unicode 属性类</span><a href="#unicode-shu-xing-lei" class="header-anchor">#</a></h1><p>ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">regexGreekSymbol.test(<span class="string">&#x27;π&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。<br>Unicode 属性类要指定属性名和属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName=UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<p>对于某些属性，可以只写属性名，或者只写属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;UnicodePropertyName&#125;</span><br><span class="line">\p&#123;UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<p><strong>\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符</strong>。<br>注意，这两种类只对 Unicode 有效，所以使用的时候<strong>一定要加上u修饰符</strong>。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。<br>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">&#x27;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。<br>\p{Number}甚至能匹配罗马数字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有数字</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">&#x27;²³¹¼½¾&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">&#x27;㉛㉜㉝&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">&#x27;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下面是其他一些例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;White_Space&#125;</span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.test(<span class="string">&#x27;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1><span id="ju-ming-zu-pi-pei">具名组匹配</span><a href="#ju-ming-zu-pi-pei" class="header-anchor">#</a></h1><p>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">&#x27;1999-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// &quot;1999&quot;</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// &quot;31&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“<strong>问号 + 尖括号 + 组名</strong>”（?<year>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。<br>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。<br>如果具名组没有匹配，那么对应的groups对象属性会是undefined。</year></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_OPT_A = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.as <span class="comment">// undefined</span></span><br><span class="line"><span class="string">&#x27;as&#x27;</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。</p>
<h2><span id="1-jie-gou-fu-zhi-he-ti-huan">1. 解构赋值和替换</span><a href="#1-jie-gou-fu-zhi-he-ti-huan" class="header-anchor">#</a></h2><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">groups</span>: &#123;one, two&#125;&#125; = <span class="regexp">/^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u</span>.exec(<span class="string">&#x27;foo:bar&#x27;</span>);</span><br><span class="line">one  <span class="comment">// foo</span></span><br><span class="line">two  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>字符串替换时，使用$&lt;组名&gt;引用具名组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;2015-01-02&#x27;</span>.replace(re, <span class="string">&#x27;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;02/01/2015&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。<br>replace方法的第二个参数也可以是函数，该函数的参数序列如下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;2015-01-02&#x27;</span>.replace(re, (</span><br><span class="line">   matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span><br><span class="line">   capture1, <span class="comment">// 第一个组匹配 2015</span></span><br><span class="line">   capture2, <span class="comment">// 第二个组匹配 01</span></span><br><span class="line">   capture3, <span class="comment">// 第三个组匹配 02</span></span><br><span class="line">   position, <span class="comment">// 匹配开始的位置 0</span></span><br><span class="line">   S, <span class="comment">// 原字符串 2015-01-02</span></span><br><span class="line">   groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span><br><span class="line"> ) =&gt; &#123;</span><br><span class="line"> <span class="keyword">let</span> &#123;day, month, year&#125; = groups;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;day&#125;</span>/<span class="subst">$&#123;month&#125;</span>/<span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>
<h2><span id="yin-yong">引用</span><a href="#yin-yong" class="header-anchor">#</a></h2><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>数字引用（\1）依然有效。 =&gt; 可以理解为 对应的第几个匹配项</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>; <span class="comment">//  \1 指的是&lt;word&gt;匹配到的文本</span></span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!ab&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这两种引用语法还可以同时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!abc!abc&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">&#x27;abc!abc!ab&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">/^(?&lt;word&gt;[a-z]+)!(?&lt;number&gt;[<span class="number">0</span>-<span class="number">9</span>]+)!\<span class="number">2</span>$/.test(<span class="string">&#x27;abc!3!abc&#x27;</span>)</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">/^(?&lt;word&gt;[a-z]+)!(?&lt;number&gt;[<span class="number">0</span>-<span class="number">9</span>]+)!\<span class="number">2</span>$/.test(<span class="string">&#x27;abc!3!4&#x27;</span>)</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">/^(?&lt;word&gt;[a-z]+)!(?&lt;number&gt;[<span class="number">0</span>-<span class="number">9</span>]+)!\<span class="number">2</span>$/.test(<span class="string">&#x27;abc!3!3&#x27;</span>)</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h1><span id="zheng-ze-pi-pei-suo-yin-gt-huan-zai-di-san-jie-duan-sui-ran-huan-mei-cheng-wei-zheng-shi-gui-fan-dan-ye-shi-chi-zao-de-shi-qing">正则匹配索引   =&gt; 还在第三阶段，虽然还没成为正式规范，但也是迟早的事情</span><a href="#zheng-ze-pi-pei-suo-yin-gt-huan-zai-di-san-jie-duan-sui-ran-huan-mei-cheng-wei-zheng-shi-gui-fan-dan-ye-shi-chi-zao-de-shi-qing" class="header-anchor">#</a></h1><p>正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的exec()方法，返回结果有一个index属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到。</p>
<p>现在有一个<strong>第三阶段提案</strong>，为exec()方法的返回结果加上indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.index <span class="comment">// 1</span></span><br><span class="line">result.indices <span class="comment">// [ [1, 3] ]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;zabbcdef&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/ab+(cd)/</span>;</span><br><span class="line"><span class="keyword">const</span> result = re.exec(text);</span><br><span class="line"></span><br><span class="line">result.indices <span class="comment">// [ [ 1, 6 ], [ 4, 6 ] ]</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，正则表达式包含一个组匹配，那么indices属性数组就有两个成员，<br>第一个成员是整个匹配结果（abbcd）的开始位置和结束位置，第二个成员是组匹配（cd）的开始位置和结束位置。</p>
<h1><span id="string-prototype-matchall">String.prototype.matchAll()</span><a href="#string-prototype-matchall" class="header-anchor">#</a></h1><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"><span class="keyword">var</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> matches = [];</span><br><span class="line"><span class="keyword">var</span> match;</span><br><span class="line"><span class="keyword">while</span> (match = regex.exec(string)) &#123;</span><br><span class="line">  matches.push(match);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matches</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],</span></span><br><span class="line"><span class="comment">//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],</span></span><br><span class="line"><span class="comment">//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，while循环取出每一轮的正则匹配，一共三轮。</p>
<p><strong>ES2020</strong>增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个<strong>遍历器</strong>（Iterator），而不是数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">&#x27;test1test2test3&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/t(e)(st(\d?))/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> string.matchAll(regex)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，<strong>如果匹配结果是一个很大的数组，那么遍历器比较节省资源</strong>。</p>
<p>遍历器转为数组是非常简单的，使用…运算符和Array.from()方法就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转为数组的方法一</span></span><br><span class="line">[...string.matchAll(regex)]</span><br><span class="line"><span class="comment">// 转为数组的方法二</span></span><br><span class="line"><span class="built_in">Array</span>.from(string.matchAll(regex))</span><br></pre></td></tr></table></figure></div><div class="article-licensing box"><div class="licensing-title"><p>ES6笔记4-正则的拓展</p><p><a href="http://thetiso.github.io/2021/03/11/ES6笔记4-正则的拓展/">http://thetiso.github.io/2021/03/11/ES6笔记4-正则的拓展/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Thetiso</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-03-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-03-11</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/11/ES6%E7%AC%94%E8%AE%B05-%E6%95%B0%E5%80%BC%E7%9A%84%E6%8B%93%E5%B1%95/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ES6笔记5-数值的拓展</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/11/ES6%E7%AC%94%E8%AE%B03-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%93%E5%B1%95%E4%B8%8E%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"><span class="level-item">ES6笔记3-字符串的拓展与新增方法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "0e2a2dfdef33e9de4b8afbd4b345f028",
            repo: "blog-site-comments",
            owner: "thetiso",
            clientID: "6fc0041775b201d6de94",
            clientSecret: "6e7e41e3c9efa52eaa1712f435f3890d4325596b",
            admin: ["thetiso"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Thetiso&#039;s Tech Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Thetiso</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>